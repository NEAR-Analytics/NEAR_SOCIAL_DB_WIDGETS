{"tx_hash": "B4hQXaMshu52tMFDUkEsZbXaHMcxoxfvz1mo4Jt8gTfT", "action_id_social": "C2QPuysUGqUHJANGrufJaEpMnBGUezKB3aLNUuGB9Kww-0-widget", "block_id": 82437088, "block_timestamp": "2023-01-07 22:33:46.038", "signer_id": "bozon.near", "widget_name": "WidgetHistory.CodeHistory", "source_code": "//props\n//props.pathToWidget - string (\"bozon.near/widget/PrivateMailBox\")\n//props.currentBlockHeight - number\n//props.prevBlockHeight? - number\n\nif (!props.pathToWidget || !props.currentBlockHeight)\n  return \"send pathToWidget and currentBlockHeight in props\";\n\n//code from this - https://github.com/jonTrent/PatienceDiff\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\n  //\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n  // function is used in preparation for determining the longest common\n  // subsequence.  Specifically, it first reduces the array range in question\n  // to unique values.\n  //\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\n  // array index i as the Map value.\n  //\n\n  function findUnique(arr, lo, hi) {\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n      let line = arr[i];\n\n      if (lineMap.has(line)) {\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n      } else {\n        lineMap.set(line, {\n          count: 1,\n          index: i,\n        });\n      }\n    }\n\n    lineMap.forEach((val, key) => {\n      if (val.count !== 1) {\n        lineMap.delete(key);\n      } else {\n        lineMap.set(key, val.index);\n      }\n    });\n\n    return lineMap;\n  }\n\n  //\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n  // down the aArray and bArray ranges first, before then walking the comparison\n  // between the two arrays.\n  //\n  // Returns an ordered Map, with the Map key as the common line between aArray\n  // and bArray, with the Map value as an object containing the array indexes of\n  // the matching unique lines.\n  //\n\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key) => {\n      if (mb.has(key)) {\n        ma.set(key, {\n          indexA: val,\n          indexB: mb.get(key),\n        });\n      } else {\n        ma.delete(key);\n      }\n    });\n\n    return ma;\n  }\n\n  //\n  // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n  // and determines the Longest Common Subsequence (LCS).\n  //\n  // Returns an ordered array of objects containing the array indexes of the\n  // matching lines for a LCS.\n  //\n\n  function longestCommonSubsequence(abMap) {\n    const ja = [];\n\n    // First, walk the list creating the jagged array.\n\n    abMap.forEach((val, key, map) => {\n      let i = 0;\n\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n        i++;\n      }\n\n      if (!ja[i]) {\n        ja[i] = [];\n      }\n\n      if (0 < i) {\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\n      }\n\n      ja[i].push(val);\n    });\n\n    // Now, pull out the longest common subsequence.\n\n    let lcs = [];\n\n    if (0 < ja.length) {\n      let n = ja.length - 1;\n      lcs = [ja[n][ja[n].length - 1]];\n\n      while (lcs[lcs.length - 1].prev) {\n        lcs.push(lcs[lcs.length - 1].prev);\n      }\n    }\n\n    return lcs.reverse();\n  }\n\n  // \"result\" is the array used to accumulate the aLines that are deleted, the\n  // lines that are shared between aLines and bLines, and the bLines that were\n  // inserted.\n\n  const result = [];\n  let deleted = 0;\n  let inserted = 0;\n\n  // aMove and bMove will contain the lines that don't match, and will be returned\n  // for possible searching of lines that moved.\n\n  const aMove = [];\n  const aMoveIndex = [];\n  const bMove = [];\n  const bMoveIndex = [];\n\n  //\n  // addToResult simply pushes the latest value onto the \"result\" array.  This\n  // array captures the diff of the line, aIndex, and bIndex from the aLines\n  // and bLines array.\n  //\n\n  function addToResult(aIndex, bIndex) {\n    if (bIndex < 0) {\n      aMove.push(aLines[aIndex]);\n      aMoveIndex.push(result.length);\n      deleted++;\n    } else if (aIndex < 0) {\n      bMove.push(bLines[bIndex]);\n      bMoveIndex.push(result.length);\n      inserted++;\n    }\n\n    result.push({\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n      aIndex: aIndex,\n      bIndex: bIndex,\n    });\n  }\n\n  //\n  // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n  // this function might recursively call recurseLCS to further match the lines\n  // between aLines and bLines.\n  //\n\n  function addSubMatch(aLo, aHi, bLo, bHi) {\n    // Match any lines at the beginning of aLines and bLines.\n\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n      addToResult(aLo++, bLo++);\n    }\n\n    // Match any lines at the end of aLines and bLines, but don't place them\n    // in the \"result\" array just yet, as the lines between these matches at\n    // the beginning and the end need to be analyzed first.\n\n    let aHiTemp = aHi;\n\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n      aHi--;\n      bHi--;\n    }\n\n    // Now, check to determine with the remaining lines in the subsequence\n    // whether there are any unique common lines between aLines and bLines.\n    //\n    // If not, add the subsequence to the result (all aLines having been\n    // deleted, and all bLines having been inserted).\n    //\n    // If there are unique common lines between aLines and bLines, then let's\n    // recursively perform the patience diff on the subsequence.\n\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n    if (uniqueCommonMap.size === 0) {\n      while (aLo <= aHi) {\n        addToResult(aLo++, -1);\n      }\n\n      while (bLo <= bHi) {\n        addToResult(-1, bLo++);\n      }\n    } else {\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n    }\n\n    // Finally, let's add the matches at the end to the result.\n\n    while (aHi < aHiTemp) {\n      addToResult(++aHi, ++bHi);\n    }\n  }\n\n  //\n  // recurseLCS finds the longest common subsequence (LCS) between the arrays\n  // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n  // recursively performs another LCS search (via addSubMatch), until there are\n  // none found, at which point the subsequence is dumped to the result.\n  //\n\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\n    const x = longestCommonSubsequence(\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\n    );\n\n    if (x.length === 0) {\n      addSubMatch(aLo, aHi, bLo, bHi);\n    } else {\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n      }\n\n      let i = 0;\n      for (; i < x.length - 1; i++) {\n        addSubMatch(\n          x[i].indexA,\n          x[i + 1].indexA - 1,\n          x[i].indexB,\n          x[i + 1].indexB - 1\n        );\n      }\n\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n      }\n    }\n  }\n\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n  if (diffPlusFlag) {\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n      aMove: aMove,\n      aMoveIndex: aMoveIndex,\n      bMove: bMove,\n      bMoveIndex: bMoveIndex,\n    };\n  }\n\n  return {\n    lines: result,\n    lineCountDeleted: deleted,\n    lineCountInserted: inserted,\n    lineCountMoved: 0,\n  };\n}\n\nconst currentCode = Social.get(\n  `${props.pathToWidget}`,\n  props.currentBlockHeight\n);\nconst prevCode = props.prevBlockHeight\n  ? Social.get(`${props.pathToWidget}`, props.prevBlockHeight)\n  : undefined;\n\nif (currentCode === null || prevCode === null) return \"Loading\";\n\nconst diffResult = patienceDiff(\n  prevCode ? prevCode.split(/\\r\\n|\\n/) : [],\n  currentCode.split(/\\r\\n|\\n/)\n);\n\nlet Line = styled.div`\n& > .col.md {\n    padding-top: 0px;\n    padding-left: 0px;\n    padding-bottom: 0px;\n}\n\n& > .col.md > pre {\n    margin: 0px;\n}\n\n& > .col.md > pre > div {\n    margin: 0px !important;\n\n    padding-top: ${(props) =>\n      !props.top ? \"0px !important;\" : \"1em !important;\"}\n    padding-bottom: ${(props) =>\n      !props.bottom ? \"0px !important;\" : \"1em !important;\"}\n\n    background: ${(props) =>\n      props.deleted\n        ? \"rgb(156 73 41) !important;\"\n        : (props) => (props.added ? \"rgb(0 95 67) !important;\" : \"\")};\n}\n\n`;\n\nreturn (\n  <div>\n    {diffResult.lines.map((el, index) => {\n      return (\n        <div>\n          <Line\n            className=\"no-gutter\"\n            added={el.aIndex === -1}\n            deleted={el.bIndex === -1}\n            deleted={el.bIndex === -1}\n            top={index == 0}\n            bottom={index == diffResult.lines.length - 1}\n          >\n            <div class=\"col md\">\n              <Markdown\n                text={`\n\\`\\`\\`jsx\n${el.line == \"\" ? \"\\n\" : el.line}\n`}\n              />\n            </div>\n          </Line>\n        </div>\n      );\n    })}\n  </div>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bozon.near/widget/WidgetHistory.CodeHistory", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.name": NaN, "metadata.tags.code": NaN, "metadata.tags.dev": NaN, "metadata.tags.markdown": NaN}