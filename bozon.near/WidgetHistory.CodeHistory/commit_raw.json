{"tx_hash": "3ahG8VJHL4hLMYZz3XGQ6S3NPFQCDzd8V6vBPxgfp9pZ", "action_id_social": "6CQ1wUcWznAsx64EjXyDH4FBhqdGFuZbWMX1rc4WkVdn-0-widget", "block_id": 82413215, "block_timestamp": "2023-01-07 15:04:48.586", "signer_id": "bozon.near", "widget_name": "WidgetHistory.CodeHistory", "source_code": "//props\r\n//props.pathToWidget - string (\"bozon.near/widget/PrivateMailBox\")\r\n//props.currentBlockHeight - number\r\n//props.prevBlockHeight? - number\r\n\r\nif (!props.pathToWidget || !props.currentBlockHeight)\r\n  return \"send pathToWidget and currentBlockHeight in props\";\r\n\r\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\r\n  //\r\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\r\n  // function is used in preparation for determining the longest common\r\n  // subsequence.  Specifically, it first reduces the array range in question\r\n  // to unique values.\r\n  //\r\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\r\n  // array index i as the Map value.\r\n  //\r\n\r\n  function findUnique(arr, lo, hi) {\r\n    const lineMap = new Map();\r\n\r\n    for (let i = lo; i <= hi; i++) {\r\n      let line = arr[i];\r\n\r\n      if (lineMap.has(line)) {\r\n        lineMap.get(line).count++;\r\n        lineMap.get(line).index = i;\r\n      } else {\r\n        lineMap.set(line, {\r\n          count: 1,\r\n          index: i,\r\n        });\r\n      }\r\n    }\r\n\r\n    lineMap.forEach((val, key) => {\r\n      if (val.count !== 1) {\r\n        lineMap.delete(key);\r\n      } else {\r\n        lineMap.set(key, val.index);\r\n      }\r\n    });\r\n\r\n    return lineMap;\r\n  }\r\n\r\n  //\r\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\r\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\r\n  // down the aArray and bArray ranges first, before then walking the comparison\r\n  // between the two arrays.\r\n  //\r\n  // Returns an ordered Map, with the Map key as the common line between aArray\r\n  // and bArray, with the Map value as an object containing the array indexes of\r\n  // the matching unique lines.\r\n  //\r\n\r\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\r\n    const ma = findUnique(aArray, aLo, aHi);\r\n    const mb = findUnique(bArray, bLo, bHi);\r\n\r\n    ma.forEach((val, key) => {\r\n      if (mb.has(key)) {\r\n        ma.set(key, {\r\n          indexA: val,\r\n          indexB: mb.get(key),\r\n        });\r\n      } else {\r\n        ma.delete(key);\r\n      }\r\n    });\r\n\r\n    return ma;\r\n  }\r\n\r\n  //\r\n  // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\r\n  // and determines the Longest Common Subsequence (LCS).\r\n  //\r\n  // Returns an ordered array of objects containing the array indexes of the\r\n  // matching lines for a LCS.\r\n  //\r\n\r\n  function longestCommonSubsequence(abMap) {\r\n    const ja = [];\r\n\r\n    // First, walk the list creating the jagged array.\r\n\r\n    abMap.forEach((val, key, map) => {\r\n      let i = 0;\r\n\r\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\r\n        i++;\r\n      }\r\n\r\n      if (!ja[i]) {\r\n        ja[i] = [];\r\n      }\r\n\r\n      if (0 < i) {\r\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\r\n      }\r\n\r\n      ja[i].push(val);\r\n    });\r\n\r\n    // Now, pull out the longest common subsequence.\r\n\r\n    let lcs = [];\r\n\r\n    if (0 < ja.length) {\r\n      let n = ja.length - 1;\r\n      lcs = [ja[n][ja[n].length - 1]];\r\n\r\n      while (lcs[lcs.length - 1].prev) {\r\n        lcs.push(lcs[lcs.length - 1].prev);\r\n      }\r\n    }\r\n\r\n    return lcs.reverse();\r\n  }\r\n\r\n  // \"result\" is the array used to accumulate the aLines that are deleted, the\r\n  // lines that are shared between aLines and bLines, and the bLines that were\r\n  // inserted.\r\n\r\n  const result = [];\r\n  let deleted = 0;\r\n  let inserted = 0;\r\n\r\n  // aMove and bMove will contain the lines that don't match, and will be returned\r\n  // for possible searching of lines that moved.\r\n\r\n  const aMove = [];\r\n  const aMoveIndex = [];\r\n  const bMove = [];\r\n  const bMoveIndex = [];\r\n\r\n  //\r\n  // addToResult simply pushes the latest value onto the \"result\" array.  This\r\n  // array captures the diff of the line, aIndex, and bIndex from the aLines\r\n  // and bLines array.\r\n  //\r\n\r\n  function addToResult(aIndex, bIndex) {\r\n    if (bIndex < 0) {\r\n      aMove.push(aLines[aIndex]);\r\n      aMoveIndex.push(result.length);\r\n      deleted++;\r\n    } else if (aIndex < 0) {\r\n      bMove.push(bLines[bIndex]);\r\n      bMoveIndex.push(result.length);\r\n      inserted++;\r\n    }\r\n\r\n    result.push({\r\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\r\n      aIndex: aIndex,\r\n      bIndex: bIndex,\r\n    });\r\n  }\r\n\r\n  //\r\n  // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\r\n  // this function might recursively call recurseLCS to further match the lines\r\n  // between aLines and bLines.\r\n  //\r\n\r\n  function addSubMatch(aLo, aHi, bLo, bHi) {\r\n    // Match any lines at the beginning of aLines and bLines.\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\r\n      addToResult(aLo++, bLo++);\r\n    }\r\n\r\n    // Match any lines at the end of aLines and bLines, but don't place them\r\n    // in the \"result\" array just yet, as the lines between these matches at\r\n    // the beginning and the end need to be analyzed first.\r\n\r\n    let aHiTemp = aHi;\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\r\n      aHi--;\r\n      bHi--;\r\n    }\r\n\r\n    // Now, check to determine with the remaining lines in the subsequence\r\n    // whether there are any unique common lines between aLines and bLines.\r\n    //\r\n    // If not, add the subsequence to the result (all aLines having been\r\n    // deleted, and all bLines having been inserted).\r\n    //\r\n    // If there are unique common lines between aLines and bLines, then let's\r\n    // recursively perform the patience diff on the subsequence.\r\n\r\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\r\n\r\n    if (uniqueCommonMap.size === 0) {\r\n      while (aLo <= aHi) {\r\n        addToResult(aLo++, -1);\r\n      }\r\n\r\n      while (bLo <= bHi) {\r\n        addToResult(-1, bLo++);\r\n      }\r\n    } else {\r\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\r\n    }\r\n\r\n    // Finally, let's add the matches at the end to the result.\r\n\r\n    while (aHi < aHiTemp) {\r\n      addToResult(++aHi, ++bHi);\r\n    }\r\n  }\r\n\r\n  //\r\n  // recurseLCS finds the longest common subsequence (LCS) between the arrays\r\n  // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\r\n  // recursively performs another LCS search (via addSubMatch), until there are\r\n  // none found, at which point the subsequence is dumped to the result.\r\n  //\r\n\r\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\r\n    const x = longestCommonSubsequence(\r\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\r\n    );\r\n\r\n    if (x.length === 0) {\r\n      addSubMatch(aLo, aHi, bLo, bHi);\r\n    } else {\r\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\r\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\r\n      }\r\n\r\n      let i = 0;\r\n      for (; i < x.length - 1; i++) {\r\n        addSubMatch(\r\n          x[i].indexA,\r\n          x[i + 1].indexA - 1,\r\n          x[i].indexB,\r\n          x[i + 1].indexB - 1\r\n        );\r\n      }\r\n\r\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\r\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\r\n      }\r\n    }\r\n  }\r\n\r\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\r\n\r\n  if (diffPlusFlag) {\r\n    return {\r\n      lines: result,\r\n      lineCountDeleted: deleted,\r\n      lineCountInserted: inserted,\r\n      lineCountMoved: 0,\r\n      aMove: aMove,\r\n      aMoveIndex: aMoveIndex,\r\n      bMove: bMove,\r\n      bMoveIndex: bMoveIndex,\r\n    };\r\n  }\r\n\r\n  return {\r\n    lines: result,\r\n    lineCountDeleted: deleted,\r\n    lineCountInserted: inserted,\r\n    lineCountMoved: 0,\r\n  };\r\n}\r\n\r\nconst currentCode = Social.get(\r\n  `${props.pathToWidget}`,\r\n  props.currentBlockHeight\r\n);\r\nconst prevCode = props.prevBlockHeight\r\n  ? Social.get(`${props.pathToWidget}`, props.prevBlockHeight)\r\n  : undefined;\r\n\r\nif (currentCode === null || prevCode === null) return \"Loading\";\r\n\r\nconst diffResult = patienceDiff(\r\n  prevCode ? prevCode.split(/\\r\\n|\\n/) : [],\r\n  currentCode.split(/\\r\\n|\\n/)\r\n);\r\n\r\nlet Line = styled.div`\r\n& > .col.md {\r\n    padding-top: 0px;\r\n    padding-left: 0px;\r\n    padding-bottom: 0px;\r\n}\r\n\r\n& > .col.md > pre {\r\n    margin: 0px;\r\n}\r\n\r\n& > .col.md > pre > div {\r\n    margin: 0px !important;\r\n\r\n    padding-top: ${(props) =>\r\n      !props.top ? \"0px !important;\" : \"1em !important;\"}\r\n    padding-bottom: ${(props) =>\r\n      !props.bottom ? \"0px !important;\" : \"1em !important;\"}\r\n\r\n    background: ${(props) =>\r\n      props.deleted\r\n        ? \"rgb(156 73 41) !important;\"\r\n        : (props) => (props.added ? \"rgb(0 95 67) !important;\" : \"\")};\r\n}\r\n\r\n`;\r\n\r\nreturn (\r\n  <div>\r\n    {diffResult.lines.map((el, index) => {\r\n      return (\r\n        <div>\r\n          <Line\r\n            className=\"row no-gutter\"\r\n            added={el.aIndex === -1}\r\n            deleted={el.bIndex === -1}\r\n            deleted={el.bIndex === -1}\r\n            top={index == 0}\r\n            bottom={index == diffResult.lines.length - 1}\r\n          >\r\n            <div class=\"col md\">\r\n              <Markdown\r\n                text={`\r\n\\`\\`\\`jsx\r\n${el.line == \"\" ? \"\\n\" : el.line}\r\n`}\r\n              />\r\n            </div>\r\n          </Line>\r\n        </div>\r\n      );\r\n    })}\r\n  </div>\r\n);\r\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bozon.near/widget/WidgetHistory.CodeHistory", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.name": NaN, "metadata.tags.code": NaN, "metadata.tags.dev": NaN, "metadata.tags.markdown": NaN}