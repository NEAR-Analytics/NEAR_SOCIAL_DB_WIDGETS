{"tx_hash": "9MW8Mdhz17E8L3RvCtCkwJFDzhcdodiRRiKapQhdFiTt", "action_id_social": "G9dQ1eQDUeqj9HJCkGUiW3LMZRMcw6FFgoX5zXqbKun4-0-widget", "block_id": 83322957, "block_timestamp": "2023-01-19 17:21:36.261", "signer_id": "bozon.near", "widget_name": "CodeDiff", "source_code": "/*\r\n---props---\r\n\r\nprops.currentCode: string,\r\nprops.prevCode?: string,\r\n\r\nprops.findUniqueResult(\r\n  lineCountDeleted: number, \r\n  lineCountInserted: inserted,\r\n  lineCountCurrentCode: number,\r\n  lineCountPrevCode: number,\r\n  allLineCount: number\r\n)?: function\r\n\r\nprops.showLineNumber?: bool\r\n\r\n*/\r\nif (!props.currentCode || !props.prevCode)\r\n  return \"send currentCode and prevCode in props\";\r\n\r\n//code from this - https://github.com/jonTrent/PatienceDiff\r\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\r\n  //\r\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\r\n  // function is used in preparation for determining the longest common\r\n  // subsequence.  Specifically, it first reduces the array range in question\r\n  // to unique values.\r\n  //\r\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\r\n  // array index i as the Map value.\r\n  //\r\n\r\n  function findUnique(arr, lo, hi) {\r\n    const lineMap = new Map();\r\n\r\n    for (let i = lo; i <= hi; i++) {\r\n      let line = arr[i];\r\n\r\n      if (lineMap.has(line)) {\r\n        lineMap.get(line).count++;\r\n        lineMap.get(line).index = i;\r\n      } else {\r\n        lineMap.set(line, {\r\n          count: 1,\r\n          index: i,\r\n        });\r\n      }\r\n    }\r\n\r\n    lineMap.forEach((val, key) => {\r\n      if (val.count !== 1) {\r\n        lineMap.delete(key);\r\n      } else {\r\n        lineMap.set(key, val.index);\r\n      }\r\n    });\r\n\r\n    return lineMap;\r\n  }\r\n\r\n  //\r\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\r\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\r\n  // down the aArray and bArray ranges first, before then walking the comparison\r\n  // between the two arrays.\r\n  //\r\n  // Returns an ordered Map, with the Map key as the common line between aArray\r\n  // and bArray, with the Map value as an object containing the array indexes of\r\n  // the matching unique lines.\r\n  //\r\n\r\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\r\n    const ma = findUnique(aArray, aLo, aHi);\r\n    const mb = findUnique(bArray, bLo, bHi);\r\n\r\n    ma.forEach((val, key) => {\r\n      if (mb.has(key)) {\r\n        ma.set(key, {\r\n          indexA: val,\r\n          indexB: mb.get(key),\r\n        });\r\n      } else {\r\n        ma.delete(key);\r\n      }\r\n    });\r\n\r\n    return ma;\r\n  }\r\n\r\n  //\r\n  // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\r\n  // and determines the Longest Common Subsequence (LCS).\r\n  //\r\n  // Returns an ordered array of objects containing the array indexes of the\r\n  // matching lines for a LCS.\r\n  //\r\n\r\n  function longestCommonSubsequence(abMap) {\r\n    const ja = [];\r\n\r\n    // First, walk the list creating the jagged array.\r\n\r\n    abMap.forEach((val, key, map) => {\r\n      let i = 0;\r\n\r\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\r\n        i++;\r\n      }\r\n\r\n      if (!ja[i]) {\r\n        ja[i] = [];\r\n      }\r\n\r\n      if (0 < i) {\r\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\r\n      }\r\n\r\n      ja[i].push(val);\r\n    });\r\n\r\n    // Now, pull out the longest common subsequence.\r\n\r\n    let lcs = [];\r\n\r\n    if (0 < ja.length) {\r\n      let n = ja.length - 1;\r\n      lcs = [ja[n][ja[n].length - 1]];\r\n\r\n      while (lcs[lcs.length - 1].prev) {\r\n        lcs.push(lcs[lcs.length - 1].prev);\r\n      }\r\n    }\r\n\r\n    return lcs.reverse();\r\n  }\r\n\r\n  // \"result\" is the array used to accumulate the aLines that are deleted, the\r\n  // lines that are shared between aLines and bLines, and the bLines that were\r\n  // inserted.\r\n\r\n  const result = [];\r\n  let deleted = 0;\r\n  let inserted = 0;\r\n\r\n  // aMove and bMove will contain the lines that don't match, and will be returned\r\n  // for possible searching of lines that moved.\r\n\r\n  const aMove = [];\r\n  const aMoveIndex = [];\r\n  const bMove = [];\r\n  const bMoveIndex = [];\r\n\r\n  //\r\n  // addToResult simply pushes the latest value onto the \"result\" array.  This\r\n  // array captures the diff of the line, aIndex, and bIndex from the aLines\r\n  // and bLines array.\r\n  //\r\n\r\n  function addToResult(aIndex, bIndex) {\r\n    if (bIndex < 0) {\r\n      aMove.push(aLines[aIndex]);\r\n      aMoveIndex.push(result.length);\r\n      deleted++;\r\n    } else if (aIndex < 0) {\r\n      bMove.push(bLines[bIndex]);\r\n      bMoveIndex.push(result.length);\r\n      inserted++;\r\n    }\r\n\r\n    result.push({\r\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\r\n      aIndex: aIndex,\r\n      bIndex: bIndex,\r\n    });\r\n  }\r\n\r\n  //\r\n  // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\r\n  // this function might recursively call recurseLCS to further match the lines\r\n  // between aLines and bLines.\r\n  //\r\n\r\n  function addSubMatch(aLo, aHi, bLo, bHi) {\r\n    // Match any lines at the beginning of aLines and bLines.\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\r\n      addToResult(aLo++, bLo++);\r\n    }\r\n\r\n    // Match any lines at the end of aLines and bLines, but don't place them\r\n    // in the \"result\" array just yet, as the lines between these matches at\r\n    // the beginning and the end need to be analyzed first.\r\n\r\n    let aHiTemp = aHi;\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\r\n      aHi--;\r\n      bHi--;\r\n    }\r\n\r\n    // Now, check to determine with the remaining lines in the subsequence\r\n    // whether there are any unique common lines between aLines and bLines.\r\n    //\r\n    // If not, add the subsequence to the result (all aLines having been\r\n    // deleted, and all bLines having been inserted).\r\n    //\r\n    // If there are unique common lines between aLines and bLines, then let's\r\n    // recursively perform the patience diff on the subsequence.\r\n\r\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\r\n\r\n    if (uniqueCommonMap.size === 0) {\r\n      while (aLo <= aHi) {\r\n        addToResult(aLo++, -1);\r\n      }\r\n\r\n      while (bLo <= bHi) {\r\n        addToResult(-1, bLo++);\r\n      }\r\n    } else {\r\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\r\n    }\r\n\r\n    // Finally, let's add the matches at the end to the result.\r\n\r\n    while (aHi < aHiTemp) {\r\n      addToResult(++aHi, ++bHi);\r\n    }\r\n  }\r\n\r\n  //\r\n  // recurseLCS finds the longest common subsequence (LCS) between the arrays\r\n  // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\r\n  // recursively performs another LCS search (via addSubMatch), until there are\r\n  // none found, at which point the subsequence is dumped to the result.\r\n  //\r\n\r\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\r\n    const x = longestCommonSubsequence(\r\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\r\n    );\r\n\r\n    if (x.length === 0) {\r\n      addSubMatch(aLo, aHi, bLo, bHi);\r\n    } else {\r\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\r\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\r\n      }\r\n\r\n      let i = 0;\r\n      for (; i < x.length - 1; i++) {\r\n        addSubMatch(\r\n          x[i].indexA,\r\n          x[i + 1].indexA - 1,\r\n          x[i].indexB,\r\n          x[i + 1].indexB - 1\r\n        );\r\n      }\r\n\r\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\r\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\r\n      }\r\n    }\r\n  }\r\n\r\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\r\n\r\n  if (diffPlusFlag) {\r\n    return {\r\n      lines: result,\r\n      lineCountDeleted: deleted,\r\n      lineCountInserted: inserted,\r\n      lineCountMoved: 0,\r\n      aMove: aMove,\r\n      aMoveIndex: aMoveIndex,\r\n      bMove: bMove,\r\n      bMoveIndex: bMoveIndex,\r\n    };\r\n  }\r\n\r\n  return {\r\n    lines: result,\r\n    lineCountDeleted: deleted,\r\n    lineCountInserted: inserted,\r\n    lineCountMoved: 0,\r\n  };\r\n}\r\n\r\nconst diffResult = patienceDiff(\r\n  props.prevCode ? props.prevCode.split(/\\r\\n|\\n/) : [],\r\n  props.currentCode.split(/\\r\\n|\\n/)\r\n);\r\n\r\nif (props.findUniqueResult)\r\n  props.findUniqueResult(\r\n    diffResult.lineCountDeleted,\r\n    diffResult.lineCountInserted,\r\n    props.currentCode.split(/\\r\\n|\\n/).length,\r\n    props.prevCode ? props.prevCode.split(/\\r\\n|\\n/).length : 0,\r\n    diffResult.lines.length\r\n  );\r\n\r\nlet Line = styled.div`\r\n& > .col.md {\r\n    padding-top: 0px;\r\n    padding-left: 0px;\r\n    padding-bottom: 0px;\r\n}\r\n\r\n& > .col.md > pre {\r\n    margin: 0px;\r\n}\r\n\r\n& > .col.md > pre > div {\r\n    margin: 0px !important;\r\n\r\n    padding-top: ${(props) =>\r\n      !props.top ? \"0px !important;\" : \"1em !important;\"}\r\n    padding-bottom: ${(props) =>\r\n      !props.bottom ? \"0px !important;\" : \"1em !important;\"}\r\n\r\n    background: ${(props) =>\r\n      props.deleted\r\n        ? \"rgb(156 73 41) !important;\"\r\n        : (props) => (props.added ? \"rgb(0 95 67) !important;\" : \"\")};\r\n}\r\n\r\n`;\r\n\r\nreturn (\r\n  <div>\r\n    <table class=\"table table-borderless\">\r\n      <tbody>\r\n        {diffResult.lines.map((el, index) => {\r\n          return (\r\n            <tr>\r\n              {props.showLineNumber && (\r\n                <td class=\"p-0\" style={{ \"user-select\": \"none\" }}>\r\n                  <Line\r\n                    className=\"no-gutter d-flex flex-row\"\r\n                    added={el.aIndex === -1}\r\n                    deleted={el.bIndex === -1}\r\n                    deleted={el.bIndex === -1}\r\n                    top={index == 0}\r\n                    bottom={index == diffResult.lines.length - 1}\r\n                  >\r\n                    <div class=\"col md\">\r\n                      <Markdown\r\n                        text={`\r\n\\`\\`\\`jsx\r\n${index + 1}\r\n`}\r\n                      />\r\n                    </div>\r\n                  </Line>\r\n                </td>\r\n              )}\r\n              <td class=\"p-0\">\r\n                <Line\r\n                  className=\"no-gutter d-flex flex-row\"\r\n                  added={el.aIndex === -1}\r\n                  deleted={el.bIndex === -1}\r\n                  deleted={el.bIndex === -1}\r\n                  top={index == 0}\r\n                  bottom={index == diffResult.lines.length - 1}\r\n                >\r\n                  <div class=\"col md\">\r\n                    <Markdown\r\n                      text={`\r\n\\`\\`\\`jsx\r\n${el.line == \"\" ? \"\\n\" : el.line}\r\n`}\r\n                    />\r\n                  </div>\r\n                </Line>\r\n              </td>\r\n            </tr>\r\n          );\r\n        })}\r\n      </tbody>\r\n    </table>\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bozon.near/widget/CodeDiff"}