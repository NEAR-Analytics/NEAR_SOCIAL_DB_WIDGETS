{"tx_hash": "CqmsPWDu347dQwQ7HidFtx8sETNRyYWcwkdm7M5wABrp", "action_id_social": "9jEu9nf4yA3dh76DDPS1VfgrfBTPyhawMKRfSLNpg6LF-0-widget", "block_id": 86181128, "block_timestamp": "2023-02-27 18:01:26.425", "signer_id": "bozon.near", "widget_name": "CodeDiff", "source_code": "/*\r\n---props---\r\n\r\ncurrentCode: string,\r\nprevCode?: string,\r\n\r\nfindUniqueResult(\r\n  lineCountDeleted: number, \r\n  lineCountInserted: inserted,\r\n  lineCountCurrentCode: number,\r\n  lineCountPrevCode: number,\r\n  allLineCount: number\r\n)?: function\r\n\r\naddStyle?: Object,\r\ndeleteStyle?: Object\r\n\r\nshowLineNumber?: bool\r\n\r\n*/\r\n\r\nif (typeof props?.currentCode !== \"string\")\r\n  return \"send {currentCode: string} in props\";\r\n\r\n//code from this - https://github.com/jonTrent/PatienceDiff\r\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\r\n  //\r\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\r\n  // function is used in preparation for determining the longest common\r\n  // subsequence.  Specifically, it first reduces the array range in question\r\n  // to unique values.\r\n  //\r\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\r\n  // array index i as the Map value.\r\n  //\r\n\r\n  function findUnique(arr, lo, hi) {\r\n    const lineMap = new Map();\r\n\r\n    for (let i = lo; i <= hi; i++) {\r\n      let line = arr[i];\r\n\r\n      if (lineMap.has(line)) {\r\n        lineMap.get(line).count++;\r\n        lineMap.get(line).index = i;\r\n      } else {\r\n        lineMap.set(line, {\r\n          count: 1,\r\n          index: i,\r\n        });\r\n      }\r\n    }\r\n\r\n    lineMap.forEach((val, key) => {\r\n      if (val.count !== 1) {\r\n        lineMap.delete(key);\r\n      } else {\r\n        lineMap.set(key, val.index);\r\n      }\r\n    });\r\n\r\n    return lineMap;\r\n  }\r\n\r\n  //\r\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\r\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\r\n  // down the aArray and bArray ranges first, before then walking the comparison\r\n  // between the two arrays.\r\n  //\r\n  // Returns an ordered Map, with the Map key as the common line between aArray\r\n  // and bArray, with the Map value as an object containing the array indexes of\r\n  // the matching unique lines.\r\n  //\r\n\r\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\r\n    const ma = findUnique(aArray, aLo, aHi);\r\n    const mb = findUnique(bArray, bLo, bHi);\r\n\r\n    ma.forEach((val, key) => {\r\n      if (mb.has(key)) {\r\n        ma.set(key, {\r\n          indexA: val,\r\n          indexB: mb.get(key),\r\n        });\r\n      } else {\r\n        ma.delete(key);\r\n      }\r\n    });\r\n\r\n    return ma;\r\n  }\r\n\r\n  //\r\n  // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\r\n  // and determines the Longest Common Subsequence (LCS).\r\n  //\r\n  // Returns an ordered array of objects containing the array indexes of the\r\n  // matching lines for a LCS.\r\n  //\r\n\r\n  function longestCommonSubsequence(abMap) {\r\n    const ja = [];\r\n\r\n    // First, walk the list creating the jagged array.\r\n\r\n    abMap.forEach((val, key, map) => {\r\n      let i = 0;\r\n\r\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\r\n        i++;\r\n      }\r\n\r\n      if (!ja[i]) {\r\n        ja[i] = [];\r\n      }\r\n\r\n      if (0 < i) {\r\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\r\n      }\r\n\r\n      ja[i].push(val);\r\n    });\r\n\r\n    // Now, pull out the longest common subsequence.\r\n\r\n    let lcs = [];\r\n\r\n    if (0 < ja.length) {\r\n      let n = ja.length - 1;\r\n      lcs = [ja[n][ja[n].length - 1]];\r\n\r\n      while (lcs[lcs.length - 1].prev) {\r\n        lcs.push(lcs[lcs.length - 1].prev);\r\n      }\r\n    }\r\n\r\n    return lcs.reverse();\r\n  }\r\n\r\n  // \"result\" is the array used to accumulate the aLines that are deleted, the\r\n  // lines that are shared between aLines and bLines, and the bLines that were\r\n  // inserted.\r\n\r\n  const result = [];\r\n  let deleted = 0;\r\n  let inserted = 0;\r\n\r\n  // aMove and bMove will contain the lines that don't match, and will be returned\r\n  // for possible searching of lines that moved.\r\n\r\n  const aMove = [];\r\n  const aMoveIndex = [];\r\n  const bMove = [];\r\n  const bMoveIndex = [];\r\n\r\n  //\r\n  // addToResult simply pushes the latest value onto the \"result\" array.  This\r\n  // array captures the diff of the line, aIndex, and bIndex from the aLines\r\n  // and bLines array.\r\n  //\r\n\r\n  function addToResult(aIndex, bIndex) {\r\n    if (bIndex < 0) {\r\n      aMove.push(aLines[aIndex]);\r\n      aMoveIndex.push(result.length);\r\n      deleted++;\r\n    } else if (aIndex < 0) {\r\n      bMove.push(bLines[bIndex]);\r\n      bMoveIndex.push(result.length);\r\n      inserted++;\r\n    }\r\n\r\n    result.push({\r\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\r\n      aIndex: aIndex,\r\n      bIndex: bIndex,\r\n    });\r\n  }\r\n\r\n  //\r\n  // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\r\n  // this function might recursively call recurseLCS to further match the lines\r\n  // between aLines and bLines.\r\n  //\r\n\r\n  function addSubMatch(aLo, aHi, bLo, bHi) {\r\n    // Match any lines at the beginning of aLines and bLines.\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\r\n      addToResult(aLo++, bLo++);\r\n    }\r\n\r\n    // Match any lines at the end of aLines and bLines, but don't place them\r\n    // in the \"result\" array just yet, as the lines between these matches at\r\n    // the beginning and the end need to be analyzed first.\r\n\r\n    let aHiTemp = aHi;\r\n\r\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\r\n      aHi--;\r\n      bHi--;\r\n    }\r\n\r\n    // Now, check to determine with the remaining lines in the subsequence\r\n    // whether there are any unique common lines between aLines and bLines.\r\n    //\r\n    // If not, add the subsequence to the result (all aLines having been\r\n    // deleted, and all bLines having been inserted).\r\n    //\r\n    // If there are unique common lines between aLines and bLines, then let's\r\n    // recursively perform the patience diff on the subsequence.\r\n\r\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\r\n\r\n    if (uniqueCommonMap.size === 0) {\r\n      while (aLo <= aHi) {\r\n        addToResult(aLo++, -1);\r\n      }\r\n\r\n      while (bLo <= bHi) {\r\n        addToResult(-1, bLo++);\r\n      }\r\n    } else {\r\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\r\n    }\r\n\r\n    // Finally, let's add the matches at the end to the result.\r\n\r\n    while (aHi < aHiTemp) {\r\n      addToResult(++aHi, ++bHi);\r\n    }\r\n  }\r\n\r\n  //\r\n  // recurseLCS finds the longest common subsequence (LCS) between the arrays\r\n  // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\r\n  // recursively performs another LCS search (via addSubMatch), until there are\r\n  // none found, at which point the subsequence is dumped to the result.\r\n  //\r\n\r\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\r\n    const x = longestCommonSubsequence(\r\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\r\n    );\r\n\r\n    if (x.length === 0) {\r\n      addSubMatch(aLo, aHi, bLo, bHi);\r\n    } else {\r\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\r\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\r\n      }\r\n\r\n      let i = 0;\r\n      for (; i < x.length - 1; i++) {\r\n        addSubMatch(\r\n          x[i].indexA,\r\n          x[i + 1].indexA - 1,\r\n          x[i].indexB,\r\n          x[i + 1].indexB - 1\r\n        );\r\n      }\r\n\r\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\r\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\r\n      }\r\n    }\r\n  }\r\n\r\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\r\n\r\n  if (diffPlusFlag) {\r\n    return {\r\n      lines: result,\r\n      lineCountDeleted: deleted,\r\n      lineCountInserted: inserted,\r\n      lineCountMoved: 0,\r\n      aMove: aMove,\r\n      aMoveIndex: aMoveIndex,\r\n      bMove: bMove,\r\n      bMoveIndex: bMoveIndex,\r\n    };\r\n  }\r\n\r\n  return {\r\n    lines: result,\r\n    lineCountDeleted: deleted,\r\n    lineCountInserted: inserted,\r\n    lineCountMoved: 0,\r\n  };\r\n}\r\n\r\nconst diffResult = patienceDiff(\r\n  props.prevCode ? props.prevCode.split(/\\r\\n|\\n/) : [],\r\n  props.currentCode.split(/\\r\\n|\\n/)\r\n);\r\n\r\nif (props.findUniqueResult)\r\n  props.findUniqueResult(\r\n    diffResult.lineCountDeleted,\r\n    diffResult.lineCountInserted,\r\n    props.currentCode.split(/\\r\\n|\\n/).length,\r\n    props.prevCode ? props.prevCode.split(/\\r\\n|\\n/).length : 0,\r\n    diffResult.lines.length\r\n  );\r\n\r\nconst lineProps = (lineNumber) => {\r\n  const line = diffResult.lines[lineNumber - 1];\r\n\r\n  let style = {\r\n    display: \"block\",\r\n    width: \"auto\",\r\n  };\r\n\r\n  if (line.aIndex === -1 || line.bIndex === -1) {\r\n    style = {\r\n      ...style,\r\n      marginRight: \"-1em\",\r\n      marginLeft: \"-1em\",\r\n      paddingLeft: \"1em\",\r\n    };\r\n  }\r\n\r\n  if (line.aIndex === -1) {\r\n    style = { ...style, background: \"rgb(0 95 67)\", ...props.addStyle };\r\n  }\r\n  if (line.bIndex === -1) {\r\n    style = { ...style, background: \"rgb(156 73 41)\", ...props.deleteStyle };\r\n  }\r\n\r\n  return { style };\r\n};\r\n\r\nconst codeText = diffResult.lines.map((el) => el.line).join(\"\\n\");\r\n\r\nreturn (\r\n  <div>\r\n    <Markdown\r\n      text={`\r\n\\`\\`\\`jsx\r\n${codeText}\r\n`}\r\n      syntaxHighlighterProps={{\r\n        wrapLines: true,\r\n        lineProps,\r\n        showLineNumbers: true,\r\n        lineNumberStyle: { display: !props.showLineNumber && \"none\" },\r\n      }}\r\n    />\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bozon.near/widget/CodeDiff"}