{"tx_hash": "28q9yrzN5dWTwtw2imXmz8H9UDjULHGbgrqfidNzdgWg", "action_id_social": "797ajvYzindLhxWcvZ7ruqgjGSneuXQF7ydr8bg6XSy3-0-widget", "block_id": 87807977, "block_timestamp": "2023-03-21 16:45:07.829", "signer_id": "roshaan.near", "widget_name": "IndexFeed", "source_code": "const index = {\n  action: \"post\",\n  key: \"main\",\n  options: {\n    limit: 10,\n    order: \"desc\",\n    accountId: props.accounts,\n  },\n};\nif (!index) {\n  return \"props.index is not defined\";\n}\n\nconst filter = props.filter;\n\nconst postsQuery = `\n  query IndexerQuery($offset: Int)  {\n    indexer_storage(\n      offset: $offset,\n      where: {function_name: {_eq: \"roshaan.near/near-social-posts\"}}\n      order_by: {key_name: desc}\n      limit: ${index.options.limit}\n    ) {\n      key_name\n      value\n    }\n  }\n`;\n\nfunction fetchGraphQL(operationsDoc, operationName, variables) {\n  return asyncFetch(\n    \"https://query-api-hasura-vcqilefdcq-uc.a.run.app/v1/graphql\",\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        query: operationsDoc,\n        variables: variables,\n        operationName: operationName,\n      }),\n    }\n  );\n}\n\nfetchGraphQL(postsQuery, \"IndexerQuery\").then((result) => {\n  if (result.status === 200) {\n    if (result.body.data) {\n      const initial_items = [];\n      result.body.data.indexer_storage.forEach((posts) => {\n        if (posts.value !== `\\\"[]\\\"`) {\n          const parsedOuterString = JSON.parse(posts.value);\n          const parsedInnerString = JSON.parse(parsedOuterString);\n          const post_parsed = JSON.parse(parsedInnerString[0].post);\n          parsedInnerString[0].post = post_parsed;\n          parsedInnerString[0].blockHeight = parsedInnerString[0].block_height;\n          delete parsedInnerString[0].block_height;\n          parsedInnerString[0].accountId = parsedInnerString[0].account_id;\n          delete parsedInnerString[0].account_id;\n          if (parsedInnerString[0].post !== null) {\n            initial_items.push(parsedInnerString[0]);\n          }\n        }\n      });\n      State.update({ initialItems: initial_items });\n    }\n  }\n});\n\nconst Post = styled.div`\n  border-bottom: 1px solid #ECEEF0;\n  padding: 24px 0 12px;\n\n  @media (max-width: 1200px) {\n    padding: 12px 0 0;\n  }\n`;\n\nconst renderItem =\n  props.renderItem ??\n  ((item, i) => {\n    console.log(item, \"ITEM\");\n    return (\n      <Post className=\"post\" key={JSON.stringify(a)}>\n        <Widget\n          src=\"roshaan.near/widget/Posts.Post\"\n          props={{\n            accountId: item.accountId,\n            blockHeight: item.blockHeight,\n            content: item.post,\n          }}\n        />\n      </Post>\n    );\n  });\n\n// <div key={JSON.stringify(item)}>\n//   #{item.block_height}: {JSON.stringify(item)}\n// </div>\nconst cachedRenderItem = (item, i) => {\n  const key = JSON.stringify(item);\n\n  if (!(key in state.cachedItems)) {\n    state.cachedItems[key] = renderItem(item, i);\n    State.update();\n  }\n  return state.cachedItems[key];\n};\n\nindex.options = index.options || {};\nconst initialRenderLimit =\n  props.initialRenderLimit ?? index.options.limit ?? 10;\nconst addDisplayCount = props.nextLimit ?? initialRenderLimit;\n\nindex.options.limit = Math.min(\n  Math.max(initialRenderLimit + addDisplayCount * 2, index.options.limit),\n  100\n);\nconst reverse = !!props.reverse;\n\n// const initialItems = Social.index(index.action, index.key, index.options);\nif (state.initialItems === null) {\n  return \"\";\n}\n\nconst computeFetchFrom = (items, limit) => {\n  if (!items || items.length < limit) {\n    return false;\n  }\n  const blockHeight = items[items.length - 1].blockHeight;\n  return index.options.order === \"desc\" ? blockHeight - 1 : blockHeight + 1;\n};\n\nconst mergeItems = (newItems) => {\n  const items = [\n    ...new Set([...newItems, ...state.items].map((i) => JSON.stringify(i))),\n  ].map((i) => JSON.parse(i));\n  items.sort((a, b) => a.blockHeight - b.blockHeight);\n  if (index.options.order === \"desc\") {\n    items.reverse();\n  }\n  return items;\n};\n\nconst jInitialItems = JSON.stringify(state.initialItems);\nif (state.jInitialItems !== jInitialItems) {\n  const jIndex = JSON.stringify(index);\n  if (jIndex !== state.jIndex) {\n    State.update({\n      jIndex,\n      jInitialItems,\n      items: state.initialItems,\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(state.initialItems, index.options.limit),\n      displayCount: initialRenderLimit,\n      cachedItems: {},\n    });\n  } else {\n    State.update({\n      jInitialItems,\n      items: mergeItems(state.initialItems),\n    });\n  }\n}\n\nif (state.fetchFrom) {\n  const limit = addDisplayCount;\n  console.log(state.fetchFrom, \"fetch from\");\n  fetchGraphQL(postsQuery, \"IndexerQuery\", {\n    offset: state.fetchFrom,\n  }).then((result) => {\n    if (result.status === 200) {\n      if (result.body.data) {\n        const posts = [];\n        result.body.data.indexer_storage.forEach((posts) => {\n          if (posts.value !== `\\\"[]\\\"`) {\n            const parsedOuterString = JSON.parse(posts.value);\n            const parsedInnerString = JSON.parse(parsedOuterString);\n            const post_parsed = JSON.parse(parsedInnerString[0].post);\n            parsedInnerString[0].post = post_parsed;\n            parsedInnerString[0].blockHeight =\n              parsedInnerString[0].block_height;\n            delete parsedInnerString[0].block_height;\n            parsedInnerString[0].accountId = parsedInnerString[0].account_id;\n            delete parsedInnerString[0].account_id;\n\n            if (parsedInnerString[0].post !== null) {\n              posts.push(parsedInnerString[0]);\n            }\n          }\n        });\n        if (posts.length > 0) {\n          const newFoundItems = !!posts.length;\n          State.update({\n            items: mergeItems(posts),\n            fetchFrom: false,\n            nextFetchFrom: computeFetchFrom(posts, limit, newFoundItems),\n          });\n        }\n      }\n    }\n  });\n}\n\nconst filteredItems = state.items;\nif (filter) {\n  if (filter.ignore) {\n    filteredItems = filteredItems.filter(\n      (item) => !(item.accountId in filter.ignore)\n    );\n  }\n}\n\nconst maybeFetchMore = () => {\n  if (\n    filteredItems.length - state.displayCount < addDisplayCount * 2 &&\n    !state.fetchFrom &&\n    state.nextFetchFrom &&\n    state.nextFetchFrom !== state.fetchFrom\n  ) {\n    State.update({\n      fetchFrom: state.nextFetchFrom,\n    });\n  }\n};\n\nmaybeFetchMore();\n\nconst makeMoreItems = () => {\n  State.update({\n    displayCount: state.displayCount + addDisplayCount,\n  });\n  maybeFetchMore();\n};\n\nconst loader = (\n  <div className=\"loader\" key={\"loader\"}>\n    <span\n      className=\"spinner-grow spinner-grow-sm me-1\"\n      role=\"status\"\n      aria-hidden=\"true\"\n    />\n    Loading ...\n  </div>\n);\n\nconst fetchMore =\n  props.manual &&\n  !props.hideFetchMore &&\n  (state.fetchFrom && filteredItems.length < state.displayCount\n    ? loader\n    : state.displayCount < filteredItems.length && (\n        <div key={\"loader more\"}>\n          <a href=\"javascript:void\" onClick={(e) => makeMoreItems()}>\n            {props.loadMoreText ?? \"Load more...\"}\n          </a>\n        </div>\n      ));\n\nconst items = filteredItems ? filteredItems.slice(0, state.displayCount) : [];\nif (reverse) {\n  items.reverse();\n}\n\nconst renderedItems = items.map(cachedRenderItem);\n\nreturn props.manual ? (\n  <>\n    {reverse && fetchMore}\n    {renderedItems}\n    {!reverse && fetchMore}\n  </>\n) : (\n  <InfiniteScroll\n    pageStart={0}\n    loadMore={makeMoreItems}\n    hasMore={state.displayCount < filteredItems.length}\n    loader={\n      <div className=\"loader\">\n        <span\n          className=\"spinner-grow spinner-grow-sm me-1\"\n          role=\"status\"\n          aria-hidden=\"true\"\n        />\n        Loading ...\n      </div>\n    }\n  >\n    {props.headerElement}\n    {renderedItems}\n    {props.footerElement}\n  </InfiniteScroll>\n);\n", "metadata": NaN, "branch": NaN, "widget_modules_used": null, "widget_url": "https://near.social/#/roshaan.near/widget/IndexFeed", "branch.draft.": NaN, "branch.draft.metadata": NaN, "metadata.description": NaN, "metadata.name": NaN, "metadata.tags.feed": NaN, "metadata.tags.index": NaN, "metadata.tags.template": NaN, "metadata.image.ipfs_cid": NaN}