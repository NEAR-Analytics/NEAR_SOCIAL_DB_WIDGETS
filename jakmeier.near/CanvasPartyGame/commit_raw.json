{"tx_hash": "7mAPaPfpSMQAuhLRs3rukvc6P5V9paAQcRWDaeNqd13A", "action_id_social": "GEoASQ3wTatkDC89pZhumgnjxH3Dvj5h1ydaeCniwpEK-0-widget", "block_id": 80724271, "block_timestamp": "2022-12-15 18:59:27.044", "signer_id": "jakmeier.near", "widget_name": "CanvasPartyGame", "source_code": "// hackathon project building a small interactive game\n\nconst MAP_TILES = 12;\nconst VIEW_OFFSET_X = 0;\nconst VIEW_OFFSET_Y = 0;\nconst MAP_SIZE = \"360px\";\nconst TILE_SIZE = \"30px\";\nconst TILE_INNER_SIZE = \"30px\";\nconst MAX_SECONDS = 600;\n\nconst Tile = {\n  Empty: \"\u25fb\",\n  Full: \"\u25fc\",\n  Ghost: \"\ud83d\udc7b\",\n};\n\nconst myTurn = props.session.activePlayer === context.accountId;\nconst msLeft = (props.session.start - Date.now()) / 1000 + MAX_SECONDS;\nconst secondsLeft = msLeft - (msLeft % 1);\nconst gameover = props.session.activePlayer === \"gameover\";\n\n// Select a view of the map, store it as 2D array of tiles and insert pixels.\nconst mapView = (start_x, start_y, width, height) => {\n  const map = Array.from(Array(width), () =>\n    new Array(height).fill(Tile.Empty)\n  );\n\n  console.log(\"props\", props);\n  props.session.pixels.forEach((pixel) => {\n    // apply view offset\n    const x = pixel.x - start_x;\n    const y = pixel.y - start_y;\n    if (map[x] && map[x][y]) {\n      map[x][y] = Tile.Full;\n    }\n  });\n\n  const updates = state.updates ?? [];\n  console.log(\"drawing with updates\", updates);\n  updates.forEach((pixel) => {\n    // apply view offset\n    const x = pixel.x - start_x;\n    const y = pixel.y - start_y;\n    if (map[x]) {\n      if (map[x][y] === Tile.Full) {\n        map[x][y] = Tile.Empty;\n      } else {\n        map[x][y] = Tile.Full;\n      }\n    }\n  });\n\n  return map;\n};\n\nconst stateObject = (updates) => {\n  return {\n    playerPos: state.playerPos ?? { x: 0, y: 0 },\n    updates,\n    currentView: mapView(\n      pos.x - VIEW_OFFSET_X,\n      pos.y - VIEW_OFFSET_Y,\n      MAP_TILES,\n      MAP_TILES\n    ),\n  };\n};\n\n// convert 2D array of tiles (stored in state.currentView) into HTML\nconst renderMap = (playerPos) => {\n  // make a deep copy of map so we can modify it\n  const map = JSON.parse(JSON.stringify(state.currentView));\n  if (myTurn) {\n    map[playerPos.x][playerPos.y] = Tile.Ghost;\n  }\n  const html = map\n    .map((row) =>\n      row.map((tile) => (\n        <div\n          style={{\n            fontSize: TILE_INNER_SIZE,\n            width: TILE_SIZE,\n            height: TILE_SIZE,\n          }}\n        >\n          {tile}\n        </div>\n      ))\n    )\n    .flat();\n  return html;\n};\n\n// instantly moves the player to the given coordinate unless the path is blocked\nconst movePlayer = (x, y) => {\n  // collision check and/or boundary check\n  if (\n    tileInCurrentView(x, y) === Tile.Empty ||\n    tileInCurrentView(x, y) === Tile.Full\n  ) {\n    setPlayerPos(x, y);\n  }\n};\n\n// update player position without checks\nconst setPlayerPos = (x, y) => {\n  state.playerPos.x = x;\n  state.playerPos.y = y;\n  state.currentView = mapView(\n    //x - VIEW_OFFSET_X,\n    //y - VIEW_OFFSET_Y,\n    -VIEW_OFFSET_X,\n    -VIEW_OFFSET_Y,\n    MAP_TILES,\n    MAP_TILES,\n    props.session.pixels\n  );\n  // trigger a re-render with the new state\n  State.update();\n};\n\nconst tileInCurrentView = (x, y) => {\n  // move view and keep  player in center\n  //const projected_x = x - state.playerPos.x + VIEW_OFFSET_X;\n  // const projected_y = y - state.playerPos.y + VIEW_OFFSET_Y;\n  // return state.currentView[projected_x][projected_y];\n  // move player biut keep view static\n  return state.currentView[x][y];\n};\n\nconst drawPixel = (x, y) => {\n  if (!myTurn) {\n    return;\n  }\n  if (\n    // deleting is not allowed for now\n    tileInCurrentView(x, y) === Tile.Empty &&\n    state.updates.length == 0\n  ) {\n    state.updates.push({ x, y });\n  } else if (\n    // undo is allowed\n    tileInCurrentView(x, y) === Tile.Full &&\n    state.updates.length == 1 &&\n    state.updates[0].x == x &&\n    state.updates[0].y == y\n  ) {\n    state.updates = [];\n  }\n};\n\nconst keyDownHandler = (e) => {\n  // apparently switch is not supported, using if-else instead\n  if (e.key == \"ArrowLeft\") {\n    movePlayer(state.playerPos.x - 1, state.playerPos.y);\n  } else if (e.key == \"ArrowRight\") {\n    movePlayer(state.playerPos.x + 1, state.playerPos.y);\n  } else if (e.key == \"ArrowUp\") {\n    movePlayer(state.playerPos.x, state.playerPos.y - 1);\n  } else if (e.key == \"ArrowDown\") {\n    movePlayer(state.playerPos.x, state.playerPos.y + 1);\n  } else if (e.key == \"Enter\") {\n    // reset to origin\n    setPlayerPos(0, 0);\n  } else if (e.key == \" \") {\n    drawPixel(state.playerPos.x, state.playerPos.y);\n  } else {\n    console.log(e);\n  }\n};\n\n// handler for gameboy input\nconst buttonDownHandler = (button) => {\n  // apparently switch is not supported, using if-else instead\n  if (button == \"left\") {\n    movePlayer(state.playerPos.x - 1, state.playerPos.y);\n  } else if (button == \"right\") {\n    movePlayer(state.playerPos.x + 1, state.playerPos.y);\n  } else if (button == \"up\") {\n    movePlayer(state.playerPos.x, state.playerPos.y - 1);\n  } else if (button == \"down\") {\n    movePlayer(state.playerPos.x, state.playerPos.y + 1);\n  } else if (button == \"b\") {\n    setPlayerPos(0, 0);\n  } else if (button == \"a\") {\n    drawPixel(state.playerPos.x, state.playerPos.y);\n  } else {\n    console.log(e);\n  }\n};\n\nconst onlineState = props.session;\n\nif (onlineState === null || onlineState === undefined) {\n  return \"Loading\";\n}\n\nif (state && onlineState.activePlayer !== context.accountId) {\n  if (state.updates.length > 0) {\n    state.updates = [];\n    State.update();\n  }\n}\nconst updates = state.updates ?? [];\nconst newState = stateObject(updates);\nState.init(newState);\nif (JSON.stringify(state) != JSON.stringify(newState)) {\n  State.update(newState);\n}\n\nconst commitMessage = {\n  canvasParty: {\n    session: {\n      pixels: onlineState.pixels.concat(state.updates),\n      otherPlayer: onlineState.otherPlayer,\n      activePlayer: secondsLeft > 0 ? onlineState.otherPlayer : \"gameover\",\n      start: onlineState.start,\n      word: onlineState.word,\n    },\n  },\n};\n\nconst timeLeftHtml = gameover ? (\n  \"\"\n) : (\n  <p style={{ fontWeight: \"bold\" }}>{secondsLeft}s left until art is frozen</p>\n);\n\nreturn (\n  <div>\n    <h1>Draw: {props.session.word}</h1>\n    <h2>{myTurn ? \"Your Turn\" : gameover ? \"Art Complete\" : \"Their Turn\"}</h2>\n    {timeLeftHtml}\n    {gameover || (\n      <Widget\n        src=\"jakmeier.near/widget/KeyInput\"\n        props={{ keyDownHandler, width: MAP_SIZE, margin: \"20px 0\" }}\n      />\n    )}\n    <div\n      style={{\n        display: \"grid\",\n        gridAutoFlow: \"column\",\n        gridTemplateRows: `repeat(${MAP_TILES},${TILE_SIZE})`,\n        width: MAP_SIZE,\n        height: MAP_SIZE,\n      }}\n    >\n      {renderMap(state.playerPos)}\n    </div>\n    {gameover || (\n      <Widget\n        src=\"jakmeier.near/widget/GameBoyInput\"\n        props={{\n          buttonDownHandler,\n          width: MAP_SIZE,\n          margin: \"20px 0\",\n          dPadWidth: \"100px\",\n          roundButtonSize: \"50px\",\n          squareButtonSize: \"60px\",\n        }}\n      />\n    )}\n\n    {gameover || (\n      <div style={{ margin: \"20px 0\" }}>\n        <CommitButton style={{ width: MAP_SIZE }} data={commitMessage}>\n          Submit\n        </CommitButton>\n      </div>\n    )}\n\n    {gameover && (\n      <div style={{ margin: \"20px 0\" }}>\n        Save the image, it will be gone after you exit!\n      </div>\n    )}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/jakmeier.near/widget/CanvasPartyGame"}