{"tx_hash": "44ed94LgSQTAncGX1KMaQrd2Bb8nvwbRc4RRUs8J1RTZ", "action_id_social": "7yGChChmH2xbxH5xLxE24bFiJCdN92YfDyXDE98Ktuiv-0-widget", "block_id": 87965638, "block_timestamp": "2023-03-23 20:34:07.121", "signer_id": "0xprometheus.near", "widget_name": "GainsNetwork", "source_code": "const gainsStakingContract = \"0x6B8D3C08072a020aC065c467ce922e3A36D3F9d6\";\nconst gainsTokenContract = \"0x18c11FD286C5EC11c3b683Caa813B77f5163A122\";\nconst tokenDecimals = 18;\n\nconst stakingAbi = fetch(\n  \"https://gist.githubusercontent.com/Prometheo/9c658aa282c90dd1b3ae873d541ea2a4/raw/e3c3abc49a2b373e737930b1f3281c049d7fe1e8/stakingAbi.json\"\n);\n\nconst tokenAbi = fetch(\n  \"https://gist.githubusercontent.com/Prometheo/44ed199abaa7eced6c189e3e6aa8b310/raw/01d057967bcff8f00cc14dc7b2f9a9fd56bc65c7/abi.json\"\n);\nif (!tokenAbi.ok) {\n  return \"Loading\";\n}\nlet apr = 0;\nconst arbitrumApr = fetch(\"https://backend-arbitrum.gains.trade/apr\");\n\nif (arbitrumApr.ok) {\n  apr = arbitrumApr.body.sssBaseApr.toFixed(2);\n}\n\nconst iface = new ethers.utils.Interface(stakingAbi.body);\nconst tokenIFace = new ethers.utils.Interface(tokenAbi.body);\n\n// HELPER FUNCTION\n\nconst goOut = () => {\n  setTimeout(() => {\n    State.update({ message: undefined });\n    State.update({ type: undefined });\n  }, 5000);\n};\n\nconst getStakedBalance = (receiver) => {\n  const encodedData = iface.encodeFunctionData(\"users\", [receiver]);\n\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"users\",\n        rawBalance\n      );\n\n      State.update({ rawStaked: receiverBalanceHex.stakedTokens.toString() });\n      State.update({\n        rawBoost: receiverBalanceHex.totalBoostTokens.toString(),\n      });\n      State.update({ rawDebtDai: receiverBalanceHex.debtDai.toString() });\n      console.log(receiverBalanceHex);\n      return Big(receiverBalanceHex.stakedTokens.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\nconst getRewardBalance = () => {\n  const encodedData = iface.encodeFunctionData(\"accDaiPerToken\");\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: encodedData,\n    })\n    .then((accDaiPerToken) => {\n      const DaiPerToken = iface.decodeFunctionResult(\n        \"accDaiPerToken\",\n        accDaiPerToken\n      );\n\n      // calculate pending reward\n      const DaiReward =\n        ((parseFloat(state.rawStaked) + parseFloat(state.rawBoost)) *\n          parseFloat(DaiPerToken.toString())) /\n          1e18 -\n        state.rawDebtDai;\n\n      console.log(\"last shi\", DaiReward);\n\n      return Big(DaiReward.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(10)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\nconst getTokenBalance = (receiver) => {\n  const encodedData = tokenIFace.encodeFunctionData(\"balanceOf\", [receiver]);\n\n  return Ethers.provider()\n    .call({\n      to: gainsTokenContract,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      console.log(receiverBalanceHex.toString());\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\nconst getTokenAllowance = (receiver) => {\n  const encodedData = tokenIFace.encodeFunctionData(\"allowance\", [\n    receiver,\n    gainsStakingContract,\n  ]);\n\n  return Ethers.provider()\n    .call({\n      to: gainsTokenContract,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\n        \"allowance\",\n        rawBalance\n      )[0];\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2);\n    });\n};\n\nconst stakeTokens = (tokenAmount) => {\n  if (!tokenAmount || tokenAmount > state.balance) {\n    return console.log(\"Amount is missing\");\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi.body,\n    Ethers.provider().getSigner()\n  );\n  let normalAmount = state.tokenAmount;\n\n  let amount = ethers.utils.parseEther(normalAmount);\n\n  erc20\n    .stakeTokens(amount)\n    .then((transactionHash) => transactionHash.wait())\n    .then((ricit) => {\n      getTokenBalance(state.sender).then((balance) => {\n        State.update({ balance });\n      });\n      getStakedBalance(state.sender).then((stakedBalance) => {\n        State.update({ stakedBalance });\n      });\n      getRewardBalance().then((rewards) => {\n        State.update({ rewards });\n      });\n      State.update({ tokenAmount: 0 });\n      State.update({ message: \"Success\" });\n      State.update({\n        reason: `You staked ${normalAmount} GNC, let the rewards start rolling in. \ud83e\udd11`,\n      });\n      State.update({ link: `https://arbiscan.io/tx/${ricit.transactionHash}` });\n      State.update({ type: \"success\" });\n      goOut();\n    })\n    .catch((err) => {\n      console.log(\"GRAN DINALE\", err);\n      State.update({ message: \"Error!\" });\n      State.update({ reason: `${err.reason || err.message.substr(100)} \ud83d\ude1e` });\n      State.update({ type: \"error\" });\n      goOut();\n    });\n};\n\nconst unStakeTokens = () => {\n  if (parseFloat(state.stakedBalance) == 0) {\n    return console.log(\"Amount is missing\");\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi.body,\n    Ethers.provider().getSigner()\n  );\n\n  const amount = ethers.utils.parseEther(state.stakedBalance);\n\n  erc20\n    .unstakeTokens(amount)\n    .then((transactionHash) => transactionHash.wait())\n    .then((ricit) => {\n      console.log(\"receipt\", ricit);\n      getTokenBalance(state.sender).then((balance) => {\n        State.update({ balance });\n      });\n      getStakedBalance(state.sender).then((stakedBalance) => {\n        State.update({ stakedBalance });\n      });\n      getRewardBalance().then((rewards) => {\n        State.update({ rewards });\n      });\n      State.update({ message: \"Success\" });\n      State.update({\n        reason: `You unstaked your GNC. Why would anyone do that? \ud83e\udd14 come back soon!`,\n      });\n      State.update({ link: `https://arbiscan.io/tx/${ricit.transactionHash}` });\n      State.update({ type: \"success\" });\n      goOut();\n    })\n    .catch((err) => {\n      State.update({ message: \"Error!\" });\n      State.update({ reason: `${err.reason} \ud83d\ude1e` });\n      State.update({ type: \"error\" });\n      goOut();\n    });\n};\n\nconst withdrawReward = () => {\n  if (!(state.rewards > 0) && state.sender) {\n    console.log(\"criterias not met\");\n    return;\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi.body,\n    Ethers.provider().getSigner()\n  );\n\n  erc20\n    .harvest()\n    .then((transactionHash) => transactionHash.wait())\n    .then((ricit) => {\n      console.log(\"receipt\", ricit);\n      State.update({ rewards: 0 });\n      State.update({ message: \"Success\" });\n      State.update({\n        reason: `Rewards withdrawn, Enjoy!`,\n      });\n      State.update({ link: `https://arbiscan.io/tx/${ricit.transactionHash}` });\n      State.update({ type: \"success\" });\n      goOut();\n    })\n    .catch((err) => {\n      State.update({ message: \"Error!\" });\n      State.update({ reason: `${err.reason} \ud83d\ude1e` });\n      State.update({ type: \"error\" });\n      goOut();\n    });\n};\n\nconst updator = (tokenAmount) => {\n  console.log(\"updator\", tokenAmount);\n  State.update({ tokenAmount: tokenAmount });\n};\n\nconst approveToken = () => {\n  const erc20 = new ethers.Contract(\n    gainsTokenContract,\n    tokenAbi.body,\n    Ethers.provider().getSigner()\n  );\n\n  const maxAllowance =\n    \"115792089237316195423570985008687907853269984665640564039457584007913129639935\";\n\n  erc20\n    .approve(gainsStakingContract, maxAllowance)\n    .then((transactionHash) => transactionHash.wait())\n    .then((ricit) => {\n      console.log(\"receipt\", ricit);\n      State.update({\n        allowance: Big(maxAllowance).div(Big(10).pow(tokenDecimals)).toFixed(2),\n      });\n      State.update({ message: \"approval successful\" });\n      State.update({\n        reason: `Approval complete, Go on now, stake your token!`,\n      });\n      State.update({ link: `https://arbiscan.io/tx/${ricit.transactionHash}` });\n      State.update({ type: \"success\" });\n      goOut();\n    })\n    .catch((err) => {\n      State.update({ message: \"Error!\" });\n      State.update({ reason: `${err.reason} \ud83d\ude1e` });\n      State.update({ type: \"error\" });\n      goOut();\n    });\n};\n\nconst getTotalRewardDistributed = () => {\n  const encodedData = iface.encodeFunctionData(\"totalRewardsDistributedDai\");\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"totalRewardsDistributedDai\",\n        rawBalance\n      );\n      console.log(\"dhee\", receiverBalanceHex.toString());\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\nif (state.sender === undefined) {\n  console.log(\"of course it's undefined\", ethers);\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  console.log(\"account\", accounts);\n  if (accounts.length) {\n    State.update({ sender: accounts[0] });\n    console.log(\"set sender\", accounts[0]);\n  }\n  console.log(\"elsefs\", Ethers.provider());\n}\nif (!state.totalRewards && state.sender) {\n  getTotalRewardDistributed().then((totalRewards) => {\n    State.update({ totalRewards });\n  });\n}\n\nif (state.balance === undefined && state.sender) {\n  getTokenBalance(state.sender).then((balance) => {\n    State.update({ balance });\n  });\n}\n\nif (state.stakedBalance === undefined && state.sender) {\n  console.log(\"i think state uodates all\");\n  getStakedBalance(state.sender).then((stakedBalance) => {\n    State.update({ stakedBalance });\n  });\n}\n\nif (state.sender && state.allowance == undefined) {\n  getTokenAllowance(state.sender).then((allowance) => {\n    console.log(\"Allowance rawed\", allowance);\n    State.update({ allowance });\n  });\n}\n\nif (state.sender && state.rewards == undefined) {\n  console.log(\"does it try?\");\n  getRewardBalance().then((rewards) => {\n    State.update({ rewards });\n  });\n}\n\nconst cssFont = fetch(\n  \"https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800\"\n).body;\nconst css = fetch(\n  \"https://pluminite.mypinata.cloud/ipfs/Qmboz8aoSvVXLeP5pZbRtNKtDD3kX5D9DEnfMn2ZGSJWtP\"\n).body;\n\nif (!cssFont || !css) return \"\";\n\nreturn (\n  <Widget\n    src=\"0xprometheus.near/widget/StakeW\"\n    props={{\n      state,\n      unStakeTokens,\n      stakeTokens,\n      withdrawReward,\n      apr,\n      approveToken,\n      updator,\n    }}\n  />\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/0xprometheus.near/widget/GainsNetwork", "metadata.name": NaN, "metadata.tags.minorityprogrammers": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.tags.app": NaN, "metadata.tags.arbitrum": NaN, "metadata.tags.eth": NaN}