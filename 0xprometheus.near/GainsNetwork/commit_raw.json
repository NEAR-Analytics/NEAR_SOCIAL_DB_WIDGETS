{"tx_hash": "6kaAJ1dGSpyZHbPUmEDYZXoKdKWbhKCUSk5gyup9oT3q", "action_id_social": "Ch1K2JjRmtMpH8vnXnfqyTFxhzHJRMQrNWTeNyen7Gxh-0-widget", "block_id": 87809485, "block_timestamp": "2023-03-21 17:17:46.713", "signer_id": "0xprometheus.near", "widget_name": "GainsNetwork", "source_code": "// FETCH ABI\r\n\r\nconst gainsStakingContract = \"0x6B8D3C08072a020aC065c467ce922e3A36D3F9d6\";\r\nconst gainsTokenContract = \"0x18c11FD286C5EC11c3b683Caa813B77f5163A122\";\r\nconst tokenDecimals = 18;\r\n\r\nconst stakingAbi = fetch(\r\n  \"https://gist.githubusercontent.com/Prometheo/9c658aa282c90dd1b3ae873d541ea2a4/raw/e3c3abc49a2b373e737930b1f3281c049d7fe1e8/stakingAbi.json\"\r\n);\r\n\r\nconst tokenAbi = fetch(\r\n  \"https://gist.githubusercontent.com/Prometheo/44ed199abaa7eced6c189e3e6aa8b310/raw/01d057967bcff8f00cc14dc7b2f9a9fd56bc65c7/abi.json\"\r\n);\r\nif (!tokenAbi.ok) {\r\n  return \"Loading\";\r\n}\r\nlet apr = 0;\r\nconst arbitrumApr = fetch(\"https://backend-arbitrum.gains.trade/apr\");\r\n\r\n// if (tokenAbi.ok) {\r\n//   return \"Loading\";\r\n// }\r\n\r\nif (arbitrumApr.ok) {\r\n  apr = arbitrumApr.body.sssBaseApr.toFixed(2);\r\n}\r\n\r\nconst iface = new ethers.utils.Interface(stakingAbi.body);\r\nconst tokenIFace = new ethers.utils.Interface(tokenAbi.body);\r\n\r\n// HELPER FUNCTION\r\n\r\nconst goOut = () => {\r\n  setTimeout(() => {\r\n    State.update({ message: undefined });\r\n    State.update({ type: undefined });\r\n  }, 3000);\r\n};\r\n\r\nconst getStakedBalance = (receiver) => {\r\n  const encodedData = iface.encodeFunctionData(\"users\", [receiver]);\r\n\r\n  return Ethers.provider()\r\n    .call({\r\n      to: gainsStakingContract,\r\n      data: encodedData,\r\n    })\r\n    .then((rawBalance) => {\r\n      const receiverBalanceHex = iface.decodeFunctionResult(\r\n        \"users\",\r\n        rawBalance\r\n      );\r\n\r\n      State.update({ rawStaked: receiverBalanceHex.stakedTokens.toString() });\r\n      State.update({\r\n        rawBoost: receiverBalanceHex.totalBoostTokens.toString(),\r\n      });\r\n      State.update({ rawDebtDai: receiverBalanceHex.debtDai.toString() });\r\n      console.log(receiverBalanceHex);\r\n      return Big(receiverBalanceHex.stakedTokens.toString())\r\n        .div(Big(10).pow(tokenDecimals))\r\n        .toFixed(2)\r\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\r\n    });\r\n};\r\n\r\nconst getRewardBalance = () => {\r\n  const encodedData = iface.encodeFunctionData(\"accDaiPerToken\");\r\n  return Ethers.provider()\r\n    .call({\r\n      to: gainsStakingContract,\r\n      data: encodedData,\r\n    })\r\n    .then((accDaiPerToken) => {\r\n      const DaiPerToken = iface.decodeFunctionResult(\r\n        \"accDaiPerToken\",\r\n        accDaiPerToken\r\n      );\r\n\r\n      // calculate pending reward\r\n      const DaiReward =\r\n        ((parseFloat(state.rawStaked) + parseFloat(state.rawBoost)) *\r\n          parseFloat(DaiPerToken.toString())) /\r\n          1e18 -\r\n        state.rawDebtDai;\r\n\r\n      console.log(\"last shi\", DaiReward);\r\n\r\n      return Big(DaiReward.toString())\r\n        .div(Big(10).pow(tokenDecimals))\r\n        .toFixed(10)\r\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\r\n    });\r\n};\r\n\r\nconst getTokenBalance = (receiver) => {\r\n  const encodedData = tokenIFace.encodeFunctionData(\"balanceOf\", [receiver]);\r\n\r\n  return Ethers.provider()\r\n    .call({\r\n      to: gainsTokenContract,\r\n      data: encodedData,\r\n    })\r\n    .then((rawBalance) => {\r\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\r\n        \"balanceOf\",\r\n        rawBalance\r\n      );\r\n\r\n      console.log(receiverBalanceHex.toString());\r\n\r\n      return Big(receiverBalanceHex.toString())\r\n        .div(Big(10).pow(tokenDecimals))\r\n        .toFixed(2)\r\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\r\n    });\r\n};\r\n\r\nconst getTokenAllowance = (receiver) => {\r\n  const encodedData = tokenIFace.encodeFunctionData(\"allowance\", [\r\n    receiver,\r\n    gainsStakingContract,\r\n  ]);\r\n\r\n  return Ethers.provider()\r\n    .call({\r\n      to: gainsTokenContract,\r\n      data: encodedData,\r\n    })\r\n    .then((rawBalance) => {\r\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\r\n        \"allowance\",\r\n        rawBalance\r\n      )[0];\r\n\r\n      return Big(receiverBalanceHex.toString())\r\n        .div(Big(10).pow(tokenDecimals))\r\n        .toFixed(2);\r\n    });\r\n};\r\n\r\nconst stakeTokens = (tokenAmount) => {\r\n  if (!tokenAmount || tokenAmount > state.balance) {\r\n    return console.log(\"Amount is missing\");\r\n  }\r\n  const erc20 = new ethers.Contract(\r\n    gainsStakingContract,\r\n    stakingAbi.body,\r\n    Ethers.provider().getSigner()\r\n  );\r\n\r\n  let amount = ethers.utils.parseEther(state.tokenAmount);\r\n\r\n  erc20\r\n    .stakeTokens(amount)\r\n    .then((transactionHash) => transactionHash.wait())\r\n    .then((ricit) => {\r\n      getTokenBalance(state.sender).then((balance) => {\r\n        State.update({ balance });\r\n      });\r\n      getStakedBalance(state.sender).then((stakedBalance) => {\r\n        State.update({ stakedBalance });\r\n      });\r\n      State.update({ tokenAmount: 0 });\r\n      State.update({ message: \"Success\" });\r\n      State.update({ type: \"success\" });\r\n      goOut();\r\n    })\r\n    .catch((err) => {\r\n      State.update({ message: err.reason });\r\n      State.update({ type: \"error\" });\r\n      goOut();\r\n    });\r\n};\r\n\r\nconst unStakeTokens = () => {\r\n  if (parseFloat(state.stakedBalance) == 0) {\r\n    return console.log(\"Amount is missing\");\r\n  }\r\n  const erc20 = new ethers.Contract(\r\n    gainsStakingContract,\r\n    stakingAbi.body,\r\n    Ethers.provider().getSigner()\r\n  );\r\n\r\n  const amount = ethers.utils.parseEther(state.stakedBalance);\r\n\r\n  erc20\r\n    .unstakeTokens(amount)\r\n    .then((transactionHash) => transactionHash.wait())\r\n    .then((ricit) => {\r\n      console.log(\"receipt\", ricit);\r\n      getTokenBalance(state.sender).then((balance) => {\r\n        State.update({ balance });\r\n      });\r\n      getStakedBalance(state.sender).then((stakedBalance) => {\r\n        State.update({ stakedBalance });\r\n      });\r\n      State.update({ message: \"Success\" });\r\n      State.update({ type: \"success\" });\r\n      goOut();\r\n    })\r\n    .catch((err) => {\r\n      State.update({ message: err.reason });\r\n      State.update({ type: \"error\" });\r\n      goOut();\r\n    });\r\n};\r\n\r\nconst withdrawReward = () => {\r\n  if (!(state.rewards > 0) && state.sender) {\r\n    console.log(\"criterias not met\");\r\n    return;\r\n  }\r\n  const erc20 = new ethers.Contract(\r\n    gainsStakingContract,\r\n    stakingAbi.body,\r\n    Ethers.provider().getSigner()\r\n  );\r\n\r\n  erc20\r\n    .harvest()\r\n    .then((transactionHash) => transactionHash.wait())\r\n    .then((ricit) => {\r\n      console.log(\"receipt\", ricit);\r\n      getStakedBalance(state.sender).then((stakedBalance) => {\r\n        State.update({ stakedBalance });\r\n      });\r\n      getRewardBalance().then((rewards) => {\r\n        State.update({ rewards });\r\n      });\r\n      State.update({ message: \"Success\" });\r\n      State.update({ type: \"success\" });\r\n      goOut();\r\n    })\r\n    .catch((err) => {\r\n      State.update({ message: err.reason });\r\n      State.update({ type: \"error\" });\r\n      goOut();\r\n    });\r\n};\r\n\r\nconst updator = (tokenAmount) => {\r\n  console.log(\"updator\", tokenAmount);\r\n  State.update({ tokenAmount: tokenAmount });\r\n};\r\n\r\nconst approveToken = () => {\r\n  const erc20 = new ethers.Contract(\r\n    gainsTokenContract,\r\n    tokenAbi.body,\r\n    Ethers.provider().getSigner()\r\n  );\r\n\r\n  const maxAllowance =\r\n    \"115792089237316195423570985008687907853269984665640564039457584007913129639935\";\r\n\r\n  erc20\r\n    .approve(gainsStakingContract, maxAllowance)\r\n    .then((transactionHash) => transactionHash.wait())\r\n    .then((ricit) => {\r\n      console.log(\"receipt\", ricit);\r\n      State.update({\r\n        allowance: Big(maxAllowance).div(Big(10).pow(tokenDecimals)).toFixed(2),\r\n      });\r\n      State.update({ message: \"approval successful\" });\r\n      State.update({ message: \"Success\" });\r\n      State.update({ type: \"success\" });\r\n      goOut();\r\n    })\r\n    .catch((err) => {\r\n      State.update({ message: err.reason });\r\n      State.update({ type: \"error\" });\r\n      goOut();\r\n    });\r\n};\r\n\r\nconst getTotalRewardDistributed = () => {\r\n  const encodedData = iface.encodeFunctionData(\"totalRewardsDistributedDai\");\r\n  return Ethers.provider()\r\n    .call({\r\n      to: gainsStakingContract,\r\n      data: encodedData,\r\n    })\r\n    .then((rawBalance) => {\r\n      const receiverBalanceHex = iface.decodeFunctionResult(\r\n        \"totalRewardsDistributedDai\",\r\n        rawBalance\r\n      );\r\n      console.log(\"dhee\", receiverBalanceHex.toString());\r\n\r\n      return Big(receiverBalanceHex.toString())\r\n        .div(Big(10).pow(tokenDecimals))\r\n        .toFixed(2)\r\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\r\n    });\r\n};\r\n\r\n// DETECT User\r\n\r\nif (state.sender === undefined) {\r\n  console.log(\"of course it's undefined\", ethers);\r\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\r\n  console.log(\"account\", accounts);\r\n  if (accounts.length) {\r\n    State.update({ sender: accounts[0] });\r\n    console.log(\"set sender\", accounts[0]);\r\n  }\r\n}\r\n\r\n//if (!state.sender)  return \"Please login first\";\r\n// FETCH Gains Network Total rewards distributed\r\n\r\nif (!state.totalRewards && state.sender) {\r\n  getTotalRewardDistributed().then((totalRewards) => {\r\n    State.update({ totalRewards });\r\n  });\r\n}\r\n\r\nif (state.balance === undefined && state.sender) {\r\n  // FETCH SENDER BALANCE\r\n  getTokenBalance(state.sender).then((balance) => {\r\n    State.update({ balance });\r\n  });\r\n}\r\n\r\n// FETCH SENDER STETH BALANCE\r\n\r\nif (state.stakedBalance === undefined && state.sender) {\r\n  console.log(\"i think state uodates all\");\r\n  getStakedBalance(state.sender).then((stakedBalance) => {\r\n    State.update({ stakedBalance });\r\n  });\r\n}\r\n\r\nif (state.sender && state.allowance == undefined) {\r\n  getTokenAllowance(state.sender).then((allowance) => {\r\n    console.log(\"Allowance rawed\", allowance);\r\n    State.update({ allowance });\r\n  });\r\n}\r\n\r\nif (state.sender && state.rewards == undefined) {\r\n  console.log(\"does it try?\");\r\n  getRewardBalance().then((rewards) => {\r\n    State.update({ rewards });\r\n  });\r\n}\r\n\r\n// FETCH CSS\r\n\r\nconst cssFont = fetch(\r\n  \"https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800\"\r\n).body;\r\nconst css = fetch(\r\n  \"https://pluminite.mypinata.cloud/ipfs/Qmboz8aoSvVXLeP5pZbRtNKtDD3kX5D9DEnfMn2ZGSJWtP\"\r\n).body;\r\n\r\nif (!cssFont || !css) return \"\";\r\n\r\n// CUSTOM CSS\r\n\r\n// OUTPUT UI\r\n\r\nconst getSender = () => {\r\n  return !state.sender\r\n    ? \"\"\r\n    : state.sender.substring(0, 6) +\r\n        \"...\" +\r\n        state.sender.substring(state.sender.length - 4, state.sender.length);\r\n};\r\n\r\nreturn (\r\n  <Widget\r\n    src=\"0xprometheus.near/widget/StakeW\"\r\n    props={{\r\n      state,\r\n      getSender,\r\n      unStakeTokens,\r\n      stakeTokens,\r\n      withdrawReward,\r\n      apr,\r\n      approveToken,\r\n      updator,\r\n    }}\r\n  />\r\n);\r\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/0xprometheus.near/widget/GainsNetwork", "metadata.name": NaN, "metadata.tags.minorityprogrammers": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.tags.app": NaN, "metadata.tags.arbitrum": NaN, "metadata.tags.eth": NaN}