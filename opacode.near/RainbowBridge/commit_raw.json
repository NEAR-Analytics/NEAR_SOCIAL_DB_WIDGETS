{"tx_hash": "BGT2DoGCPPbVwLU6XodWpgDSwd8W81wghX1mLfJYSuup", "action_id_social": "6Q6y1Zny3zSpjsVYRcjQ5LZauGzU9PTL2RAYthU3KZ1Z-0-widget", "block_id": 89418318, "block_timestamp": "2023-04-12 14:41:10.719", "signer_id": "opacode.near", "widget_name": "RainbowBridge", "source_code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (!sender) return <Web3Connect connectLabel=\"Connect Web3 Wallet\" />;\n\nconst networks = [\"ethereum\", \"aurora\"];\nconst testnetChainIds = {\n  ethereum: 5,\n  aurora: 1313161555,\n};\nconst testnetNetworkNames = {\n  ethereum: \"Goerli Testnet\",\n  aurora: \"Aurora Testnet\",\n};\nconst mainnetChainIds = {\n  ethereum: 1,\n  aurora: 1313161554,\n};\nconst mainnetNetworkNames = {\n  ethereum: \"Ethereum Mainnet\",\n  aurora: \"Aurora Mainnet\",\n};\nconst testnetConfig = {\n  etherCustodianAddress: \"0x84a82Bb39c83989D5Dc07e1310281923D2544dC2\",\n};\nconst mainnetConfig = {\n  etherCustodianAddress: \"0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52\",\n};\nconst tokens = {\n  ETH: {\n    symbol: \"ETH\",\n    name: \"Ethereum\",\n    ethereumAddress: undefined,\n    nearAddress: \"aurora\",\n    auroraAddress: undefined,\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n  FAU: {\n    symbol: \"FAU\",\n    name: \"FaucetToken\",\n    ethereumAddress: \"0xba62bcfcaafc6622853cca2be6ac7d845bc0f2dc\",\n    nearAddress:\n      \"ba62bcfcaafc6622853cca2be6ac7d845bc0f2dc.factory.goerli.testnet\",\n    auroraAddress: \"0xf93cd0e464f74c240d8ebb7ed55ce6b43452f913\",\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n};\n\n// Get balance on network switch.\nconst fetchBalance = (tokenSymbol) => {\n  const tokenAddress = tokens[tokenSymbol][`${state.sourceNetwork}Address`];\n  if (tokenAddress?.length) {\n    // erc-20\n    const erc20 = new ethers.Contract(\n      tokenAddress,\n      [\"function balanceOf(address) view returns (uint)\"],\n      Ethers.provider()\n    );\n    erc20.balanceOf(sender).then((balance) => {\n      State.update({\n        senderBalance: ethers.BigNumber.from(balance),\n        tokenSymbol,\n      });\n    });\n  } else if (tokenAddress === undefined) {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balance) => {\n        State.update({\n          senderBalance: ethers.BigNumber.from(balance),\n          tokenSymbol,\n        });\n      });\n  } else {\n    // Token address = null: not bridged on this network.\n    State.update({ senderBalance: ethers.BigNumber.from(0), tokenSymbol });\n  }\n};\n\ninitState({\n  tokenSymbol: null,\n  sourceTokenBalance: ethers.BigNumber.from(0),\n  senderBalance: ethers.BigNumber.from(0),\n  amount: \"\",\n  bigNumberAmount: ethers.BigNumber.from(0),\n  sourceNetwork: \"ethereum\",\n  destinationNetwork: \"aurora\",\n  initialized: false,\n});\n\nEthers.provider()\n  .getNetwork()\n  .then((network) => {\n    if (!state.initialized) {\n      // Choose testnet or mainnet config depending on connected network.\n      const walletChainId = network.chainId;\n      const isTestnet =\n        walletChainId === testnetChainIds.aurora ||\n        walletChainId === testnetChainIds.ethereum;\n      // Set the bridge direction on network switch:\n      // bos.gg doesn't keep the component state on wallet network switch !\n      const sourceNetwork =\n        testnetChainIds.ethereum === walletChainId ||\n        mainnetChainIds.ethereum === walletChainId\n          ? \"ethereum\"\n          : \"aurora\";\n      State.update({\n        walletChainId: network.chainId,\n        chainIds: isTestnet ? testnetChainIds : mainnetChainIds,\n        networkNames: isTestnet ? testnetNetworkNames : mainnetNetworkNames,\n        config: isTestnet ? testnetConfig : mainnetConfig,\n        isTestnet,\n        sourceNetwork,\n        destinationNetwork:\n          sourceNetwork === \"ethereum\" ? \"aurora\" : \"ethereum\",\n        initialized: true,\n      });\n    }\n  });\n\nconst wrongWalletNetwork =\n  state.walletChainId !== state.chainIds[state.sourceNetwork];\nif (wrongWalletNetwork) {\n  State.update({\n    tokenSymbol: null,\n    amount: \"\",\n    senderBalance: ethers.BigNumber.from(0),\n    bigNumberAmount: ethers.BigNumber.from(0),\n  });\n}\n\nconst bridgeTokens = () => {\n  console.log(\"WIP\");\n  return;\n\n  if (state.sourceNetwork !== \"ethereum\") {\n    console.log(\"Coming soon...\");\n    return;\n  }\n  const iface = new ethers.utils.Interface([\n    \"function depositToEvm(string,uint) payable\",\n  ]);\n  const data = iface.encodeFunctionData(\"depositToEvm\", [\n    sender.slice(2).toLowerCase(),\n    0,\n  ]);\n  console.log(data);\n  const ethTokenLocker = new ethers.Contract(\n    state.config.etherCustodianAddress,\n    [\"function depositToEvm(string,uint) payable\"],\n    Ethers.provider().getSigner()\n  );\n\n  // Cannot call a contract with data:\n  // Error: Not a function call expression\n  ethTokenLocker\n    .submit(state.config.etherCustodianAddress, {\n      value: state.bigNumberAmount.toHexString(),\n      data,\n    })\n    .then((txHash) => {\n      console.log(txHash);\n    });\n  ethTokenLocker.depositToEVM(sender.slice(2).toLowerCase(), 0, {\n    value: state.bigNumberAmount.toHexString(),\n  });\n  //.then((txHash) => console.log(txHash));\n};\n\nif (!state.initialized) return <></>;\nreturn (\n  <>\n    <h2>\n      {\" \"}\n      \ud83c\udf08 {state.isTestnet\n        ? \"Testnet Rainbow Bridge\"\n        : \"Rainbow Bridge (alpha)\"}{\" \"}\n      \ud83c\udf08{\" \"}\n    </h2>\n    <div class=\"mb-3\">\n      <label for=\"selectSourceNetwork\">Select Source Network</label>\n      <select\n        class=\"form-select\"\n        id=\"selectSourceNetwork\"\n        onChange={(e) => {\n          State.update({ sourceNetwork: e.target.value });\n          if (state.destinationNetwork === e.target.value) {\n            State.update({\n              destinationNetwork: networks.find(\n                (network) => network !== e.target.value\n              ),\n            });\n          }\n        }}\n      >\n        <option selected={state.sourceNetwork === \"aurora\"} value={\"aurora\"}>\n          {state.networkNames.aurora}\n        </option>\n        <option\n          selected={state.sourceNetwork === \"ethereum\"}\n          value={\"ethereum\"}\n        >\n          {state.networkNames.ethereum}\n        </option>\n      </select>\n      {state.walletChainId !== state.chainIds[state.sourceNetwork] && (\n        <p>\n          Connect your wallet network to{\" \"}\n          {state.networkNames[state.sourceNetwork]}\n        </p>\n      )}\n    </div>\n\n    <div class=\"mb-3\">\n      <label for=\"selectToken\">Select token</label>\n      <select\n        class=\"form-select\"\n        id=\"selectToken\"\n        disabled={wrongWalletNetwork}\n        onChange={(e) => {\n          if (e.target.value === \"...\") {\n            State.update({\n              tokenSymbol: null,\n              amount: \"\",\n              bigNumberAmount: ethers.BigNumber.from(0),\n            });\n            return;\n          }\n          State.update({\n            tokenSymbol: e.target.value,\n          });\n          fetchBalance(e.target.value);\n        }}\n      >\n        <option selected={state.tokenSymbol === null} value={null}>\n          ...\n        </option>\n        {Object.keys(tokens).map((symbol) => (\n          <option value={symbol}>{symbol}</option>\n        ))}\n      </select>\n    </div>\n    <div class=\"mb-3\">\n      <label for=\"amount\" class=\"form-label\">\n        Enter the amount\n      </label>\n      <input\n        value={state.amount}\n        class=\"form-control\"\n        id=\"amount\"\n        disabled={wrongWalletNetwork || !state.tokenSymbol}\n        placeholder=\"\"\n        onChange={(e) => {\n          const bigNumberAmount = ethers.utils.parseUnits(\n            e.target.value !== \"\" ? e.target.value : \"0\",\n            tokens[state.tokenSymbol].decimals\n          );\n          State.update({ amount: e.target.value, bigNumberAmount });\n        }}\n      />\n      {state.tokenSymbol && (\n        <div>\n          Balance:{\" \"}\n          {ethers.utils.formatUnits(\n            state.senderBalance,\n            tokens[state.tokenSymbol].decimals\n          )}{\" \"}\n          {state.tokenSymbol}\n        </div>\n      )}\n    </div>\n\n    <div class=\"mb-3\">\n      <label for=\"selectDestinationNetwork\">Select Destination Network</label>\n      <select\n        class=\"form-select\"\n        id=\"selectDestinationNetwork\"\n        onChange={(e) => {\n          State.update({ destinationNetwork: e.target.value });\n          if (state.sourceNetwork === e.target.value) {\n            State.update({\n              sourceNetwork: networks.find(\n                (network) => network !== e.target.value\n              ),\n            });\n          }\n        }}\n      >\n        <option\n          selected={state.destinationNetwork === \"aurora\"}\n          value={\"aurora\"}\n        >\n          {state.networkNames.aurora}\n        </option>\n        <option\n          selected={state.destinationNetwork === \"ethereum\"}\n          value={\"ethereum\"}\n        >\n          {state.networkNames.ethereum}\n        </option>\n      </select>\n    </div>\n\n    <div class=\"mb-3\">\n      <button\n        disabled={\n          !state.tokenSymbol ||\n          state.bigNumberAmount.isZero() ||\n          state.senderBalance.lt(state.bigNumberAmount)\n        }\n        onClick={bridgeTokens}\n      >\n        Bridge tokens\n      </button>\n    </div>\n    <p class=\"\">\n      NOTE: Please make sure that your wallet is compatible with the Destination\n      Network before sending tokens. Visit rainbowbridge.app.\n    </p>\n    <h3> Recent transfers </h3>\n  </>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/opacode.near/widget/RainbowBridge", "metadata.image.url": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.linktree.website": NaN, "metadata.name": NaN, "metadata.tags.aurora": NaN, "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.tags.bridge": NaN}