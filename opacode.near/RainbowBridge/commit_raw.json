{"tx_hash": "BEGUcKKa937SRQeaSU89oMGvUirxCnaPhTKY56Qnp3bA", "action_id_social": "DHZu9sPHux5ubsAW6ztAo78hU8QTdHmugHWBEaFLvKp-0-widget", "block_id": 89536410, "block_timestamp": "2023-04-14 03:48:17.274", "signer_id": "opacode.near", "widget_name": "RainbowBridge", "source_code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n// NOTE: Switching account in MetaMask doesn't update the sender.\nif (!sender) return <Web3Connect connectLabel=\"Connect Web3 Wallet\" />;\n\nconst networks = [\"ethereum\", \"aurora\"];\nconst testnetChainIds = {\n  ethereum: 5,\n  aurora: 1313161555,\n};\nconst testnetNetworkNames = {\n  ethereum: \"Goerli Testnet\",\n  aurora: \"Aurora Testnet\",\n};\nconst mainnetChainIds = {\n  ethereum: 1,\n  aurora: 1313161554,\n};\nconst mainnetNetworkNames = {\n  ethereum: \"Ethereum Mainnet\",\n  aurora: \"Aurora Mainnet\",\n};\nconst testnetConfig = {\n  etherCustodianAddress: \"0x84a82Bb39c83989D5Dc07e1310281923D2544dC2\",\n  erc20LockerAddress: \"0xc115851ca60aed2ccc6ee3d5343f590834e4a3ab\",\n};\nconst mainnetConfig = {\n  etherCustodianAddress: \"0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52\",\n  erc20LockerAddress: \"0x23ddd3e3692d1861ed57ede224608875809e127f\",\n};\nconst testnetTokens = {\n  ETH: {\n    symbol: \"ETH\",\n    name: \"Ether\",\n    ethereumAddress: undefined,\n    nearAddress: \"aurora\",\n    auroraAddress: undefined,\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n\n  FAU: {\n    symbol: \"FAU\",\n    name: \"FaucetToken\",\n    ethereumAddress: \"0xba62bcfcaafc6622853cca2be6ac7d845bc0f2dc\",\n    nearAddress:\n      \"ba62bcfcaafc6622853cca2be6ac7d845bc0f2dc.factory.goerli.testnet\",\n    auroraAddress: \"0xf93cd0e464f74c240d8ebb7ed55ce6b43452f913\",\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n};\nconst mainnetTokens = {\n  ETH: {\n    symbol: \"ETH\",\n    name: \"Ether\",\n    ethereumAddress: undefined,\n    nearAddress: \"aurora\",\n    auroraAddress: undefined,\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n  \"USDC.e\": {\n    symbol: \"USDC.e\",\n    name: \"USD Coin\",\n    ethereumAddress: \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n    nearAddress: \"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\n    auroraAddress: \"0xb12bfca5a55806aaf64e99521918a4bf0fc40802\",\n    decimals: 6,\n    origin: \"ethereum\",\n  },\n};\n\nconst fetchBalance = (tokenSymbol) => {\n  const tokenAddress =\n    state.tokens[tokenSymbol][`${state.sourceNetwork}Address`];\n  if (tokenAddress?.length) {\n    // erc-20\n    const erc20 = new ethers.Contract(\n      tokenAddress,\n      [\n        \"function balanceOf(address) view returns (uint)\",\n        \"function allowance(address owner, address spender) view returns (uint)\",\n      ],\n      Ethers.provider()\n    );\n    erc20.balanceOf(sender).then((balance) => {\n      State.update({\n        senderBalance: ethers.BigNumber.from(balance),\n        tokenSymbol,\n      });\n    });\n    erc20\n      .allowance(sender, state.config.erc20LockerAddress)\n      .then((allowance) => {\n        State.update({\n          senderAllowance: ethers.BigNumber.from(allowance),\n          tokenSymbol,\n        });\n      });\n  } else if (tokenAddress === undefined) {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balance) => {\n        State.update({\n          senderBalance: ethers.BigNumber.from(balance),\n          tokenSymbol,\n        });\n      });\n  } else {\n    // Token address = null: not bridged on this network.\n    State.update({\n      senderBalance: ethers.BigNumber.from(0),\n      senderAllowance: ethers.BigNumber.from(0),\n      tokenSymbol,\n    });\n  }\n};\n\nconst erc20Approve = () => {\n  const tokenAddress =\n    state.tokens[state.tokenSymbol][`${state.sourceNetwork}Address`];\n  const erc20 = new ethers.Contract(\n    tokenAddress,\n    [\"function approve(address,uint) public returns (bool)\"],\n    Ethers.provider().getSigner()\n  );\n  erc20\n    .approve(state.config.erc20LockerAddress, state.bigNumberAmount)\n    .then((tx) => {\n      console.log(tx);\n      State.update({ lastTxHash: tx.hash });\n      tx.wait().then((receipt) => {\n        console.log(receipt);\n        fetchBalance(state.tokenSymbol);\n        State.update({ lastTxHash: null });\n      });\n    });\n};\n\nconst bridgeTokens = () => {\n  if (state.sourceNetwork !== \"ethereum\") {\n    console.log(\"Coming soon...\");\n    return;\n  }\n  if (state.tokenSymbol === \"ETH\") {\n    const ethTokenLocker = new ethers.Contract(\n      state.config.etherCustodianAddress,\n      // NOTE: for some reason human readable abi gives\n      // Error: Not a function call expression\n      // when calling the payable contract, so use standard abi.\n      //[\"function depositToEvm(string,uint256) payable\"],\n      [\n        {\n          inputs: [\n            {\n              internalType: \"string\",\n              name: \"ethRecipientOnNear\",\n              type: \"string\",\n            },\n            { internalType: \"uint256\", name: \"fee\", type: \"uint256\" },\n          ],\n          name: \"depositToEVM\",\n          outputs: [],\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n    ethTokenLocker\n      .depositToEVM(sender.slice(2).toLowerCase(), 0, {\n        value: state.bigNumberAmount,\n      })\n      .then((tx) => {\n        console.log(tx);\n        State.update({ lastTxHash: tx.hash });\n        tx.wait().then((receipt) => {\n          console.log(receipt);\n          // TODO sync Recent transfers after 10s\n          State.update({ lastTxHash: null });\n        });\n      });\n  } else if (state.tokenSymbol === \"NEAR\") {\n    console.log(\"Coming soon...\");\n  } else {\n    const erc20TokenLocker = new ethers.Contract(\n      state.config.erc20LockerAddress,\n      [\"function lockToken(address,uint,string) public\"],\n      Ethers.provider().getSigner()\n    );\n    const tokenAddress =\n      state.tokens[state.tokenSymbol][`${state.sourceNetwork}Address`];\n    erc20TokenLocker\n      .lockToken(\n        tokenAddress,\n        state.bigNumberAmount,\n        `aurora:${sender.toLowerCase().slice(2)}`\n      )\n      .then((tx) => {\n        console.log(tx);\n        State.update({ lastTxHash: tx.hash });\n        tx.wait().then((receipt) => {\n          console.log(receipt);\n          fetchBalance(state.tokenSymbol);\n          State.update({ lastTxHash: null });\n        });\n      });\n  }\n};\n\ninitState({\n  tokenSymbol: null,\n  sourceTokenBalance: ethers.BigNumber.from(0),\n  senderBalance: ethers.BigNumber.from(0),\n  senderAllowance: ethers.BigNumber.from(0),\n  amount: \"\",\n  bigNumberAmount: ethers.BigNumber.from(0),\n  sourceNetwork: \"ethereum\",\n  destinationNetwork: \"aurora\",\n  initialized: false,\n  lastTxHash: null,\n});\n\nEthers.provider()\n  .getNetwork()\n  .then((network) => {\n    if (!state.initialized) {\n      // Choose testnet or mainnet config depending on connected network.\n      const walletChainId = network.chainId;\n      const isTestnet =\n        walletChainId === testnetChainIds.aurora ||\n        walletChainId === testnetChainIds.ethereum;\n      // Set the bridge direction on network switch:\n      // bos.gg doesn't keep the component state on wallet network switch !\n      const sourceNetwork =\n        testnetChainIds.ethereum === walletChainId ||\n        mainnetChainIds.ethereum === walletChainId\n          ? \"ethereum\"\n          : \"aurora\";\n      State.update({\n        walletChainId: network.chainId,\n        chainIds: isTestnet ? testnetChainIds : mainnetChainIds,\n        networkNames: isTestnet ? testnetNetworkNames : mainnetNetworkNames,\n        config: isTestnet ? testnetConfig : mainnetConfig,\n        tokens: isTestnet ? testnetTokens : mainnetTokens,\n        isTestnet,\n        sourceNetwork,\n        destinationNetwork:\n          sourceNetwork === \"ethereum\" ? \"aurora\" : \"ethereum\",\n        initialized: true,\n      });\n    }\n  });\n\nconst recentTransfers = useCache(\n  () =>\n    asyncFetch(\n      `https://jvea2jh4jzwg4vykyhy3mcdh7i0yfosk.lambda-url.eu-central-1.on.aws/${\n        state.isTestnet ? 5 : 1\n      }/${sender}`\n    ).then((res) => res?.body ?? []),\n  \"recentTransfers\",\n  { subscribe: true }\n);\n\nif (!state.theme) {\n  State.update({\n    theme: styled.div`\n      .Container{\n        box-sizing: border-box;\n        margin: 8px auto;\n        min-width: 320px;\n        width: 100%;\n        padding: 0px 32px;\n        max-width: 560px;\n        position: relative;\n      }\n      .Header{\n        text-align: center;\n        margin-top: 30px;\n        margin-bottom: 30px;\n      }\n      .networkIcon {\n        border: 3px solid rgb(149,149,149);\n        background-color: rgb(149,149,149);\n      }\n      tr {\n        border-bottom: 1px solid;\n        border-top: 1px solid;\n      }\n      table {\n        width: 100%;\n      }`,\n  });\n}\nconst Theme = state.theme;\nconst ethExplorerUrl = state.isTestnet\n  ? \"https://goerli.etherscan.io\"\n  : \"https://etherscan.io\";\nconst nearExplorerUrl = state.isTestnet\n  ? \"https://explorer.testnet.near.org\"\n  : \"https://explorer.near.org\";\n\nconst wrongWalletNetwork =\n  state.walletChainId !== state.chainIds[state.sourceNetwork];\nif (wrongWalletNetwork) {\n  // Reset selection\n  State.update({\n    tokenSymbol: null,\n    amount: \"\",\n    senderBalance: ethers.BigNumber.from(0),\n    senderAllowance: ethers.BigNumber.from(0),\n    bigNumberAmount: ethers.BigNumber.from(0),\n  });\n}\nif (!state.initialized) return <></>;\nreturn (\n  <Theme>\n    <div class=\"Container\">\n      <h2 class=\"Header\">\n        {\" \"}\n        \ud83c\udf08{\" \"}\n        {state.isTestnet\n          ? \"Testnet Rainbow Bridge\"\n          : \"Rainbow Bridge (alpha)\"}{\" \"}\n        \ud83c\udf08{\" \"}\n      </h2>\n      <div class=\"mb-3\">\n        <label for=\"selectSourceNetwork\">Select Source Network</label>\n        <select\n          class=\"form-select\"\n          id=\"selectSourceNetwork\"\n          onChange={(e) => {\n            State.update({ sourceNetwork: e.target.value });\n            if (state.destinationNetwork === e.target.value) {\n              State.update({\n                destinationNetwork: networks.find(\n                  (network) => network !== e.target.value\n                ),\n              });\n            }\n          }}\n        >\n          <option selected={state.sourceNetwork === \"aurora\"} value={\"aurora\"}>\n            {state.networkNames.aurora}\n          </option>\n          <option\n            selected={state.sourceNetwork === \"ethereum\"}\n            value={\"ethereum\"}\n          >\n            {state.networkNames.ethereum}\n          </option>\n        </select>\n        {state.walletChainId !== state.chainIds[state.sourceNetwork] && (\n          <p>\n            Connect your wallet network to{\" \"}\n            {state.networkNames[state.sourceNetwork]}\n          </p>\n        )}\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"selectDestinationNetwork\">Select Destination Network</label>\n        <select\n          class=\"form-select\"\n          id=\"selectDestinationNetwork\"\n          onChange={(e) => {\n            State.update({ destinationNetwork: e.target.value });\n            if (state.sourceNetwork === e.target.value) {\n              State.update({\n                sourceNetwork: networks.find(\n                  (network) => network !== e.target.value\n                ),\n              });\n            }\n          }}\n        >\n          <option\n            selected={state.destinationNetwork === \"aurora\"}\n            value={\"aurora\"}\n          >\n            {state.networkNames.aurora}\n          </option>\n          <option\n            selected={state.destinationNetwork === \"ethereum\"}\n            value={\"ethereum\"}\n          >\n            {state.networkNames.ethereum}\n          </option>\n        </select>\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"selectToken\">Select token</label>\n        <select\n          class=\"form-select\"\n          id=\"selectToken\"\n          disabled={wrongWalletNetwork}\n          onChange={(e) => {\n            if (e.target.value === \"...\") {\n              State.update({\n                tokenSymbol: null,\n                amount: \"\",\n                bigNumberAmount: ethers.BigNumber.from(0),\n              });\n              return;\n            }\n            State.update({\n              tokenSymbol: e.target.value,\n            });\n            fetchBalance(e.target.value);\n          }}\n        >\n          <option selected={state.tokenSymbol === null} value={null}>\n            ...\n          </option>\n          {Object.keys(state.tokens).map((symbol) => (\n            <option value={symbol}>{symbol}</option>\n          ))}\n        </select>\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"amount\" class=\"form-label\">\n          Enter the amount\n        </label>\n        <input\n          value={state.amount}\n          class=\"form-control\"\n          id=\"amount\"\n          disabled={wrongWalletNetwork || !state.tokenSymbol}\n          placeholder=\"\"\n          onChange={(e) => {\n            const bigNumberAmount = ethers.utils.parseUnits(\n              e.target.value !== \"\" ? e.target.value : \"0\",\n              state.tokens[state.tokenSymbol].decimals\n            );\n            State.update({ amount: e.target.value, bigNumberAmount });\n          }}\n        />\n        {state.tokenSymbol && (\n          <div>\n            Balance:{\" \"}\n            {ethers.utils.formatUnits(\n              state.senderBalance,\n              state.tokens[state.tokenSymbol].decimals\n            )}{\" \"}\n            {state.tokenSymbol}\n          </div>\n        )}\n      </div>\n      {state.tokenSymbol !== \"ETH\" &&\n      state.senderAllowance.lt(state.bigNumberAmount) ? (\n        <div class=\"mb-3\">\n          <button\n            disabled={\n              !state.tokenSymbol ||\n              state.bigNumberAmount.isZero() ||\n              state.lastTxHash\n            }\n            onClick={erc20Approve}\n          >\n            Allow transfer of tokens\n          </button>\n        </div>\n      ) : (\n        <div class=\"mb-3\">\n          <button\n            disabled={\n              !state.tokenSymbol ||\n              state.bigNumberAmount.isZero() ||\n              state.senderBalance.lt(state.bigNumberAmount) ||\n              state.lastTxHash\n            }\n            onClick={bridgeTokens}\n          >\n            Bridge tokens\n          </button>\n        </div>\n      )}\n      {state.lastTxHash && (\n        <div class=\"mb-3\">{`Pending transaction: ${state.lastTxHash}`}</div>\n      )}\n      <p>\n        NOTE: Please make sure that your wallet is compatible with the\n        Destination Network before sending tokens.\n      </p>\n      <p>\n        This component relies on a new indexed bridge transfers API. The user\n        can view their recent transfers on any browser and will be able to\n        finalize a transfer in one click without having to restore the transfer\n        on\n        <a href=\"https://rainbowbridge.app/\" target=\"_blank\" rel=\"noreferrer\">\n          rainbowbridge.app\n        </a>\n        . Only Ethereum ={\">\"} Aurora transfers available atm from this UI.\n      </p>\n      <h3> Recent transfers </h3>\n      <table>\n        <tbody>\n          {recentTransfers.map((t, i) => (\n            <tr>\n              <td>\n                <img\n                  src={\n                    t.metadata.icon?.length\n                      ? t.metadata.icon\n                      : \"https://rainbowbridge.app/static/tokens/aurora.svg\"\n                  }\n                  width=\"25\"\n                  height=\"25\"\n                  style={{ \"margin-bottom\": \"2px\" }}\n                />\n                {ethers.utils.formatUnits(t.amount, t.metadata.decimals)}\n                {t.metadata.symbol}\n              </td>\n              <td>\n                <a\n                  href={`${ethExplorerUrl}/tx/${t.ethHash}`}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                >\n                  <img\n                    src={\"https://rainbowbridge.app/static/tokens/eth.svg\"}\n                    class=\"networkIcon\"\n                    width=\"30\"\n                    height=\"30\"\n                  />\n                </a>\n                ={\">\"}\n                <a\n                  href={`${nearExplorerUrl}/receipts/${t.nearReceipt}`}\n                  target=\"_blank\"\n                  rel=\"noreferrer\"\n                >\n                  <img\n                    src={\"https://rainbowbridge.app/static/tokens/aurora.svg\"}\n                    class=\"networkIcon\"\n                    width=\"30\"\n                    height=\"30\"\n                  />\n                </a>\n              </td>\n              <td>{t.status}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  </Theme>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/opacode.near/widget/RainbowBridge", "metadata.image.url": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.linktree.website": NaN, "metadata.name": NaN, "metadata.tags.aurora": NaN, "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.tags.bridge": NaN}