{"tx_hash": "En6nxe2NaZn8BVw9CaVdZEqtzosjrXheMuJYdcMMTWAy", "action_id_social": "8Aq2VHST96w33ctFG4RFvjqXKam2vBeu1e45udr8ZbJj-0-widget", "block_id": 89632954, "block_timestamp": "2023-04-15 10:32:44.221", "signer_id": "opacode.near", "widget_name": "RainbowBridge", "source_code": "const sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n// NOTE: Switching account in MetaMask doesn't update the sender.\nif (!sender) return <Web3Connect connectLabel=\"Connect Web3 Wallet\" />;\n\nconst networks = [\"ethereum\", \"aurora\"];\nconst testnetChainIds = {\n  ethereum: 5,\n  aurora: 1313161555,\n};\nconst testnetNetworkNames = {\n  ethereum: \"Goerli Testnet\",\n  aurora: \"Aurora Testnet\",\n};\nconst mainnetChainIds = {\n  ethereum: 1,\n  aurora: 1313161554,\n};\nconst mainnetNetworkNames = {\n  ethereum: \"Ethereum Mainnet\",\n  aurora: \"Aurora Mainnet\",\n};\nconst testnetConfig = {\n  etherCustodianAddress: \"0x84a82Bb39c83989D5Dc07e1310281923D2544dC2\",\n  erc20LockerAddress: \"0xc115851ca60aed2ccc6ee3d5343f590834e4a3ab\",\n};\nconst mainnetConfig = {\n  etherCustodianAddress: \"0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52\",\n  erc20LockerAddress: \"0x23ddd3e3692d1861ed57ede224608875809e127f\",\n};\nconst testnetTokens = {\n  ETH: {\n    symbol: \"ETH\",\n    name: \"Ether\",\n    ethereumAddress: undefined,\n    nearAddress: \"aurora\",\n    auroraAddress: undefined,\n    decimals: 18,\n    origin: \"ethereum\",\n    icon: \"https://rainbowbridge.app/static/tokens/eth.svg\",\n  },\n\n  FAU: {\n    symbol: \"FAU\",\n    name: \"FaucetToken\",\n    ethereumAddress: \"0xba62bcfcaafc6622853cca2be6ac7d845bc0f2dc\",\n    nearAddress:\n      \"ba62bcfcaafc6622853cca2be6ac7d845bc0f2dc.factory.goerli.testnet\",\n    auroraAddress: \"0xf93cd0e464f74c240d8ebb7ed55ce6b43452f913\",\n    decimals: 18,\n    origin: \"ethereum\",\n  },\n};\nconst mainnetTokens = {\n  ETH: {\n    symbol: \"ETH\",\n    name: \"Ether\",\n    ethereumAddress: undefined,\n    nearAddress: \"aurora\",\n    auroraAddress: undefined,\n    decimals: 18,\n    origin: \"ethereum\",\n    icon: \"https://rainbowbridge.app/static/tokens/eth.svg\",\n  },\n  \"USDC.e\": {\n    symbol: \"USDC.e\",\n    name: \"USD Coin\",\n    ethereumAddress: \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n    nearAddress: \"a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near\",\n    auroraAddress: \"0xb12bfca5a55806aaf64e99521918a4bf0fc40802\",\n    decimals: 6,\n    origin: \"ethereum\",\n    icon: \"https://rainbowbridge.app/static/tokens/usdc.svg\",\n  },\n  AURORA: {\n    symbol: \"AURORA\",\n    name: \"Aurora\",\n    ethereumAddress: \"0xaaaaaa20d9e0e2461697782ef11675f668207961\",\n    nearAddress: \"aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near\",\n    auroraAddress: \"0x8bec47865ade3b172a928df8f990bc7f2a3b9f79\",\n    decimals: 18,\n    origin: \"ethereum\",\n    icon: \"https://rainbowbridge.app/static/tokens/aurora.svg\",\n  },\n};\n\nconst fetchBalance = (tokenSymbol) => {\n  const tokenAddress =\n    state.tokens[tokenSymbol][`${state.sourceNetwork}Address`];\n  if (tokenAddress?.length) {\n    // erc-20\n    const erc20 = new ethers.Contract(\n      tokenAddress,\n      [\n        \"function balanceOf(address) view returns (uint)\",\n        \"function allowance(address owner, address spender) view returns (uint)\",\n      ],\n      Ethers.provider()\n    );\n    erc20.balanceOf(sender).then((balance) => {\n      State.update({\n        senderBalance: ethers.BigNumber.from(balance),\n        tokenSymbol,\n      });\n    });\n    erc20\n      .allowance(sender, state.config.erc20LockerAddress)\n      .then((allowance) => {\n        State.update({\n          senderAllowance: ethers.BigNumber.from(allowance),\n          tokenSymbol,\n        });\n      });\n  } else if (tokenAddress === undefined) {\n    Ethers.provider()\n      .getBalance(sender)\n      .then((balance) => {\n        State.update({\n          senderBalance: ethers.BigNumber.from(balance),\n          tokenSymbol,\n        });\n      });\n  } else {\n    // Token address = null: not bridged on this network.\n    State.update({\n      senderBalance: ethers.BigNumber.from(0),\n      senderAllowance: ethers.BigNumber.from(0),\n      tokenSymbol,\n    });\n  }\n};\n\nconst erc20Approve = () => {\n  const tokenAddress =\n    state.tokens[state.tokenSymbol][`${state.sourceNetwork}Address`];\n  const erc20 = new ethers.Contract(\n    tokenAddress,\n    [\"function approve(address,uint) public returns (bool)\"],\n    Ethers.provider().getSigner()\n  );\n  erc20\n    .approve(state.config.erc20LockerAddress, state.bigNumberAmount)\n    .then((tx) => {\n      console.log(tx);\n      State.update({ lastTxHash: tx.hash });\n      tx.wait().then((receipt) => {\n        console.log(receipt);\n        fetchBalance(state.tokenSymbol);\n        State.update({ lastTxHash: null });\n      });\n    });\n};\n\nconst bridgeTokens = () => {\n  if (state.sourceNetwork !== \"ethereum\") {\n    console.log(\"Coming soon...\");\n    return;\n  }\n  if (state.tokenSymbol === \"ETH\") {\n    const ethTokenLocker = new ethers.Contract(\n      state.config.etherCustodianAddress,\n      // NOTE: for some reason human readable abi gives\n      // Error: Not a function call expression\n      // when calling the payable contract, so use standard abi.\n      //[\"function depositToEvm(string,uint256) payable\"],\n      [\n        {\n          inputs: [\n            {\n              internalType: \"string\",\n              name: \"ethRecipientOnNear\",\n              type: \"string\",\n            },\n            { internalType: \"uint256\", name: \"fee\", type: \"uint256\" },\n          ],\n          name: \"depositToEVM\",\n          outputs: [],\n          stateMutability: \"payable\",\n          type: \"function\",\n        },\n      ],\n      Ethers.provider().getSigner()\n    );\n    ethTokenLocker\n      .depositToEVM(sender.slice(2).toLowerCase(), 0, {\n        value: state.bigNumberAmount,\n      })\n      .then((tx) => {\n        console.log(tx);\n        State.update({ lastTxHash: tx.hash });\n        tx.wait().then((receipt) => {\n          console.log(receipt);\n          const metadata = state.tokens[state.tokenSymbol];\n          State.update({\n            lastTxHash: null,\n            lastestTransfer: {\n              amount: state.bigNumberAmount.toString(),\n              ethHash: tx.hash,\n              nearReceipt: \"\",\n              status: \"pending\",\n              metadata: {\n                address: tokenAddress,\n                ...metadata,\n              },\n            },\n          });\n        });\n      });\n  } else if (state.tokenSymbol === \"NEAR\") {\n    console.log(\"Coming soon...\");\n  } else {\n    const erc20TokenLocker = new ethers.Contract(\n      state.config.erc20LockerAddress,\n      [\"function lockToken(address,uint,string) public\"],\n      Ethers.provider().getSigner()\n    );\n    const tokenAddress =\n      state.tokens[state.tokenSymbol][`${state.sourceNetwork}Address`];\n    erc20TokenLocker\n      .lockToken(\n        tokenAddress,\n        state.bigNumberAmount,\n        `aurora:${sender.toLowerCase().slice(2)}`\n      )\n      .then((tx) => {\n        console.log(tx);\n        State.update({ lastTxHash: tx.hash });\n        tx.wait().then((receipt) => {\n          console.log(receipt);\n          fetchBalance(state.tokenSymbol);\n          const metadata = state.tokens[state.tokenSymbol];\n          State.update({\n            lastTxHash: null,\n            lastestTransfer: {\n              amount: state.bigNumberAmount.toString(),\n              ethHash: tx.hash,\n              nearReceipt: \"\",\n              status: \"pending\",\n              metadata: {\n                address: tokenAddress,\n                ...metadata,\n              },\n            },\n          });\n        });\n      });\n  }\n};\n\ninitState({\n  tokenSymbol: null,\n  sourceTokenBalance: ethers.BigNumber.from(0),\n  senderBalance: ethers.BigNumber.from(0),\n  senderAllowance: ethers.BigNumber.from(0),\n  amount: \"\",\n  bigNumberAmount: ethers.BigNumber.from(0),\n  sourceNetwork: \"ethereum\",\n  destinationNetwork: \"aurora\",\n  initialized: false,\n  lastTxHash: null,\n});\n\nEthers.provider()\n  .getNetwork()\n  .then((network) => {\n    if (!state.initialized) {\n      // Choose testnet or mainnet config depending on connected network.\n      const walletChainId = network.chainId;\n      const isTestnet =\n        walletChainId === testnetChainIds.aurora ||\n        walletChainId === testnetChainIds.ethereum;\n      // Set the bridge direction on network switch:\n      // bos.gg doesn't keep the component state on wallet network switch !\n      const sourceNetwork =\n        testnetChainIds.ethereum === walletChainId ||\n        mainnetChainIds.ethereum === walletChainId\n          ? \"ethereum\"\n          : \"aurora\";\n      State.update({\n        walletChainId: network.chainId,\n        chainIds: isTestnet ? testnetChainIds : mainnetChainIds,\n        networkNames: isTestnet ? testnetNetworkNames : mainnetNetworkNames,\n        config: isTestnet ? testnetConfig : mainnetConfig,\n        tokens: isTestnet ? testnetTokens : mainnetTokens,\n        isTestnet,\n        sourceNetwork,\n        destinationNetwork:\n          sourceNetwork === \"ethereum\" ? \"aurora\" : \"ethereum\",\n        initialized: true,\n      });\n    }\n  })\n  .catch((error) => console.log(error));\n\nlet transfers;\nif (state.initialized) {\n  transfers = useCache(\n    () =>\n      asyncFetch(\n        `https://jvea2jh4jzwg4vykyhy3mcdh7i0yfosk.lambda-url.eu-central-1.on.aws/${\n          state.isTestnet ? 5 : 1\n        }/${sender}`\n      )\n        .then((res) => res?.body ?? [])\n        .catch((error) => console.log(error)),\n    \"recentTransfers\",\n    { subscribe: true }\n  );\n}\n\nconst lastTransferIndexed =\n  transfers &&\n  transfers.find((t) => t.ethHash === state.lastestTransfer?.ethHash);\nconst recentTransfers =\n  lastTransferIndexed || !state.lastestTransfer\n    ? transfers\n    : [state.lastestTransfer, ...(transfers ?? [])];\n\nif (!state.theme) {\n  State.update({\n    theme: styled.div`\n      .Container{\n        box-sizing: border-box;\n        margin: 8px auto;\n        min-width: 320px;\n        width: 100%;\n        padding: 0px 32px;\n        max-width: 560px;\n        position: relative;\n      }\n      .Header{\n        text-align: center;\n        margin-top: 30px;\n        margin-bottom: 30px;\n      }\n      .networkIcon {\n        border: 3px solid rgb(149,149,149);\n        background-color: rgb(149,149,149);\n      }\n      tr {\n        border-bottom: 1px solid;\n        border-top: 1px solid;\n      }\n      table {\n        width: 100%;\n      }`,\n  });\n}\nconst Theme = state.theme;\nconst ethExplorerUrl = state.isTestnet\n  ? \"https://goerli.etherscan.io\"\n  : \"https://etherscan.io\";\nconst nearExplorerUrl = state.isTestnet\n  ? \"https://explorer.testnet.near.org\"\n  : \"https://explorer.near.org\";\n\nconst wrongWalletNetwork =\n  state.walletChainId !== state.chainIds[state.sourceNetwork];\nif (wrongWalletNetwork) {\n  // Reset selection\n  State.update({\n    tokenSymbol: null,\n    amount: \"\",\n    senderBalance: ethers.BigNumber.from(0),\n    senderAllowance: ethers.BigNumber.from(0),\n    bigNumberAmount: ethers.BigNumber.from(0),\n  });\n}\nif (!state.initialized) return <></>;\nreturn (\n  <Theme>\n    <div class=\"Container\">\n      <h2 class=\"Header\">\n        {\" \"}\n        \ud83c\udf08{\" \"}\n        {state.isTestnet\n          ? \"Testnet Rainbow Bridge\"\n          : \"Rainbow Bridge (alpha)\"}{\" \"}\n        \ud83c\udf08{\" \"}\n      </h2>\n      <div class=\"mb-3\">\n        <label for=\"selectSourceNetwork\">Select Source Network</label>\n        <select\n          class=\"form-select\"\n          id=\"selectSourceNetwork\"\n          onChange={(e) => {\n            State.update({ sourceNetwork: e.target.value });\n            if (state.destinationNetwork === e.target.value) {\n              State.update({\n                destinationNetwork: networks.find(\n                  (network) => network !== e.target.value\n                ),\n              });\n            }\n          }}\n        >\n          <option selected={state.sourceNetwork === \"aurora\"} value={\"aurora\"}>\n            {state.networkNames.aurora}\n          </option>\n          <option\n            selected={state.sourceNetwork === \"ethereum\"}\n            value={\"ethereum\"}\n          >\n            {state.networkNames.ethereum}\n          </option>\n        </select>\n        {state.walletChainId !== state.chainIds[state.sourceNetwork] && (\n          <p>\n            Connect your wallet network to{\" \"}\n            {state.networkNames[state.sourceNetwork]}\n          </p>\n        )}\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"selectDestinationNetwork\">Select Destination Network</label>\n        <select\n          class=\"form-select\"\n          id=\"selectDestinationNetwork\"\n          onChange={(e) => {\n            State.update({ destinationNetwork: e.target.value });\n            if (state.sourceNetwork === e.target.value) {\n              State.update({\n                sourceNetwork: networks.find(\n                  (network) => network !== e.target.value\n                ),\n              });\n            }\n          }}\n        >\n          <option\n            selected={state.destinationNetwork === \"aurora\"}\n            value={\"aurora\"}\n          >\n            {state.networkNames.aurora}\n          </option>\n          <option\n            selected={state.destinationNetwork === \"ethereum\"}\n            value={\"ethereum\"}\n          >\n            {state.networkNames.ethereum}\n          </option>\n        </select>\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"selectToken\">Select token</label>\n        <select\n          class=\"form-select\"\n          id=\"selectToken\"\n          disabled={wrongWalletNetwork}\n          onChange={(e) => {\n            if (e.target.value === \"...\") {\n              State.update({\n                tokenSymbol: null,\n                amount: \"\",\n                bigNumberAmount: ethers.BigNumber.from(0),\n              });\n              return;\n            }\n            State.update({\n              tokenSymbol: e.target.value,\n            });\n            fetchBalance(e.target.value);\n          }}\n        >\n          <option selected={state.tokenSymbol === null} value={null}>\n            ...\n          </option>\n          {Object.keys(state.tokens).map((symbol) => (\n            <option value={symbol}>{symbol}</option>\n          ))}\n        </select>\n      </div>\n      <div class=\"mb-3\">\n        <label for=\"amount\" class=\"form-label\">\n          Enter the amount\n        </label>\n        <input\n          value={state.amount}\n          class=\"form-control\"\n          id=\"amount\"\n          disabled={wrongWalletNetwork || !state.tokenSymbol}\n          placeholder=\"\"\n          onChange={(e) => {\n            const bigNumberAmount = ethers.utils.parseUnits(\n              e.target.value !== \"\" ? e.target.value : \"0\",\n              state.tokens[state.tokenSymbol].decimals\n            );\n            State.update({ amount: e.target.value, bigNumberAmount });\n          }}\n        />\n        {state.tokenSymbol && (\n          <div>\n            Balance:{\" \"}\n            {ethers.utils.formatUnits(\n              state.senderBalance,\n              state.tokens[state.tokenSymbol].decimals\n            )}{\" \"}\n            {state.tokenSymbol}\n          </div>\n        )}\n      </div>\n      {state.tokenSymbol !== \"ETH\" &&\n      state.senderAllowance.lt(state.bigNumberAmount) ? (\n        <div class=\"mb-3\">\n          <button\n            disabled={\n              !state.tokenSymbol ||\n              state.sourceNetwork === \"aurora\" ||\n              state.bigNumberAmount.isZero() ||\n              state.lastTxHash\n            }\n            onClick={erc20Approve}\n          >\n            Allow transfer of tokens\n          </button>\n        </div>\n      ) : (\n        <div class=\"mb-3\">\n          <button\n            disabled={\n              !state.tokenSymbol ||\n              state.sourceNetwork === \"aurora\" ||\n              state.bigNumberAmount.isZero() ||\n              state.senderBalance.lt(state.bigNumberAmount) ||\n              state.lastTxHash\n            }\n            onClick={bridgeTokens}\n          >\n            Bridge tokens\n          </button>\n        </div>\n      )}\n      {state.lastTxHash && (\n        <div class=\"mb-3\">{`Pending transaction: ${state.lastTxHash}`}</div>\n      )}\n      <p>\n        NOTE: Please make sure that your wallet is compatible with the\n        Destination Network before sending tokens.\n      </p>\n      <p>\n        This component relies on a new indexed bridge transfers API. The user\n        can view their recent transfers on any browser and will be able to\n        finalize a transfer in one click without having to restore the transfer\n        on\n        <a href=\"https://rainbowbridge.app/\" target=\"_blank\" rel=\"noreferrer\">\n          rainbowbridge.app\n        </a>\n        . Only Ethereum ={\">\"} Aurora transfers available from this UI.\n      </p>\n      <h3> Recent transfers </h3>\n      <table>\n        <tbody>\n          {recentTransfers &&\n            recentTransfers.map((t, i) => (\n              <tr>\n                <td>\n                  <img\n                    src={\n                      t.metadata.icon?.length\n                        ? t.metadata.icon\n                        : \"https://rainbowbridge.app/static/tokens/aurora.svg\"\n                    }\n                    width=\"25\"\n                    height=\"25\"\n                    style={{ \"margin-bottom\": \"2px\" }}\n                  />\n                  {ethers.utils.formatUnits(t.amount, t.metadata.decimals)}\n                  {t.metadata.symbol}\n                </td>\n                <td>\n                  <a\n                    href={`${ethExplorerUrl}/tx/${t.ethHash}`}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                  >\n                    <img\n                      src={\"https://rainbowbridge.app/static/tokens/eth.svg\"}\n                      class=\"networkIcon\"\n                      width=\"30\"\n                      height=\"30\"\n                    />\n                  </a>\n                  ={\">\"}\n                  <a\n                    href={`${nearExplorerUrl}/receipts/${t.nearReceipt}`}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                  >\n                    <img\n                      src={\"https://rainbowbridge.app/static/tokens/aurora.svg\"}\n                      class=\"networkIcon\"\n                      width=\"30\"\n                      height=\"30\"\n                    />\n                  </a>\n                </td>\n                <td>{t.status}</td>\n              </tr>\n            ))}\n        </tbody>\n      </table>\n    </div>\n  </Theme>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/opacode.near/widget/RainbowBridge", "metadata.image.url": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.linktree.website": NaN, "metadata.name": NaN, "metadata.tags.aurora": NaN, "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.tags.bridge": NaN}