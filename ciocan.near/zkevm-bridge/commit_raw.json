{"tx_hash": "ARu9K61Xkppngg32a4BaVfeC1eQ4XhfMsmCMbu6pRM8y", "action_id_social": "EGxGQpk9K4Nsirk7HFHx3N2h3cwSYGsvEetQWrMCQ5Ph-0-widget", "block_id": 94747122, "block_timestamp": "2023-06-22T06:20:07.514Z", "signer_id": "ciocan.near", "widget_name": "zkevm-bridge", "source_code": "const Container = styled.div`\n  display: flex;\n  gap: 8px;\n\n  .side {\n    margin-top: 20px;\n  }\n`;\n\nconst tokens = [\n  // eth testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 5,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x4701Aa9471d7bfAc765D87dcb1Ea6BB23AD32733\",\n    chainId: 5,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xd35cceead182dcee0f148ebac9447da2c4d449c4\",\n    chainId: 5,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0xD7E55eB808693D5Ff81a3391c59886C7E0449f35\",\n    chainId: 5,\n    symbol: \"DAI\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/9956/small/4943.png\",\n  },\n  {\n    address: \"0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984\",\n    chainId: 5,\n    symbol: \"UNI\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png\",\n  },\n  // eth mainnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0\",\n    chainId: 1,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\",\n    chainId: 1,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0x6B175474E89094C44Da98b954EedeAC495271d0F\",\n    symbol: \"DAI\",\n    decimals: 18,\n    chainId: 1,\n    logoURI: \"https://assets.coingecko.com/coins/images/9956/small/4943.png\",\n  },\n  {\n    address: \"0xdAC17F958D2ee523a2206206994597C13D831ec7\",\n    chainId: 1,\n    symbol: \"USDT\",\n    decimals: 6,\n    logoURI: \"https://assets.coingecko.com/coins/images/325/small/Tether.png\",\n  },\n  {\n    address: \"0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\",\n    chainId: 1,\n    symbol: \"WBTC\",\n    decimals: 8,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/7598/small/wrapped_bitcoin_wbtc.png\",\n  },\n  // zkevm testnet assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1442,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0x8Ba0a934ef4C24e475C78072cCa3Ed306c1aBaDD\",\n    chainId: 1442,\n    symbol: \"USDC\",\n    decimals: 6,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n  {\n    address: \"0x378588D64A464d61c646e5e86F4DA5277e65802C\",\n    chainId: 1442,\n    symbol: \"UNI\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/12504/small/uniswap-uni.png\",\n  },\n  // zkevm assets\n  {\n    address: \"0x0000000000000000000000000000000000000000\",\n    chainId: 1101,\n    symbol: \"ETH\",\n    decimals: 18,\n    logoURI: \"https://assets.coingecko.com/coins/images/279/small/ethereum.png\",\n  },\n  {\n    address: \"0xa2036f0538221a77A3937F1379699f44945018d0\",\n    chainId: 1101,\n    symbol: \"MATIC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/4713/small/matic-token-icon.png\",\n  },\n  {\n    address: \"0xA8CE8aee21bC2A48a5EF670afCc9274C7bbbC035\",\n    chainId: 1101,\n    symbol: \"USDC\",\n    decimals: 18,\n    logoURI:\n      \"https://assets.coingecko.com/coins/images/6319/small/USD_Coin_icon.png\",\n  },\n];\n\nconst MAX_AMOUNT =\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\nState.init({\n  gasLimit: ethers.BigNumber.from(\"300000\"),\n  isToastOpen: false,\n});\n\nconst {\n  chainId,\n  name,\n  isContractAllowedToSpendToken,\n  variant,\n  title,\n  description,\n  isToastOpen,\n} = state;\nconst isMainnet = chainId === 1 || chainId === 1101;\n\nconst onOpenChange = (v) => {\n  State.update({\n    isToastOpen: false,\n  });\n};\n\nconst BRIDGE_CONTRACT_ADDRESS = isMainnet\n  ? \"0x2a3DD3EB832aF982ec71669E178424b10Dca2EDe\"\n  : \"0xF6BEEeBB578e214CA9E23B0e9683454Ff88Ed2A7\";\n\nconst provider = Ethers.provider();\nconst sender = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nconst bridgeAbi = [\n  {\n    inputs: [\n      { internalType: \"uint32\", name: \"destinationNetwork\", type: \"uint32\" },\n      { internalType: \"address\", name: \"destinationAddress\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n      { internalType: \"address\", name: \"token\", type: \"address\" },\n      { internalType: \"bool\", name: \"forceUpdateGlobalExitRoot\", type: \"bool\" },\n      { internalType: \"bytes\", name: \"permitData\", type: \"bytes\" },\n    ],\n    name: \"bridgeAsset\",\n    outputs: [],\n    stateMutability: \"payable\",\n    type: \"function\",\n  },\n];\n\nif (sender) {\n  Ethers.provider()\n    .getNetwork()\n    .then(({ chainId }) => {\n      State.update({ chainId });\n    });\n}\n\nconst bridgeIface = new ethers.utils.Interface(bridgeAbi);\n\nconst updateGasLimit = (props) => {\n  console.log(\"updateGasLimit\", props);\n  const { amount, token, network } = props;\n  if (network !== \"ethereum\") return;\n  const amountBig = ethers.utils.parseUnits(amount.toString(), token.decimals);\n\n  const bridgeContract = new ethers.Contract(\n    BRIDGE_CONTRACT_ADDRESS,\n    bridgeAbi,\n    Ethers.provider().getSigner()\n  );\n  bridgeContract.estimateGas\n    .bridgeAsset(1, sender, amountBig, token.address, true, \"0x\", {\n      from: sender,\n    })\n    .then((data) => {\n      console.log(\"gasLimit\", data);\n    })\n    .catch((e) => {\n      console.log(\"gasLimit error\", e);\n    });\n};\n\nconst handleBridge = (props) => {\n  console.log(\"handleBridge\", props);\n  const { amount, token, network, permit } = props;\n  const networkId = network === \"ethereum\" ? 1 : 0;\n\n  const amountBig = ethers.utils.parseUnits(amount.toString(), token.decimals);\n  // const permitData = permit || \"0x\";\n  const permitData = \"0x\";\n\n  const encodedData = bridgeIface.encodeFunctionData(\n    \"bridgeAsset(uint32,address,uint256,address,bool,bytes)\",\n    [networkId, sender, amountBig, token.address, true, permitData]\n  );\n\n  updateGasLimit(props);\n\n  Ethers.provider()\n    .getSigner()\n    .sendTransaction({\n      to: BRIDGE_CONTRACT_ADDRESS,\n      data: encodedData,\n      value: token.symbol === \"ETH\" ? amountBig : \"0\",\n      gasLimit,\n    })\n    .then((tx) => {\n      consle.log(\"tx:\", tx);\n    })\n    .catch((e) => {\n      console.log(\"bridge error:\", e);\n      if (!e.code) {\n        State.update({\n          isToastOpen: true,\n          variant: \"success\",\n          title: \"Asset bridged\",\n          description:\n            \"Please allow a few seconds and press the 'refresh list' button\",\n        });\n      }\n    });\n};\n\nconst setName = (token) => {\n  const abi = [\"function name() external view returns (string)\"];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n  erc20contract\n    .name()\n    .then((name) => {\n      State.update({ name });\n    })\n    .catch((e) => {\n      console.log(\"name error\", e);\n    });\n};\n\nconst setIsContractAllowedToSpendToken = ({ token, amount }) => {\n  if (!amount) return;\n  const abi = [\n    \"function allowance(address owner, address spender) external view returns (uint256)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n\n  erc20contract\n    .allowance(sender, BRIDGE_CONTRACT_ADDRESS)\n    .then((data) => {\n      const allowance = Number(ethers.utils.formatUnits(data, token.decimals));\n      State.update({\n        isContractAllowedToSpendToken: allowance >= Number(amount),\n      });\n    })\n    .catch((e) => {\n      console.log(\"setIsContractAllowedToSpendToken\", e);\n    });\n};\n\nconst setNonce = (props) => {\n  console.log(\"setNonce\", props);\n  const { token } = props;\n  const signer = Ethers.provider().getSigner();\n\n  const abi = [\n    \"function nonces(address owner) external view returns (uint256)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider()\n  );\n\n  erc20contract\n    .nonces(sender)\n    .then((nonce) => {\n      console.log(\"nonce\", nonce);\n      State.update({ nonce });\n    })\n    .catch((e) => {\n      console.log(\"setNonce err:\", e);\n    });\n};\n\nconst handlePermit = (props) => {\n  console.log(\"handlePermit\", props);\n  const { amount, token, network } = props;\n\n  const domain = {\n    chainId,\n    name: state.name,\n    verifyingContract: token.address,\n    version: \"1\",\n  };\n\n  const types = {\n    Permit: [\n      { name: \"owner\", type: \"address\" },\n      { name: \"spender\", type: \"address\" },\n      { name: \"value\", type: \"uint256\" },\n      { name: \"nonce\", type: \"uint256\" },\n      { name: \"deadline\", type: \"uint256\" },\n    ],\n  };\n\n  const values = {\n    deadline: MAX_AMOUNT,\n    nonce: state.nonce || 0,\n    owner: sender,\n    spender: BRIDGE_CONTRACT_ADDRESS,\n    value: ethers.BigNumber.from(amount),\n  };\n\n  console.log({ domain, types, values });\n\n  Ethers.provider()\n    .getSigner()\n    ._signTypedData(domain, types, values)\n    .then((signature) => {\n      console.log(\"signature\", signature);\n      const { r, s, v } = ethers.utils.splitSignature(signature);\n\n      console.log({ r, s, v });\n\n      const erc20Abi = [\n        {\n          inputs: [\n            {\n              internalType: \"address\",\n              name: \"owner\",\n              type: \"address\",\n            },\n            {\n              internalType: \"address\",\n              name: \"spender\",\n              type: \"address\",\n            },\n            {\n              internalType: \"uint256\",\n              name: \"value\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"uint256\",\n              name: \"deadline\",\n              type: \"uint256\",\n            },\n            {\n              internalType: \"uint8\",\n              name: \"v\",\n              type: \"uint8\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"r\",\n              type: \"bytes32\",\n            },\n            {\n              internalType: \"bytes32\",\n              name: \"s\",\n              type: \"bytes32\",\n            },\n          ],\n          name: \"permit\",\n          outputs: [],\n          stateMutability: \"nonpayable\",\n          type: \"function\",\n        },\n      ];\n\n      const erc20Iface = new ethers.utils.Interface(erc20Abi);\n\n      const permit = erc20Iface.encodeFunctionData(\n        \"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)\",\n        [\n          sender,\n          BRIDGE_CONTRACT_ADDRESS,\n          ethers.BigNumber.from(amount),\n          MAX_AMOUNT,\n          v,\n          r,\n          s,\n        ]\n      );\n\n      console.log(\"permitData\", permit);\n      handleBridge({ ...props, permit });\n    });\n};\n\nconst approve = (props) => {\n  const { token, network, amount } = props;\n  if (isContractAllowedToSpendToken) return;\n\n  const abi = [\n    \"function approve(address spender, uint256 amount) external returns (bool)\",\n  ];\n  const erc20contract = new ethers.Contract(\n    token.address,\n    abi,\n    Ethers.provider().getSigner()\n  );\n\n  return erc20contract.approve(\n    BRIDGE_CONTRACT_ADDRESS,\n    ethers.BigNumber.from(MAX_AMOUNT)\n  );\n};\n\nconst onConfirm = (props) => {\n  const { token, network, amount } = props;\n  if (token.symbol !== \"ETH\" && network === \"ethereum\") {\n    const res = approve(props);\n    console.log(\"approve response:\", res);\n    if (res) {\n      res\n        .then((tx) => {\n          console.log(\"approve\", tx);\n          handlePermit(props);\n        })\n        .catch((e) => {\n          console.log(\"approve err\", e);\n        });\n    } else {\n      handlePermit(props);\n    }\n  } else {\n    handleBridge(props);\n  }\n};\n\nconst onChangeAmount = (props) => {\n  console.log(\"onChangeAmount\", props);\n  setIsContractAllowedToSpendToken(props);\n};\n\nconst onUpdateToken = (props) => {\n  console.log(\"onUpdateToken\", props);\n  setIsContractAllowedToSpendToken(props);\n  setName(props.token);\n  setNonce(props);\n};\n\nif (!sender) {\n  return <Web3Connect connectLabel=\"Connect ETH Wallet\" />;\n}\n\nconsole.log(state);\n\nreturn (\n  <Container>\n    <Widget\n      src=\"ciocan.near/widget/zkevm-bridge-ui\"\n      props={{ onConfirm, onUpdateToken, onChangeAmount, tokens }}\n    />\n    <div class=\"side\">\n      <Widget\n        src=\"ciocan.near/widget/zkevm-bridge-transactions\"\n        props={{ tokens }}\n      />\n    </div>\n    <Widget\n      src=\"ciocan.near/widget/toast\"\n      props={{ open: isToastOpen, variant, title, description, onOpenChange }}\n    />\n  </Container>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/ciocan.near/widget/zkevm-bridge", "__row_index": 2}