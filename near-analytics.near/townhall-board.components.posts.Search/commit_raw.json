{"tx_hash": null, "action_id_social": "E2mFkK3Qyuvdc24YDFjcmouYM95W5N53pgg34Xy3Q39J-0-widget", "block_id": 93756103, "block_timestamp": "2023-06-08T18:50:42.350Z", "signer_id": "near-analytics.near", "widget_name": "townhall-board.components.posts.Search", "source_code": "/* INCLUDE: \"common.jsx\" */\nconst nearNFDevsContractAccountId =\n  props.nearNFDevsContractAccountId ||\n  (context.widgetSrc ?? \"near-analytics.near\").split(\"/\", 1)[0];\n\nconst nearNFDevsWidgetsAccountId =\n  props.nearNFDevsWidgetsAccountId ||\n  (context.widgetSrc ?? \"near-analytics.near\").split(\"/\", 1)[0];\n\nfunction widget(widgetName, widgetProps, key) {\n  widgetProps = {\n    ...widgetProps,\n    nearNFDevsContractAccountId: props.nearNFDevsContractAccountId,\n    nearNFDevsWidgetsAccountId: props.nearNFDevsWidgetsAccountId,\n    referral: props.referral,\n  };\n\n  return (\n    <Widget\n      src={`${nearNFDevsWidgetsAccountId}/widget/townhall-board.${widgetName}`}\n      props={widgetProps}\n      key={key}\n    />\n  );\n}\n\nfunction href(widgetName, linkProps) {\n  linkProps = { ...linkProps };\n\n  if (props.nearNFDevsContractAccountId) {\n    linkProps.nearNFDevsContractAccountId = props.nearNFDevsContractAccountId;\n  }\n\n  if (props.nearNFDevsWidgetsAccountId) {\n    linkProps.nearNFDevsWidgetsAccountId = props.nearNFDevsWidgetsAccountId;\n  }\n\n  if (props.referral) {\n    linkProps.referral = props.referral;\n  }\n\n  const linkPropsQuery = Object.entries(linkProps)\n    .filter(([_key, nullable]) => (nullable ?? null) !== null)\n    .map(([key, value]) => `${key}=${value}`)\n    .join(\"&\");\n\n  return `/#/${nearNFDevsWidgetsAccountId}/widget/townhall-board.pages.${widgetName}${\n    linkPropsQuery ? \"?\" : \"\"\n  }${linkPropsQuery}`;\n}\n/* END_INCLUDE: \"common.jsx\" */\n\n//////////////////////////////////////////////////////////////////////\n///STOPWORDS//////////////////////////////////////////////////////////\nconst stopWords = [\n  \"about\",\n  \"above\",\n  \"after\",\n  \"again\",\n  \"against\",\n  \"all\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"because\",\n  \"been\",\n  \"before\",\n  \"being\",\n  \"below\",\n  \"between\",\n  \"both\",\n  \"but\",\n  \"can\",\n  \"cannot\",\n  \"could\",\n  \"did\",\n  \"does\",\n  \"doing\",\n  \"down\",\n  \"during\",\n  \"each\",\n  \"etc\",\n  \"few\",\n  \"for\",\n  \"from\",\n  \"further\",\n  \"had\",\n  \"has\",\n  \"have\",\n  \"having\",\n  \"her\",\n  \"hers\",\n  \"herself\",\n  \"him\",\n  \"himself\",\n  \"his\",\n  \"how\",\n  \"into\",\n  \"its\",\n  \"itself\",\n  \"just\",\n  \"more\",\n  \"most\",\n  \"myself\",\n  \"nor\",\n  \"not\",\n  \"now\",\n  \"off\",\n  \"once\",\n  \"only\",\n  \"other\",\n  \"our\",\n  \"ours\",\n  \"ourselves\",\n  \"out\",\n  \"over\",\n  \"own\",\n  \"same\",\n  \"she\",\n  \"should\",\n  \"some\",\n  \"still\",\n  \"such\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"their\",\n  \"theirs\",\n  \"them\",\n  \"themselves\",\n  \"then\",\n  \"there\",\n  \"these\",\n  \"they\",\n  \"this\",\n  \"those\",\n  \"through\",\n  \"too\",\n  \"under\",\n  \"until\",\n  \"very\",\n  \"was\",\n  \"were\",\n  \"what\",\n  \"when\",\n  \"where\",\n  \"which\",\n  \"while\",\n  \"who\",\n  \"whom\",\n  \"why\",\n  \"will\",\n  \"with\",\n  \"you\",\n  \"your\",\n  \"yours\",\n  \"yourself\",\n  \"yourselves\",\n  \"www\",\n  \"http\",\n  \"com\",\n];\n\nconst stopWordsDictionary = {};\nfor (let i = 0; i < stopWords.length; i++) {\n  stopWordsDictionary[stopWords[i]] = true;\n}\n\nfunction isStopWord(word) {\n  return stopWordsDictionary.hasOwnProperty(word.toLowerCase());\n}\n//////////////////////////////////////////////////////////////////////\n///SYNONYMS///////////////////////////////////////////////////////////\nconst synonyms = {\n  ether: \"ethereum\",\n  eth: \"ethereum\",\n  either: \"ethereum\",\n  app: \"application\",\n  cryptocyrrency: \"crypto\",\n  developerdao: \"devdao\",\n  dev: \"develop\",\n  doc: \"document\",\n  lib: \"librari\",\n  saw: \"see\",\n  seen: \"see\",\n  tweet: \"twitter\",\n  paid: \"pai\",\n  src: \"sourc\",\n};\n\nconst applySynonym = (word) => {\n  if (synonyms.hasOwnProperty(word.toLowerCase())) {\n    return synonyms[word];\n  }\n  return word;\n};\n//////////////////////////////////////////////////////////////////////\n///STEMMING///////////////////////////////////////////////////////////\nconst step2list = {\n  ational: \"ate\",\n  tional: \"tion\",\n  enci: \"ence\",\n  anci: \"ance\",\n  izer: \"ize\",\n  bli: \"ble\",\n  alli: \"al\",\n  entli: \"ent\",\n  eli: \"e\",\n  ousli: \"ous\",\n  ization: \"ize\",\n  ation: \"ate\",\n  ator: \"ate\",\n  alism: \"al\",\n  iveness: \"ive\",\n  fulness: \"ful\",\n  ousness: \"ous\",\n  aliti: \"al\",\n  iviti: \"ive\",\n  biliti: \"ble\",\n  logi: \"log\",\n};\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: \"ic\",\n  ative: \"\",\n  alize: \"al\",\n  iciti: \"ic\",\n  ical: \"ic\",\n  ful: \"\",\n  ness: \"\",\n};\n\nconst gt0 = /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)/;\nconst eq1 =\n  /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)([aeiouy][aeiou]*)?$/;\nconst gt1 =\n  /^([^aeiou][^aeiouy]*)?(([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)){2,}/;\nconst vowelInStem = /^([^aeiou][^aeiouy]*)?[aeiouy]/;\nconst consonantLike = /^([^aeiou][^aeiouy]*)[aeiouy][^aeiouwxy]$/;\n\n// Exception expressions.\nconst sfxLl = /ll$/;\nconst sfxE = /^(.+?)e$/;\nconst sfxY = /^(.+?)y$/;\nconst sfxIon = /^(.+?(s|t))(ion)$/;\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/;\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/;\nconst sfxEED = /^(.+?)eed$/;\nconst sfxS = /^.+?[^s]s$/;\nconst sfxSsesOrIes = /^.+?(ss|i)es$/;\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/;\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nfunction stemmer(value) {\n  let result = value.toLowerCase();\n\n  // Exit early.\n  if (result.length < 3) {\n    return result;\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false;\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true;\n    result = \"Y\" + result.slice(1);\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2);\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1);\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match;\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1);\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1];\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += \"e\";\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1);\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += \"e\";\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + \"i\";\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]];\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]];\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1];\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1];\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1];\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1);\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = \"y\" + result.slice(1);\n  }\n\n  return result;\n}\n\n//////////////////////////////////////////////////////////////////////\n///SPELLCHECK/////////////////////////////////////////////////////////\nfunction levenshteinDistance(s, t, threshold) {\n  const BIG_NUMBER = 10000;\n  if (s == null || t == null) {\n    return BIG_NUMBER;\n  }\n  if (threshold < 0) {\n    return BIG_NUMBER;\n  }\n  let n = s.length;\n  let m = t.length;\n  if (Math.abs(n - m) >= threshold) {\n    return BIG_NUMBER;\n  }\n\n  // if one string is empty, the edit distance is necessarily the length of the other\n  if (n == 0) {\n    return m <= threshold ? m : BIG_NUMBER;\n  } else if (m == 0) {\n    return n <= threshold ? n : BIG_NUMBER;\n  }\n\n  if (n > m) {\n    // swap the two strings to consume less memory\n    let temp = s;\n    s = t;\n    t = temp;\n    let tempSize = n;\n    n = m;\n    m = tempSize;\n  }\n\n  let p = Array.from({ length: n + 1 }, () => 0); // 'previous' cost array, horizontally\n  let d = Array.from({ length: n + 1 }, () => 0); // cost array, horizontally\n  let _d; // placeholder to assist in swapping p and d\n\n  // fill in starting table values\n  const boundary = Math.min(n, threshold) + 1;\n  for (let i = 0; i < boundary; i++) {\n    p[i] = i;\n  }\n  // these fills ensure that the value above the rightmost entry of our\n  // stripe will be ignored in following loop iterations\n  for (let i = boundary; i < p.length; i++) {\n    p[i] = BIG_NUMBER;\n  }\n  for (let i = 0; i < d.length; i++) {\n    d[i] = BIG_NUMBER;\n  }\n\n  // iterates through t\n  for (let j = 1; j <= m; j++) {\n    const t_j = t.charAt(j - 1); // jth character of t\n    d[0] = j;\n\n    // compute stripe indices, constrain to array size\n    const min = Math.max(1, j - threshold);\n    const max = j > BIG_NUMBER - threshold ? n : Math.min(n, j + threshold);\n\n    // the stripe may lead off of the table if s and t are of different sizes\n    if (min > max) {\n      return BIG_NUMBER;\n    }\n\n    // ignore entry left of leftmost\n    if (min > 1) {\n      d[min - 1] = BIG_NUMBER;\n    }\n\n    // iterates through [min, max] in s\n    for (let i = min; i <= max; i++) {\n      if (s.charAt(i - 1) == t_j) {\n        // diagonally left and up\n        d[i] = p[i - 1];\n      } else {\n        // 1 + minimum of cell to the left, to the top, diagonally left and up\n        d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n      }\n    }\n\n    // copy current distance counts to 'previous row' distance counts\n    _d = p;\n    p = d;\n    d = _d;\n  }\n  // we don't need to check for threshold here because we did it inside the loop\n  return p[n] <= threshold ? p[n] : BIG_NUMBER;\n}\n\nconst spellcheckQueryProcessing = (query, dictionary) => {\n  // Split text document into words\n  const words = stemAndFilterQuery(query);\n  const dictionaryArray = Object.keys(dictionary);\n  // Iterate over each word in the text\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i].toLowerCase().replace(/[^a-z0-9]/g, \"\");\n\n    // If the word is not in the dictionary, find the closest match\n    if (!dictionary.hasOwnProperty(word)) {\n      let closestMatch = undefined;\n      let closestDistance = word.length;\n      let allowedDistance = Math.min(word.length - 1, 3);\n      // Iterate over each word in the dictionary\n      if (word.length > 1) {\n        for (let j = 0; j < dictionaryArray.length; j++) {\n          let dictWord = dictionaryArray[j];\n          let distance = levenshteinDistance(word, dictWord, allowedDistance);\n\n          // If the distance is less than the closest distance, update the closest match\n          if (distance <= allowedDistance && distance < closestDistance) {\n            closestMatch = dictWord;\n            closestDistance = distance;\n          }\n        }\n      }\n      // Replace the misspelled word with the closest match\n      words[i] = closestMatch;\n    }\n  }\n  return words.filter((word) => !!word);\n};\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/near-analytics.near/widget/townhall-board.components.posts.Search", "__row_index": 3}