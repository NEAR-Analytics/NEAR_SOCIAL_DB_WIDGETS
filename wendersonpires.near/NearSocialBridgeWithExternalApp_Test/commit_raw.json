{"tx_hash": "38SevsF2tini5MJ6tEP7tJzpYFYGX2rrdqWX3GAR7sFi", "action_id_social": "H2dwR33EBydy9jU5m3aVSiHXuHbWHk7XU8ivYi7L41U3-0-widget", "block_id": 87575597, "block_timestamp": "2023-03-18 14:31:53.439", "signer_id": "wendersonpires.near", "widget_name": "NearSocialBridgeWithExternalApp_Test", "source_code": "// INITIAL PROPS [EDIT]:\nconst externalAppUrl = \"https://6fa4294326de.ngrok.app/\";\nconst env = \"development\"; // Possible values: 'development' | 'production'\n\n// SETUP: [Navigation] Get the initial route / path (optional)\n// path: e.g \"https://near.social/#/wendersonpires.near/widget/MyWidget?path=/\"\nconst initialPath = props.path;\n\nlet sessionStorageClone = {};\n\n// SETUP:  message sender (it will re-send the message to the iframe source)\nconst sendMessage = (message) => {\n  State.update({\n    currentMessage: message,\n  });\n};\n\n// SETUP: Answer Factory\nconst buildAnswer = (requestType, payload) => {\n  return {\n    type: \"answer\",\n    requestType,\n    payload,\n  };\n};\n\n// SETUP: Set initial state\nState.init({\n  // SETUP:  message sender (it will re-send the message to the iframe source)\n  currentMessage: {},\n  connectMessageSent: false,\n  env, // Possible values: 'development' | 'production'\n  // SETUP: Iframe height\n  iframeHeight: 720,\n  // SETUP: [Session Storage] It'll always have the same data provided inside the external app\n  sessionStorageClone: {},\n});\n\n// SETUP: Connect Payload data sent once the connection is established\nconst accountId = props.accountId ?? context.accountId ?? \"*\";\nconst profileInfo = props.profile ?? Social.getr(`${accountId}/profile`);\nconst createConnectionPayload = () => ({\n  type: \"connect\",\n  created_at: Date.now(),\n  payload: {\n    // SETUP: initial path (tell the external app witch route should be rendered first)\n    initialPath,\n    // additional data below (optional)\n    accountId,\n    ipfsCidAvatar: profileInfo.image?.ipfs_cid,\n  },\n});\nconst welcomePayload = createConnectionPayload();\n\n// Wait a bit to send the \"connect\" payload only after all the scripts are loaded\nsetTimeout(() => {\n  State.update({ connectMessageSent: true });\n  if (!state.connectMessageSent) {\n    sendMessage(welcomePayload);\n\n    // If in Development mode, check the connection every 2 seconds.\n    // This is because the external app can be reloaded when the developer\n    // makes changes to it and the connection is lost\n    if (state.env === \"development\") {\n      setInterval(() => {\n        sendMessage(createConnectionPayload());\n      }, 2000);\n    }\n  }\n}, 0);\n\n// SETUP: On message handler. On get message handler (from the External App)\nconst onMessageHandler = (message) => {\n  // Internal Request Handler\n  internalRequestHandler(message);\n\n  // Custom Request Handler\n  customRequestHandler(message);\n};\n\nconst internalRequestHandler = (message) => {\n  switch (message.type) {\n    case \"nsb:session-storage:hydrate-viewer\":\n      sessionStorageHydrateViewer(message.type, message.payload);\n      break;\n    case \"nsb:session-storage:hydrate-app\":\n      sessionStorageHydrateApp(message.type, message.payload);\n      break;\n    case \"nsb:bridge-service:update-status\":\n      updateBridgeServiceStatus(message.type, message.payload);\n      break;\n    case \"nsb:bridge-service:get-status\":\n      sendBridgeServiceStatusToExternalApp(message.type, message.payload);\n      break;\n    case \"nsb:navigation:sync-content-height\":\n      syncContentHeight(message.type, message.payload);\n  }\n};\n\nconst sessionStorageHydrateViewer = (requestType, payload) => {\n  if (payload) {\n    State.update({ sessionStorageClone: payload });\n  }\n\n  const responseBody = buildAnswer(requestType);\n  sendMessage(responseBody);\n};\n\nconst sessionStorageHydrateApp = (requestType, payload) => {\n  const responseBody = buildAnswer(requestType, state.sessionStorageClone);\n  sendMessage(responseBody);\n};\n\nconst updateBridgeServiceStatus = (requestType, payload) => {\n  if (payload) {\n    State.update({ bridgeServiceStatus: payload });\n  }\n\n  const responseBody = buildAnswer(requestType);\n  sendMessage(responseBody);\n};\n\nconst sendBridgeServiceStatusToExternalApp = (requestType, payload) => {\n  const responseBody = buildAnswer(requestType, state.bridgeServiceStatus);\n  sendMessage(responseBody);\n};\n\nconst syncContentHeight = (requestType, payload) => {\n  if (payload.height) {\n    State.update({ iframeHeight: payload.height });\n  }\n\n  const responseBody = buildAnswer(requestType);\n  sendMessage(responseBody);\n};\n\n// SETUP: Custom Request Handlers Below\nconst customRequestHandler = (message) => {\n  switch (message.type) {\n    case \"get-updated-user-info\":\n      sendUpdatedUserInfo(message.type, message.payload);\n      break;\n  }\n};\n\nconst sendUpdatedUserInfo = (requestType, payload) => {\n  const updatedUserInfo = buildAnswer(requestType, {\n    accountId,\n    profileInfo,\n  });\n  sendMessage(updatedUserInfo);\n};\n\nreturn (\n  <iframe\n    id=\"main-iframe\"\n    className=\"w-100\"\n    style={{\n      height: `${state.iframeHeight}px`,\n    }}\n    // Load external app\n    src={externalAppUrl}\n    // Data the Near Social View is going to send to the External App\n    message={state.currentMessage}\n    // When the external app send a message back to the NS View\n    onMessage={onMessageHandler}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/wendersonpires.near/widget/NearSocialBridgeWithExternalApp_Test"}