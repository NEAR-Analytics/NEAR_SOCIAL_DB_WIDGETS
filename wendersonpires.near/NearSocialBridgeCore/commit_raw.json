{"tx_hash": "4v7Tbh5UYB9Yd943Wf7u2aGHoWndFkAduxszTYVAEgX8", "action_id_social": "Cbiq7x2bYJg3ccbcnAK5a9621uwD2HpPe8tKBvYLWoaw-0-widget", "block_id": 87960242, "block_timestamp": "2023-03-23 18:40:40.809", "signer_id": "wendersonpires.near", "widget_name": "NearSocialBridgeCore", "source_code": "/**\n * Near Social Bridge - Core\n *\n * This is part of a library that allows you to inject an external React App in a Widget created inside\n * Near Social as well as send and receive data from it.\n *\n * Basically, The View works as a Backend source.\n *\n * Visit https://github.com/wpdas/near-social-bridge to get to know how to use it\n */\n\n// Error handlers\nif (!props.externalAppUrl) {\n  return (\n    <p style={{ fontWeight: 600, color: \"#AB2E28\", fontFamily: \"Courier new\" }}>\n      Error: \"externalAppUrl\" prop must be provided\n    </p>\n  );\n}\n\n// (i) Discovery API uses cached data structure\nconst Utils = {\n  /**\n   * Send message\n   */\n  sendMessage: (message) => {\n    State.update({\n      currentMessage: message,\n    });\n  },\n  /**\n   * Call resolve or reject for a given caller\n   * E.g:\n   * Utils.promisify(() => getCachedObject(), (res) => console.log(res), (err) => console.log(err))\n   */\n  promisify: (caller, resolve, reject) => {\n    const timer = 1000;\n    const timeout = timer * 10;\n    let timeoutCheck = 0;\n\n    const find = () => {\n      const response = caller();\n      if (response) {\n        resolve(response);\n      } else {\n        if (timeoutCheck < timeout) {\n          // try again\n          setTimeout(find, 1000);\n          timeoutCheck += timer;\n        } else {\n          reject(null);\n        }\n      }\n    };\n\n    // Fist attempt\n    find();\n  },\n};\n\n// External App Url\nconst externalAppUrl = props.externalAppUrl;\n\n// User Info\nconst accountId = context.accountId;\nconsole.log(\"INITIAL ACCOUNT ID:\", accountId);\nconst userInfo = { accountId };\n\n// Initial Path\nconst initialPath = props.path;\n\n// Initial iframe height\nconst initialIframeHeight = props.initialViewHeight || 500;\n\n// Initial Payload (optional)\nconst initialPayload = props.initialPayload;\n\nconst buildConnectionPayload = () => ({\n  type: \"connect\",\n  payload: {\n    userInfo,\n    initialPath,\n    initialPayload,\n  },\n  created_at: Date.now(),\n});\n\n// Initial State\nState.init({\n  connectedToExternalApp: false,\n  iframeHeight: initialIframeHeight,\n  sessionStorageClone: {},\n  // (i) DON'T send async data, it's going to randonly fail\n  // If you need to get new info, use \"request\" for that\n  currentMessage: buildConnectionPayload(),\n});\n\n// Send the \"connect\" msg again until the External App is connected\nconst checkConnection = () => {\n  if (!state.connectedToExternalApp) {\n    // Try to connect to the external app again\n    Utils.sendMessage(buildConnectionPayload());\n    setTimeout(checkConnection, 2000);\n  }\n};\ncheckConnection();\nconsole.log(\"CHECKKKKKKK\", state.connectedToExternalApp);\n\n// Answer Factory\nconst buildAnswer = (requestType, payload) => {\n  return {\n    from: \"core\",\n    type: \"answer\",\n    requestType,\n    payload,\n    created_at: Date.now(),\n  };\n};\n\n/**\n * Widget response factory - closure\n *\n * E.g:\n * const response = responseFactory.build()\n * response({type: 'request-type'}).send({myPayloadHere: 123})\n */\nconst responseFactory = {\n  build: () => {\n    return (request) => {\n      return {\n        send: (payload) => {\n          const responseBody = buildAnswer(request.type, payload);\n          Utils.sendMessage(responseBody);\n        },\n      };\n    };\n  },\n};\n\n// Message handler\nconst onMessageHandler = (message) => {\n  // Handles core calls\n  if (message.type.includes(\"nsb:\")) {\n    requestsHandler(message);\n    return;\n  }\n\n  // Handles Widget request calls:\n  // - request: payload sent by External App\n  // - response: method to send the answer back to the External App\n  // - utils: Utils features like: promisify, ...\n  const request = {\n    type: message.type,\n    payload: message.payload,\n  };\n  const utils = {\n    promisify: Utils.promisify,\n  };\n  props.requestHandler(request, responseFactory.build(), utils);\n};\n\n// CORE - REQUEST HANDLERS BELOW\nconst requestsHandler = (message) => {\n  switch (message.type) {\n    case \"nsb:navigation:sync-content-height\":\n      setIframeHeight(message.type, message.payload);\n      break;\n    case \"nsb:session-storage:hydrate-viewer\":\n      sessionStorageHydrateViewer(message.type, message.payload);\n      break;\n    case \"nsb:session-storage:hydrate-app\":\n      sessionStorageHydrateApp(message.type, message.payload);\n      break;\n    case \"nsb:auth:get-user-info\":\n      getUserInfo(message.type, message.payload);\n      break;\n    case \"nsb:bridge-service:connection-established\":\n      setConnectionStatus(message.type, message.payload);\n      break;\n  }\n};\n\n// [DON'T REMOVE]: Set thew new iFrame height based on the new screen/route\nconst setIframeHeight = (requestType, payload) => {\n  State.update({ iframeHeight: payload.height + 20 });\n  const responseBody = buildAnswer(requestType);\n  Utils.sendMessage(responseBody);\n};\n\n// [DON'T REMOVE]: Hydrate View session data with data provided by the External App\nconst sessionStorageHydrateViewer = (requestType, payload) => {\n  if (payload) {\n    State.update({ sessionStorageClone: payload });\n  }\n\n  const responseBody = buildAnswer(requestType, payload);\n  Utils.sendMessage(responseBody);\n};\n\n// [DON'T REMOVE]: Hydrate External App with data provided by the View\nconst sessionStorageHydrateApp = (requestType, payload) => {\n  const responseBody = buildAnswer(requestType, state.sessionStorageClone);\n  Utils.sendMessage(responseBody);\n};\n\n// [DON'T REMOVE]: Get user info\nconst getUserInfo = (requestType, payload) => {\n  console.log(\"ACCOUNT ID getUserInfo:\", accountId, context.accountId);\n  Utils.promisify(\n    () => Social.getr(`${accountId}/profile`), // profile info\n    (res) => {\n      const responseBody = buildAnswer(requestType, {\n        accountId,\n        profileInfo: res,\n      });\n      console.log(\"ACCOUNT AAAAA\", responseBody);\n      Utils.sendMessage(responseBody);\n    },\n    (err) => {\n      console.log(\"ACCOUNT BBBB\");\n      console.log(\"error fetching profile data\", err);\n    }\n  );\n};\n\n// [DON'T REMOVE]: Set the connection status (external app saying it's connected)\nconst setConnectionStatus = (requestType) => {\n  State.update({ connectedToExternalApp: true });\n  const responseBody = buildAnswer(requestType);\n  Utils.sendMessage(responseBody);\n};\n// CORE - REQUEST HANDLERS ABOVE\n\nreturn (\n  <div>\n    <iframe\n      className=\"w-100\"\n      style={{ height: `${state.iframeHeight}px` }}\n      src={externalAppUrl}\n      message={state.currentMessage}\n      onMessage={onMessageHandler}\n    />\n  </div>\n);\n", "metadata": NaN, "branch": NaN, "widget_modules_used": null, "widget_url": "https://near.social/#/wendersonpires.near/widget/NearSocialBridgeCore", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.linktree.website": NaN, "metadata.name": NaN, "metadata.tags.app": NaN, "metadata.tags.bridge": NaN, "metadata.tags.library": NaN, "metadata.tags.react": NaN, "metadata.tags.social": NaN, "branch.draft.": NaN, "branch.draft.metadata": NaN}