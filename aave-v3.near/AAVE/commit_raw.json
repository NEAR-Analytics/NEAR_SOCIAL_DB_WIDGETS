{"tx_hash": "9eRh77fLbwKnPesDJAiKD6s5YhF2rDyacWFvUUdfeKUA", "action_id_social": "2GFn4XoYbyyFL6JYBeg26EmgQTUTwJfdvfnkpX1ztXEu-0-widget", "block_id": 94245520, "block_timestamp": "2023-06-15T14:27:02.197Z", "signer_id": "aave-v3.near", "widget_name": "AAVE", "source_code": "const ROUND_DOWN = 0;\nconst CONTRACT_ABI = {\n  wrappedTokenGatewayV3ABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/WrappedTokenGatewayV3ABI.json\",\n  erc20Abi:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/ERC20Permit.json\",\n  aavePoolV3ABI:\n    \"https://raw.githubusercontent.com/corndao/aave-v3-bos-app/main/abi/AAVEPoolV3.json\",\n};\nconst DEFAULT_CHAIN_ID = 1442;\nconst ETH_TOKEN = { name: \"Ethereum\", symbol: \"ETH\", decimals: 18 };\nconst MATIC_TOKEN = { name: \"Matic\", symbol: \"MATIC\", decimals: 18 };\n\n// Get AAVE network config by chain id\nfunction getNetworkConfig(chainId) {\n  const abis = {\n    wrappedTokenGatewayV3ABI: fetch(CONTRACT_ABI.wrappedTokenGatewayV3ABI),\n    erc20Abi: fetch(CONTRACT_ABI.erc20Abi),\n    aavePoolV3ABI: fetch(CONTRACT_ABI.aavePoolV3ABI),\n  };\n\n  switch (chainId) {\n    case 1: // ethereum mainnet\n      return {\n        chainName: \"Ethereum Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        rpcUrl: \"https://rpc.ankr.com/eth\",\n        aavePoolV3Address: \"0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2\",\n        wrappedTokenGatewayV3Address:\n          \"0xD322A49006FC828F9B5B37Ab215F99B4E5caB19C\",\n        ...abis,\n      };\n    case 42161: // arbitrum one\n      return {\n        chainName: \"Arbitrum Mainnet\",\n        nativeCurrency: ETH_TOKEN,\n        rpcUrl: \"https://arb1.arbitrum.io/rpc\",\n        aavePoolV3Address: \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\",\n        wrappedTokenGatewayV3Address:\n          \"0xB5Ee21786D28c5Ba61661550879475976B707099\",\n        ...abis,\n      };\n    case 137: // polygon mainnet\n      return {\n        chainName: \"Polygon Mainnet\",\n        nativeCurrency: MATIC_TOKEN,\n        rpcUrl: \"https://rpc.ankr.com/polygon\",\n        aavePoolV3Address: \"0x794a61358D6845594F94dc1DB02A252b5b4814aD\",\n        wrappedTokenGatewayV3Address:\n          \"0x1e4b7A6b903680eab0c5dAbcb8fD429cD2a9598c\",\n        ...abis,\n      };\n    case 1442: // zkevm testnet\n      return {\n        chainName: \"Polygon zkEVM Testnet\",\n        nativeCurrency: ETH_TOKEN,\n        rpcUrl: \"https://rpc.public.zkevm-test.net\",\n        aavePoolV3Address: \"0x4412c92f6579D9FC542D108382c8D1d6D2Be63d9\",\n        wrappedTokenGatewayV3Address:\n          \"0xD82940E16D25aB1349914e1C369eF1b287d457BF\",\n        ...abis,\n      };\n    default:\n      throw new Error(\"unknown chain id\");\n  }\n}\n\nfunction switchEthereumChain(chainId) {\n  const chainIdHex = `0x${chainId.toString(16)}`;\n  const res = Ethers.send(\"wallet_switchEthereumChain\", [\n    { chainId: chainIdHex },\n  ]);\n  // If `res` === `undefined`, it means switch chain failed, which is very weird but it works.\n  // If `res` is `null` the function is either not called or executed successfully.\n  if (res === undefined) {\n    console.log(\n      `Failed to switch chain to ${chainId}. Add the chain to wallet`\n    );\n    const config = getNetworkConfig(chainId);\n    Ethers.send(\"wallet_addEthereumChain\", [\n      {\n        chainId: chainIdHex,\n        chainName: config.chainName,\n        nativeCurrency: config.nativeCurrency,\n        rpcUrls: [config.rpcUrl],\n      },\n    ]);\n  }\n}\n\nif (\n  state.chainId === undefined &&\n  ethers !== undefined &&\n  Ethers.send(\"eth_requestAccounts\", [])[0]\n) {\n  Ethers.provider()\n    .getNetwork()\n    .then((data) => {\n      const chainId = data?.chainId;\n      if (chainId && chainId === DEFAULT_CHAIN_ID) {\n        State.update({ chainId });\n      } else {\n        switchEthereumChain(DEFAULT_CHAIN_ID);\n      }\n    });\n}\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\n// interface Market {\n//   id: string,\n//   underlyingAsset: string,\n//   name: string,\n//   symbol: string,\n//   decimals: number,\n// }\n// returns Market[]\nfunction getMarkets(chainId) {\n  return asyncFetch(`https://aave-api.pages.dev/${chainId}/markets`);\n}\n\n/**\n * @param {string} account user address\n * @param {string[]} tokens list of token addresses\n */\n// interface TokenBalance {\n//   token: string,\n//   balance: string,\n//   decimals: number,\n// }\n// returns TokenBalance[]\nfunction getUserBalances(chainId, account, tokens) {\n  const url = `https://aave-api.pages.dev/${chainId}/balances?account=${account}&tokens=${tokens.join(\n    \"|\"\n  )}`;\n  return asyncFetch(url);\n}\n\n// interface UserDeposit {\n//   underlyingAsset: string,\n//   name: string,\n//   symbol: string,\n//   scaledATokenBalance: string,\n//   usageAsCollateralEnabledOnUser: boolean,\n//   underlyingBalance: string,\n//   underlyingBalanceUSD: string,\n// }\n// returns UserDeposit[]\nfunction getUserDeposits(chainId, address) {\n  return asyncFetch(\n    `https://aave-api.pages.dev/${chainId}/deposits/${address}`\n  );\n}\n\n// App config\nfunction getConfig(network) {\n  const chainId = state.chainId;\n  switch (network) {\n    case \"mainnet\":\n      return {\n        ownerId: \"aave-v3.near\",\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        ipfsPrefix: \"https://ipfs.near.social/ipfs\",\n        ...(chainId ? getNetworkConfig(chainId) : {}),\n      };\n    case \"testnet\":\n      return {\n        ownerId: \"aave-v3.testnet\",\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        ipfsPrefix: \"https://ipfs.near.social/ipfs\",\n        ...(chainId ? getNetworkConfig(chainId) : {}),\n      };\n    default:\n      throw Error(`Unconfigured environment '${network}'.`);\n  }\n}\nconst config = getConfig(context.networkId);\n\n// App states\nState.init({\n  imports: {},\n  chainId: undefined,\n  showWithdrawModal: false,\n  showSupplyModal: false,\n  walletConnected: false,\n  assetsToSupply: undefined,\n  yourSupplies: undefined,\n  address: undefined,\n  ethBalance: undefined,\n});\n\nconst loading = !state.assetsToSupply || !state.yourSupplies;\n\n// Import functions to state.imports\nfunction importFunctions(imports) {\n  if (loading) {\n    State.update({\n      imports,\n    });\n  }\n}\n\n// Define the modules you'd like to import\nconst modules = {\n  number: `${config.ownerId}/widget/Utils.Number`,\n  date: `${config.ownerId}/widget/Utils.Date`,\n  data: `${config.ownerId}/widget/AAVE.Data`,\n};\n// Import functions\n// const { formatAmount } = state.imports.number;\n// const { formatDateTime } = state.imports.date;\n\nfunction checkProvider() {\n  const provider = Ethers.provider();\n  if (provider) {\n    State.update({ walletConnected: true });\n  } else {\n    State.update({ walletConnected: false });\n  }\n}\n\n// update data in async manner\nfunction updateData() {\n  const provider = Ethers.provider();\n  if (!provider) {\n    return;\n  }\n  provider\n    .getSigner()\n    ?.getAddress()\n    ?.then((address) => {\n      State.update({ address });\n    });\n  provider\n    .getSigner()\n    ?.getBalance()\n    .then((balance) => State.update({ ethBalance: balance }));\n  if (!state.address || !state.ethBalance) {\n    return;\n  }\n\n  const prevYourSupplies = state.yourSupplies;\n\n  getMarkets(state.chainId).then((marketsResponse) => {\n    if (!marketsResponse) {\n      return;\n    }\n    const markets = JSON.parse(marketsResponse.body);\n\n    // get user balances\n    getUserBalances(\n      state.chainId,\n      state.address,\n      markets.map((market) => market.underlyingAsset)\n    ).then((userBalancesResponse) => {\n      if (!userBalancesResponse) {\n        return;\n      }\n      const userBalances = JSON.parse(userBalancesResponse.body);\n      const assetsToSupply = markets.map((market, idx) => {\n        if (!isValid(userBalances[idx].decimals)) {\n          return;\n        }\n        const balanceRaw = Big(\n          market.symbol === \"WETH\"\n            ? state.ethBalance\n            : userBalances[idx].balance\n        ).div(Big(10).pow(userBalances[idx].decimals));\n        const balance = balanceRaw.toFixed(7, ROUND_DOWN);\n        const balanceInUSD = balanceRaw\n          .mul(market.marketReferencePriceInUsd)\n          .toFixed(3, ROUND_DOWN);\n        return {\n          ...userBalances[idx],\n          ...market,\n          balance,\n          balanceInUSD,\n          ...(market.symbol === \"WETH\"\n            ? {\n                symbol: \"ETH\",\n                name: \"Ethereum\",\n              }\n            : {}),\n        };\n      });\n\n      State.update({\n        assetsToSupply,\n      });\n    });\n\n    // get user supplies\n    getUserDeposits(state.chainId, state.address).then(\n      (userDepositsResponse) => {\n        if (!userDepositsResponse) {\n          return;\n        }\n        const userDeposits = JSON.parse(userDepositsResponse.body).filter(\n          (row) => Number(row.underlyingBalance) !== 0\n        );\n        const marketsMapping = markets.reduce((prev, cur) => {\n          prev[cur.symbol] = cur;\n          return prev;\n        }, {});\n        const yourSupplies = userDeposits.map((userDeposit) => {\n          const market = marketsMapping[userDeposit.symbol];\n          return {\n            ...market,\n            ...userDeposit,\n            ...(market.symbol === \"WETH\"\n              ? {\n                  symbol: \"ETH\",\n                  name: \"Ethereum\",\n                }\n              : {}),\n          };\n        });\n\n        State.update({\n          yourSupplies,\n        });\n\n        if (JSON.stringify(prevYourSupplies) === JSON.stringify(yourSupplies)) {\n          console.log(\"refresh again ...\", prevYourSupplies, yourSupplies);\n          setTimeout(updateData, 500);\n        }\n      }\n    );\n  });\n}\n\nfunction onActionSuccess({ msg, callback }) {\n  // update data if action finishes\n  updateData();\n  // update UI after data has almost loaded\n  setTimeout(() => {\n    if (callback) {\n      callback();\n    }\n    if (msg) {\n      State.update({ alertModalText: msg });\n    }\n  }, 5000);\n}\n\ncheckProvider();\nif (state.walletConnected && state.chainId && loading) {\n  updateData();\n}\n\nconst Body = styled.div`\n  padding: 24px 15px;\n  background: #0e0e26;\n  min-height: 100vh;\n  color: white;\n`;\n\nconst FlexContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n`;\n// Component body\nconst body = loading ? (\n  <>\n    <Widget src={`${config.ownerId}/widget/AAVE.Header`} props={{ config }} />\n    <Body>\n      {state.walletConnected\n        ? state.chainId === DEFAULT_CHAIN_ID\n          ? \"Loading...\"\n          : `Please switch network to ${\n              getNetworkConfig(DEFAULT_CHAIN_ID).chainName\n            }`\n        : \"Need to connect wallet first.\"}\n    </Body>\n  </>\n) : (\n  <>\n    <Widget src={`${config.ownerId}/widget/AAVE.Header`} props={{ config }} />\n    <Body>\n      <FlexContainer>\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.NetworkSwitcher`}\n          props={{\n            chainId: state.chainId,\n            config,\n            switchNetwork: (chainId) => {\n              switchEthereumChain(chainId);\n            },\n            disabled: true,\n          }}\n        />\n      </FlexContainer>\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.TabSwitcher`}\n        props={{ config }}\n      />\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Card.YourSupplies`}\n        props={{\n          config,\n          yourSupplies: state.yourSupplies,\n          showWithdrawModal: state.showWithdrawModal,\n          setShowWithdrawModal: (isShow) =>\n            State.update({ showWithdrawModal: isShow }),\n          onActionSuccess,\n        }}\n      />\n      <Widget\n        src={`${config.ownerId}/widget/AAVE.Card.AssetsToSupply`}\n        props={{\n          config,\n          chainId: state.chainId,\n          assetsToSupply: state.assetsToSupply,\n          showSupplyModal: state.showSupplyModal,\n          setShowSupplyModal: (isShow) =>\n            State.update({ showSupplyModal: isShow }),\n          onActionSuccess,\n        }}\n      />\n      {state.alertModalText && (\n        <Widget\n          src={`${config.ownerId}/widget/AAVE.Modal.AlertModal`}\n          props={{\n            config,\n            title: \"All done!\",\n            description: state.alertModalText,\n            onRequestClose: () => State.update({ alertModalText: false }),\n          }}\n        />\n      )}\n    </Body>\n  </>\n);\n\nreturn (\n  <div>\n    {/* Component Head */}\n    <Widget\n      src={`${config.ownerId}/widget/Utils.Import`}\n      props={{ modules, onLoad: importFunctions }}\n    />\n    {/* Component Body */}\n    {body}\n  </div>\n);\n", "metadata": {"description": "Aave - Open Source Liquidity Protocol", "image": {"ipfs_cid": "bafkreicmsnivbvp2xd3ewcjb5kybgnbnevbcojhn4mgub7rregnbtqcige"}, "name": "AAVE v3", "tags": {"app": "", "defi": "", "eth": "", "lending": ""}}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/aave-v3.near/widget/AAVE", "__row_index": 1}