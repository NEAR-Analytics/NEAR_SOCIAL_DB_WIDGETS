{"tx_hash": "2wHRDs93uGj857qkZ3PSLkWgcdmRU52dBM7oGX4nYPLw", "action_id_social": "H9P7cfVWP7dsAtvVquzWfNeLKF4PgiNLEVeiz6EviS5z-0-widget", "block_id": 91212576, "block_timestamp": "2023-05-06T07:28:06.734Z", "signer_id": "chanon.near", "widget_name": "1inch", "source_code": "// TODO ::\n// - handle error pop up if an 1inch check allowance api does not work properly\n// - handle and display 1inch mutiple chain support not just only bsc\n// - Multiple Token Selection\n// - Max(helper button) to get max amount of token from wallet address\n// - error when user select from / to as same token\n// - error when user don't select destination token\n// - change allow token behavior to replace swap butto\n// - might add revork button\n\ninitState({\n  toggleAmount: false,\n  txHash: \"\",\n  tokenDecimals: 18,\n  fromTokenAmount: 0,\n});\n\nconst signer = Ethers.send(\"eth_requestAccounts\", [])[0];\n\nif (!signer) {\n  return (\n    <div>\n      <h3>Please connect your wallet</h3>\n      <Web3Connect />\n    </div>\n  );\n}\n\nif (\n  state.chainId === undefined &&\n  ethers !== undefined &&\n  Ethers.send(\"eth_requestAccounts\", [])[0]\n) {\n  Ethers.provider()\n    .getNetwork()\n    .then((chainIdData) => {\n      if (chainIdData?.chainId) {\n        State.update({ chainId: chainIdData.chainId });\n      }\n    });\n}\n\nif (state.chainId !== 56) {\n  return (\n    <div>\n      <h3>\n        Wrong Network - We only support the Binance Smart Chain mainnet at this\n        time.\n      </h3>\n    </div>\n  );\n}\n\nconst setToken = (token) => {\n  State.update({ token });\n  checkAllowance(token);\n};\n\nconst setDestinationToken = (destinationToken) => {\n  State.update({ destinationToken });\n};\n\nfunction checkAllowance(token) {\n  asyncFetch(\n    \"https://api.1inch.io/v5.0/\" +\n      state.chainId +\n      \"/approve/allowance?tokenAddress=\" +\n      token +\n      \"&walletAddress=\" +\n      signer\n  ).then((res) => {\n    console.log(res);\n    if (res.status === 200) {\n      {\n        res.body.allowance > 0\n          ? State.update({ toggleAmount: true })\n          : State.update({ toggleAmount: false });\n      }\n    } // TODO :: need to handle error ?\n  });\n}\n\nconst tokens = {\n  \"Select Token\": \"\",\n  USDT: \"0x55d398326f99059fF775485246999027B3197955\",\n  BUSD: \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\",\n};\n\nconst tokensMenuItems = Object.keys(tokens).map((token) => (\n  <option value={tokens[token]}>{token}</option>\n));\n\nconst BUSD = \"0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\";\nconst USDT = \"0x55d398326f99059fF775485246999027B3197955\";\nconst ROUTER = \"0x1111111254eeb25477b68fb85ed929f73a960582\";\n\nconst MAX_AMOUNT =\n  \"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n\nconst MIN_AMOUNT =\n  \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\nconst erc20Abi = fetch(\n  \"https://gist.githubusercontent.com/veox/8800debbf56e24718f9f483e1e40c35c/raw/f853187315486225002ba56e5283c1dba0556e6f/erc20.abi.json\"\n);\nif (!erc20Abi.ok) {\n  return \"erc20 not ok\";\n}\n\nconst iface = new ethers.utils.Interface(erc20Abi.body);\n\nconst getTokenBalance = (wallet) => {\n  const encodedData = iface.encodeFunctionData(\"balanceOf\", [wallet]);\n\n  return Ethers.provider()\n    .call({\n      to: state.token,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(state.tokenDecimals))\n        .toFixed(2)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\n\nconst oneInchAbi = fetch(\n  \"https://gist.githubusercontent.com/taforyou/5747abd24159d5fd4e95cf1820d5d90f/raw/ca965bdfa9a291d2e0e8617f9f6b53d132baa0c6/1inchv5.abi.json\"\n);\nif (!oneInchAbi.ok) {\n  return \"1inch not ok\";\n}\n\nconst apiBaseUrl = \"https://api.1inch.io/v5.0/\" + state.chainId;\n\nfunction apiRequestUrl(methodName, queryParams) {\n  return apiBaseUrl + methodName + \"?\" + buildSearchParams(queryParams);\n}\n\nfunction buildSearchParams(params) {\n  var ss = [];\n  for (const [key, value] of Object.entries(params)) {\n    ss.push(`${key}=${value}`);\n  }\n  return ss.join(\"&\");\n}\n\nconst handleApprove = () => {\n  const approveToken = new ethers.Contract(\n    state.token,\n    erc20Abi.body,\n    Ethers.provider().getSigner()\n  );\n\n  approveToken.approve(ROUTER, MAX_AMOUNT).then((tx) => {\n    State.update({ txHash: \"https://bscscan.com/tx/\" + tx.hash });\n    // console.log({\n    //   log: \"The TX hash is: \" + tx.hash,\n    //   explorerLink: \"https://bscscan.com/tx/\" + tx.hash,\n    // });\n  });\n};\n\nconst handleSwap = () => {\n  //   console.log(\"fromTokenAddress \", state.token);\n  //   console.log(\"destinationToken \", state.destinationToken);\n  // getTokenBalance(signer).then((value) => {\n  //   console.log(value);\n  // });\n\n  let swapAmount = ethers.utils.parseUnits(\n    state.fromTokenAmount,\n    state.tokenDecimals\n  );\n\n  const swapParam = {\n    fromTokenAddress: state.token,\n    toTokenAddress: state.destinationToken,\n    amount: swapAmount,\n    fromAddress: signer,\n    slippage: 1,\n  };\n  asyncFetch(apiRequestUrl(\"/swap\", swapParam)).then(({ ok, body }) => {\n    if (!ok) {\n      return;\n    }\n\n    const ifaceOneInch = new ethers.utils.Interface(oneInchAbi.body);\n    const r = ifaceOneInch.decodeFunctionData(\"swap\", body.tx.data);\n    const oneInch = new ethers.Contract(\n      ROUTER,\n      oneInchAbi.body,\n      Ethers.provider().getSigner()\n    );\n\n    // Function: swap(address executor,tuple desc,bytes permit,bytes data)\n    oneInch.swap(r.executor, r.desc, r.permit, r.data).then((x) => {\n      //   console.log(x.hash);\n      State.update({ txHash: \"https://bscscan.com/tx/\" + x.hash });\n    });\n  });\n};\n\nreturn (\n  <div>\n    <h3>Swap BEP-20 tokens via 1inch V.5</h3>\n    <div class=\"mb-3\">\n      <label for=\"selectToken\">From token</label>\n      <select\n        class=\"form-select\"\n        id=\"selectToken\"\n        onChange={(e) => {\n          setToken(e.target.value);\n        }}\n      >\n        {tokensMenuItems}\n      </select>\n    </div>\n\n    {state.toggleAmount ? (\n      <input\n        value={state.fromTokenAmount}\n        onChange={(e) => State.update({ fromTokenAmount: e.target.value })}\n        placeholder=\"Amount\"\n      />\n    ) : (\n      <button\n        class=\"btn btn-success\"\n        onClick={handleApprove}\n        disabled={state.token ? false : true}\n      >\n        Please allow the use of a 1-inch router for the swap.\n      </button>\n    )}\n    <div class=\"mb-3\">\n      <label for=\"selectToken\">To token</label>\n      <select\n        class=\"form-select\"\n        id=\"selectToken\"\n        onChange={(e) => {\n          setDestinationToken(e.target.value);\n        }}\n      >\n        {tokensMenuItems}\n      </select>\n    </div>\n    <button class=\"btn btn-success\" onClick={handleSwap} disabled={false}>\n      Swap\n    </button>\n    <div>tx explorer : {state.txHash}</div>\n  </div>\n);\n", "metadata": {"linktree": {"website": "killswitch.finance"}, "name": "1inch BOS Component", "tags": {"scb10xblockathon": ""}}, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chanon.near/widget/1inch", "__row_index": 2}