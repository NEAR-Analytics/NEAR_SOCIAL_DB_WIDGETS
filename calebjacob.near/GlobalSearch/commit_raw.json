{"tx_hash": "3MCQqtZrHELFeFUDECpRczqULuFtCfqf8AqJFdswEpSY", "action_id_social": "HkU3fq9Dvra2enmBcFyFfauv3zSACMiH77PabtqzM38R-0-widget", "block_id": 85962633, "block_timestamp": "2023-02-24 20:13:34.548", "signer_id": "calebjacob.near", "widget_name": "GlobalSearch", "source_code": "const profiles =\n  Social.get([\"*/profile/name\", \"*/profile/tags/*\"], \"final\") || {};\n\nconst componentMetadata =\n  Social.get(\n    [\"*/widget/*/metadata/name\", \"*/widget/*/metadata/tags/*\"],\n    \"final\"\n  ) || {};\n\nconst componentKeys =\n  Social.keys([\"*/widget/*\"], \"final\", { values_only: true }) || {};\n\nconst boostedComponentTag = props.boostedComponentTag || \"app\";\nconst requiredComponentTag = props.requiredComponentTag || null;\nconst limitPerGroup = props.limitPerGroup || 5;\n\nconst computeResults = (term) => {\n  const terms = (term || \"\")\n    .toLowerCase()\n    .split(/[^\\w._-]/)\n    .filter((s) => !!s.trim());\n\n  const result = {\n    components: computeComponents(terms),\n    people: computePeople(terms),\n  };\n\n  State.update({\n    term,\n    result,\n  });\n\n  if (props.onChange) {\n    props.onChange({ term, result });\n  }\n};\n\nconst computeComponents = (terms) => {\n  const results = [];\n  const MaxSingleScore = 1;\n  const MaxScore = MaxSingleScore * 4;\n\n  const computeScore = (s) => {\n    s = s.toLowerCase();\n    return (\n      terms\n        .map((term) => {\n          const pos = s.indexOf(term);\n          return pos >= 0 ? Math.exp(-pos) : 0;\n        })\n        .reduce((s, v) => s + v, 0) / terms.length\n    );\n  };\n\n  Object.entries(componentKeys).forEach(([accountId, data]) => {\n    Object.keys(data.widget).forEach((componentId) => {\n      const widgetSrc = `${accountId}/widget/${componentId}`;\n      const widgetSrcScore = computeScore(widgetSrc);\n      const componentIdScore = computeScore(componentId);\n      const metadata =\n        componentMetadata[accountId].widget[componentId].metadata;\n      const name = metadata.name || componentId;\n\n      if (\n        requiredComponentTag &&\n        !(metadata.tags && requiredComponentTag in metadata.tags)\n      ) {\n        return;\n      }\n\n      const boosted =\n        boostedComponentTag &&\n        metadata.tags &&\n        boostedComponentTag in metadata.tags;\n      const tags = Object.keys(metadata.tags || {}).slice(0, 10);\n      const nameScore = computeScore(name);\n      const tagsScore = Math.min(\n        MaxSingleScore,\n        tags.map(computeScore).reduce((s, v) => s + v, 0)\n      );\n      const score =\n        (widgetSrcScore + componentIdScore + nameScore + tagsScore) / MaxScore;\n\n      if (score > 0) {\n        results.push({\n          score,\n          accountId,\n          widgetName: componentId,\n          widgetSrc,\n          name,\n          tags,\n          boosted,\n        });\n      }\n    });\n  });\n\n  results.sort(\n    (a, b) => (b.boosted ? 2 : 0) + b.score - (a.boosted ? 2 : 0) - a.score\n  );\n\n  return results.slice(0, limitPerGroup);\n};\n\nconst computePeople = (terms) => {\n  const results = [];\n  const MaxSingleScore = 20;\n  const MaxScore = MaxSingleScore * 3;\n\n  const computeScore = (s) => {\n    s = s.toLowerCase();\n    return (\n      terms\n        .map((term) => {\n          const pos = s.indexOf(term);\n          return pos >= 0 ? Math.max(1, 20 - pos) : 0;\n        })\n        .reduce((s, v) => s + v, 0) / terms.length\n    );\n  };\n\n  Object.entries(profiles).forEach(([accountId, data]) => {\n    const accountIdScore = computeScore(accountId);\n    const name = data.profile.name || \"\";\n    const tags = Object.keys(data.profile.tags || {}).slice(0, 10);\n    const nameScore = computeScore(name);\n    const tagsScore = Math.min(\n      20,\n      tags.map(computeScore).reduce((s, v) => s + v, 0)\n    );\n    const score = (accountIdScore + nameScore + tagsScore) / MaxScore;\n    if (score > 0) {\n      results.push({ score, accountId, name, tags });\n    }\n  });\n\n  results.sort((a, b) => b.score - a.score);\n\n  return results.slice(0, limitPerGroup);\n};\n\nif (props.term && props.term !== state.lastSyncedTermProp) {\n  State.update({\n    term: props.term,\n    lastSyncedTermProp: props.term,\n  });\n  computeResults(props.term);\n}\n\nif (profiles && componentMetadata && componentKeys) {\n  computeResults(state.term);\n}\n\nconst Wrapper = styled.div`\n  width: 100%;\n  height: 40px;\n  position: relative;\n\n  .bi-search {\n      position: absolute;\n      top: 0;\n      left: 18px;\n      z-index: 100;\n      font-size: 14px;\n      line-height: 40px;\n      color: #687076;\n  }\n\n  .input-group {\n      height: 100%;\n  }\n\n  input {\n      padding: 0 14px 0 42px;\n      border: 1px solid #D0D5DD !important;\n      background: #FFFFFF;\n      border-radius: 100px;\n  }\n\n  button {\n      border-color: #D0D5DD !important;\n      border-radius: 0 100px 100px 0 !important;\n      border-left: none !important;\n      background: #fff !important;\n      color: #687076 !important;\n\n      &:hover, &:focus {\n          color: #000 !important;\n      }\n  }\n\n  @media (max-width: 500px) {\n      width: 100%;\n  }\n`;\n\nreturn (\n  <Wrapper>\n    <i className=\"bi bi-search\"></i>\n    <div className=\"input-group\">\n      <input\n        type=\"text\"\n        className={`form-control ${state.term ? \"border-end-0\" : \"\"}`}\n        value={state.term ?? \"\"}\n        onChange={(e) => computeResults(e.target.value)}\n        placeholder={props.placeholder ?? `Search`}\n      />\n\n      {state.term && (\n        <button\n          className=\"btn btn-outline-secondary border border-start-0\"\n          type=\"button\"\n          onClick={() => computeResults(\"\")}\n        >\n          <i className=\"bi bi-x\"></i>\n        </button>\n      )}\n    </div>\n\n    {props.debug && <pre>{JSON.stringify(state.result, undefined, 2)}</pre>}\n  </Wrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/calebjacob.near/widget/GlobalSearch"}