{"tx_hash": "4zu8RcmmTUHn1qcz1FtvVPbGd133ThFZrhid11h1XYb", "action_id_social": "6MGTjmefJ9d6EJQuk1JVeEfurivgJ6UzTxYB4tvShn9y-0-widget", "block_id": 94757417, "block_timestamp": "2023-06-22T09:30:50.982Z", "signer_id": "chess-game.near", "widget_name": "ChessGameReplay", "source_code": "const { game_id } = props;\nconst playerWhiteId = game_id[1];\nconst playerBlackId = game_id[2];\nconst gameIdStr = JSON.stringify(game_id);\nconst contractId = \"app.chess-game.near\";\nconst chessBoardWidget = \"chess-game.near/widget/ChessBoard\";\nconst loadingWidget = \"chess-game.near/widget/ChessGameLoading\";\nconst waitTime = 50;\nconst waitTimeOnErr = 500;\n\nif (!playerWhiteId) {\n  return \"Malformed game_id prop!\";\n}\n\nconst BoardView = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  max-width: 100vw;\n`;\n\nconst fetchOptions = {\n  headers: {\n    \"x-api-key\": \"36f2b87a-7ee6-40d8-80b9-5e68e587a5b5\",\n  },\n};\n\nlet transactions = [...(state?.transactions ?? [])];\nif (!state.transactions) {\n  let offset = 0;\n  while (true) {\n    const res = fetch(\n      `https://api.pikespeak.ai/event-historic/${contractId}?offset=${offset}&contractFilter=${playerWhiteId}&filters=FUNCTION_CALL`,\n      fetchOptions\n    );\n    offset += 50;\n    if (!res.ok) {\n      return `Pikespeak API returned error: ${JSON.stringify(res)}`;\n    }\n\n    if (res.body.length === 0) break;\n    transactions = transactions.concat(res.body);\n    if (res.body.length < 50) break;\n  }\n  if (playerBlackId != null) {\n    offset = 0;\n    while (true) {\n      const res = fetch(\n        `https://api.pikespeak.ai/event-historic/${contractId}?offset=${offset}&contractFilter=${playerBlackId}&filters=FUNCTION_CALL`,\n        fetchOptions\n      );\n      offset += 50;\n      if (!res.ok) {\n        return `Pikespeak API returned error: ${JSON.stringify(res)}`;\n      }\n\n      if (res.body.length === 0) break;\n      transactions = transactions.concat(res.body);\n      if (res.body.length < 50) break;\n    }\n    transactions = transactions.sort(\n      (a, b) => Number(b.timestamp) - Number(a.timestamp)\n    );\n  }\n}\n\nlet events = [...(state?.events ?? [])];\nState.init({\n  transactions: [...transactions],\n  events: [...events],\n  tabIndex: 0,\n  errCount: state?.errCount ?? 0,\n});\n\nif (transactions.length > 0) {\n  const tx = transactions.pop();\n\n  asyncFetch(\n    `https://api.pikespeak.ai/tx/graph-by-hash/${tx.transaction_id}`,\n    fetchOptions\n  ).then(({ ok, body }) => {\n    if (!ok) {\n      setTimeout(() => {\n        State.update({\n          errCount: state.errCount + 1,\n        });\n      }, waitTimeOnErr);\n      return;\n    }\n    const { logs } = body[0].transaction_graph.eoNode.childs[0].content;\n    const newEvents = logs\n      .filter((log) => log.startsWith(\"EVENT_JSON:\"))\n      .map((log) => JSON.parse(log.substr(11)))\n      .filter(({ data }) => JSON.stringify(data.game_id) == gameIdStr);\n    if (newEvents.length > 0) {\n      State.update({\n        transactions,\n        events: events.concat(newEvents),\n      });\n      return;\n    }\n\n    setTimeout(() => {\n      State.update({\n        transactions,\n      });\n    }, waitTime);\n  });\n  return (\n    <Widget\n      src={loadingWidget}\n      props={{\n        content: (\n          <div>Scanning transactions. Remaining: {transactions.length}</div>\n        ),\n      }}\n    />\n  );\n}\n\nconst GameInfo = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  font-size: 1.4rem;\n  margin: 1rem 0.3rem;\n  width: 350px;\n  max-width: calc(100% - 0.6rem);\n`;\nconst Button = styled.button`\n  display: flex;\n  flex-direction: column;\n  border: 1px solid black;\n  border-radius: 4px;\n  visibility: ${(props) => (props.invisible ? \"hidden\" : \"visible\")};\n`;\nconst ButtonWrapper = styled.div`\n  display: flex;\n  justify-content: space-around;\n`;\nconst HorizontalLine = styled.div`\n  width: 100%;\n  border: 1px solid black;\n  margin: 1rem 0;\n`;\nconst Move = styled.div`\n  text-align: center;\n  visibility: ${(props) => (props.invisible ? \"hidden\" : \"visible\")};\n`;\nconst Outcome = styled.div`\n  display: flex;\n  justify-content: center;\n  margin-top: 1rem;\n  font-weight: 600;\n  font-size: 1.8rem;\n  visibility: ${(props) => (props.invisible ? \"hidden\" : \"visible\")};\n`;\n\nconst renderPlayer = (color, player) => {\n  if (player.Human) {\n    return (\n      <div>\n        Player {color}: {player.Human}\n      </div>\n    );\n  } else if (player.Ai) {\n    return (\n      <div>\n        Player {color}: AI ({player.Ai})\n      </div>\n    );\n  } else {\n    const err = new Error(`Unable to render player: ${player}`);\n    console.error(err);\n    return \"\";\n  }\n};\nconst renderMove = (move, label) => (\n  <Move invisible={!move?.mv}>\n    {label}: {move?.mv && move.color + \" \" + move.mv}\n  </Move>\n);\nconst renderOutcome = (outcome) => (\n  <Outcome invisible={!outcome}>\n    {outcome\n      ? outcome.Victory\n        ? `Victory: ${outcome.Victory}`\n        : outcome\n      : \"placeholder\"}\n  </Outcome>\n);\nconst setTabIndex = (index) => () => {\n  State.update({\n    tabIndex: index,\n  });\n};\n\nconst prevMove = state.events[state.tabIndex - 1]?.data;\nconst nextMove = state.events[state.tabIndex + 1]?.data;\nconst isPvP = state.events[0]?.event === \"accept_challenge\";\nif (isPvP && state.tabIndex === 0) {\n  State.update({\n    tabIndex: 1,\n  });\n  return \"\";\n}\nconst boardState = state.events[state.tabIndex].data;\nif (!boardState.board) {\n  return (\n    <BoardView>\n      Unable to render board. It looks like this game has been created with an\n      older version of the contract and it's incompatible with replay rendering.\n    </BoardView>\n  );\n}\n\nreturn (\n  <BoardView>\n    <GameInfo>\n      <div>ID: {game_id[0]}</div>\n      {renderPlayer(\"White\", state.events[isPvP ? 1 : 0].data.white)}\n      {renderPlayer(\"Black\", state.events[isPvP ? 1 : 0].data.black)}\n    </GameInfo>\n    <HorizontalLine />\n    <GameInfo>\n      {renderMove(prevMove, \"Previous Move\")}\n      {renderMove(nextMove, \"Next Move\")}\n      <ButtonWrapper>\n        <Button\n          invisible={!prevMove?.mv}\n          onClick={setTabIndex(state.tabIndex - 2)}\n        >\n          \u21e6\n        </Button>\n        <Button\n          invisible={!nextMove?.mv}\n          onClick={setTabIndex(state.tabIndex + 2)}\n        >\n          \u21e8\n        </Button>\n      </ButtonWrapper>\n      {renderOutcome(boardState.outcome)}\n    </GameInfo>\n    <Widget src={chessBoardWidget} props={{ board: boardState.board }} />\n  </BoardView>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chess-game.near/widget/ChessGameReplay", "__row_index": 1}