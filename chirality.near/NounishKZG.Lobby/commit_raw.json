{"tx_hash": "9BgNo8gp8BjnwGBpTW38Uo9a7aPkNxnb19XLJGnyRWuF", "action_id_social": "7QbbZqCUGCUobYA5wXNUzNfM3H4B2ySfGJmiLRe9V1A4-0-widget", "block_id": 95013159, "block_timestamp": "2023-06-25T17:31:35.687Z", "signer_id": "chirality.near", "widget_name": "NounishKZG.Lobby", "source_code": "const code = `\n<script>\nvar exports = {};\nvar nobleCurves = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n  // input.js\n  var input_exports = {};\n  __export(input_exports, {\n    bls12_381: () => bls12_381,\n    ed25519: () => ed25519,\n    ed448: () => ed448,\n    p256: () => p256,\n    p384: () => p384,\n    p521: () => p521,\n    secp256k1: () => secp256k1,\n    utils: () => utils,\n    x25519: () => x25519,\n    x448: () => x448\n  });\n\n  // ../esm/abstract/utils.js\n  var utils_exports = {};\n  __export(utils_exports, {\n    bitGet: () => bitGet,\n    bitLen: () => bitLen,\n    bitMask: () => bitMask,\n    bitSet: () => bitSet,\n    bytesToHex: () => bytesToHex,\n    bytesToNumberBE: () => bytesToNumberBE,\n    bytesToNumberLE: () => bytesToNumberLE,\n    concatBytes: () => concatBytes,\n    createHmacDrbg: () => createHmacDrbg,\n    ensureBytes: () => ensureBytes,\n    equalBytes: () => equalBytes,\n    hexToBytes: () => hexToBytes,\n    hexToNumber: () => hexToNumber,\n    numberToBytesBE: () => numberToBytesBE,\n    numberToBytesLE: () => numberToBytesLE,\n    numberToHexUnpadded: () => numberToHexUnpadded,\n    numberToVarBytesBE: () => numberToVarBytesBE,\n    utf8ToBytes: () => utf8ToBytes,\n    validateObject: () => validateObject\n  });\n  var _0n = BigInt(0);\n  var _1n = BigInt(1);\n  var _2n = BigInt(2);\n  var u8a = (a) => a instanceof Uint8Array;\n  var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, \"0\"));\n  function bytesToHex(bytes2) {\n    if (!u8a(bytes2))\n      throw new Error(\"Uint8Array expected\");\n    let hex = \"\";\n    for (let i = 0; i < bytes2.length; i++) {\n      hex += hexes[bytes2[i]];\n    }\n    return hex;\n  }\n  function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \\`0\\${hex}\\` : hex;\n  }\n  function hexToNumber(hex) {\n    if (typeof hex !== \"string\")\n      throw new Error(\"hex string expected, got \" + typeof hex);\n    return BigInt(hex === \"\" ? \"0\" : \\`0x\\${hex}\\`);\n  }\n  function hexToBytes(hex) {\n    if (typeof hex !== \"string\")\n      throw new Error(\"hex string expected, got \" + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n      throw new Error(\"padded hex string expected, got unpadded hex of length \" + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n      const j = i * 2;\n      const hexByte = hex.slice(j, j + 2);\n      const byte = Number.parseInt(hexByte, 16);\n      if (Number.isNaN(byte) || byte < 0)\n        throw new Error(\"Invalid byte sequence\");\n      array[i] = byte;\n    }\n    return array;\n  }\n  function bytesToNumberBE(bytes2) {\n    return hexToNumber(bytesToHex(bytes2));\n  }\n  function bytesToNumberLE(bytes2) {\n    if (!u8a(bytes2))\n      throw new Error(\"Uint8Array expected\");\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));\n  }\n  function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n  }\n  function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n  }\n  function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n  }\n  function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n      try {\n        res = hexToBytes(hex);\n      } catch (e) {\n        throw new Error(\\`\\${title} must be valid hex string, got \"\\${hex}\". Cause: \\${e}\\`);\n      }\n    } else if (u8a(hex)) {\n      res = Uint8Array.from(hex);\n    } else {\n      throw new Error(\\`\\${title} must be hex string or Uint8Array\\`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength)\n      throw new Error(\\`\\${title} expected \\${expectedLength} bytes, got \\${len}\\`);\n    return res;\n  }\n  function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0;\n    arrays.forEach((a) => {\n      if (!u8a(a))\n        throw new Error(\"Uint8Array expected\");\n      r.set(a, pad);\n      pad += a.length;\n    });\n    return r;\n  }\n  function equalBytes(b1, b2) {\n    if (b1.length !== b2.length)\n      return false;\n    for (let i = 0; i < b1.length; i++)\n      if (b1[i] !== b2[i])\n        return false;\n    return true;\n  }\n  function utf8ToBytes(str) {\n    if (typeof str !== \"string\")\n      throw new Error(\\`utf8ToBytes expected string, got \\${typeof str}\\`);\n    return new Uint8Array(new TextEncoder().encode(str));\n  }\n  function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n      ;\n    return len;\n  }\n  function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n  }\n  var bitSet = (n, pos, value) => {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n  };\n  var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n  var u8n = (data) => new Uint8Array(data);\n  var u8fr = (arr) => Uint8Array.from(arr);\n  function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2)\n      throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2)\n      throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\")\n      throw new Error(\"hmacFn must be a function\");\n    let v = u8n(hashLen);\n    let k = u8n(hashLen);\n    let i = 0;\n    const reset = () => {\n      v.fill(1);\n      k.fill(0);\n      i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b);\n    const reseed = (seed = u8n()) => {\n      k = h(u8fr([0]), seed);\n      v = h();\n      if (seed.length === 0)\n        return;\n      k = h(u8fr([1]), seed);\n      v = h();\n    };\n    const gen2 = () => {\n      if (i++ >= 1e3)\n        throw new Error(\"drbg: tried 1000 values\");\n      let len = 0;\n      const out = [];\n      while (len < qByteLen) {\n        v = h();\n        const sl = v.slice();\n        out.push(sl);\n        len += v.length;\n      }\n      return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n      reset();\n      reseed(seed);\n      let res = void 0;\n      while (!(res = pred(gen2())))\n        reseed();\n      reset();\n      return res;\n    };\n    return genUntil;\n  }\n  var validatorFns = {\n    bigint: (val) => typeof val === \"bigint\",\n    function: (val) => typeof val === \"function\",\n    boolean: (val) => typeof val === \"boolean\",\n    string: (val) => typeof val === \"string\",\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n  };\n  function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n      const checkVal = validatorFns[type];\n      if (typeof checkVal !== \"function\")\n        throw new Error(\\`Invalid validator \"\\${type}\", expected function\\`);\n      const val = object[fieldName];\n      if (isOptional && val === void 0)\n        return;\n      if (!checkVal(val, object)) {\n        throw new Error(\\`Invalid param \\${String(\n          fieldName\n        )}=\\${val} (\\${typeof val}), expected \\${type}\\`);\n      }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n      checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n      checkField(fieldName, type, true);\n    return object;\n  }\n\n  // ../node_modules/@noble/hashes/esm/_assert.js\n  function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n      throw new Error(\\`Wrong positive integer: \\${n}\\`);\n  }\n  function bool(b) {\n    if (typeof b !== \"boolean\")\n      throw new Error(\\`Expected boolean, not \\${b}\\`);\n  }\n  function bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n      throw new Error(\"Expected Uint8Array\");\n    if (lengths.length > 0 && !lengths.includes(b.length))\n      throw new Error(\\`Expected Uint8Array of length \\${lengths}, not of length=\\${\n  b.length\n}\\`);\n  }\n  function hash(hash2) {\n    if (typeof hash2 !== \"function\" || typeof hash2.create !== \"function\")\n      throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    number(hash2.outputLen);\n    number(hash2.blockLen);\n  }\n  function exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n      throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished)\n      throw new Error(\"Hash#digest() has already been called\");\n  }\n  function output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n      throw new Error(\\`digestInto() expects output buffer of length at least \\${min}\\`);\n    }\n  }\n  var assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output\n  };\n  var assert_default = assert;\n\n  // ../node_modules/@noble/hashes/esm/crypto.js\n  var crypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n\n  // ../node_modules/@noble/hashes/esm/utils.js\n  var u8a2 = (a) => a instanceof Uint8Array;\n  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  var rotr = (word, shift) => word << 32 - shift | word >>> shift;\n  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\n  if (!isLE)\n    throw new Error(\"Non little-endian hardware is not supported\");\n  var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, \"0\"));\n  function utf8ToBytes2(str) {\n    if (typeof str !== \"string\")\n      throw new Error(\\`utf8ToBytes expected string, got \\${typeof str}\\`);\n    return new Uint8Array(new TextEncoder().encode(str));\n  }\n  function toBytes(data) {\n    if (typeof data === \"string\")\n      data = utf8ToBytes2(data);\n    if (!u8a2(data))\n      throw new Error(\\`expected Uint8Array, got \\${typeof data}\\`);\n    return data;\n  }\n  function concatBytes2(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0;\n    arrays.forEach((a) => {\n      if (!u8a2(a))\n        throw new Error(\"Uint8Array expected\");\n      r.set(a, pad);\n      pad += a.length;\n    });\n    return r;\n  }\n  var Hash = class {\n    // Safe version that clones internal state\n    clone() {\n      return this._cloneInto();\n    }\n  };\n  function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n  }\n  function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n  }\n  function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === \"function\") {\n      return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  }\n\n  // ../node_modules/@noble/hashes/esm/_sha2.js\n  function setBigUint64(view, byteOffset, value, isLE2) {\n    if (typeof view.setBigUint64 === \"function\")\n      return view.setBigUint64(byteOffset, value, isLE2);\n    const _32n2 = BigInt(32);\n    const _u32_max = BigInt(4294967295);\n    const wh = Number(value >> _32n2 & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE2 ? 4 : 0;\n    const l = isLE2 ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE2);\n    view.setUint32(byteOffset + l, wl, isLE2);\n  }\n  var SHA2 = class extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE2) {\n      super();\n      this.blockLen = blockLen;\n      this.outputLen = outputLen;\n      this.padOffset = padOffset;\n      this.isLE = isLE2;\n      this.finished = false;\n      this.length = 0;\n      this.pos = 0;\n      this.destroyed = false;\n      this.buffer = new Uint8Array(blockLen);\n      this.view = createView(this.buffer);\n    }\n    update(data) {\n      assert_default.exists(this);\n      const { view, buffer, blockLen } = this;\n      data = toBytes(data);\n      const len = data.length;\n      for (let pos = 0; pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        if (take === blockLen) {\n          const dataView = createView(data);\n          for (; blockLen <= len - pos; pos += blockLen)\n            this.process(dataView, pos);\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n    digestInto(out) {\n      assert_default.exists(this);\n      assert_default.output(out, this);\n      this.finished = true;\n      const { buffer, view, blockLen, isLE: isLE2 } = this;\n      let { pos } = this;\n      buffer[pos++] = 128;\n      this.buffer.subarray(pos).fill(0);\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      for (let i = pos; i < blockLen; i++)\n        buffer[i] = 0;\n      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);\n      this.process(view, 0);\n      const oview = createView(out);\n      const len = this.outputLen;\n      if (len % 4)\n        throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n      const outLen = len / 4;\n      const state = this.get();\n      if (outLen > state.length)\n        throw new Error(\"_sha2: outputLen bigger than state\");\n      for (let i = 0; i < outLen; i++)\n        oview.setUint32(4 * i, state[i], isLE2);\n    }\n    digest() {\n      const { buffer, outputLen } = this;\n      this.digestInto(buffer);\n      const res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n    _cloneInto(to) {\n      to || (to = new this.constructor());\n      to.set(...this.get());\n      const { blockLen, buffer, length, finished, destroyed, pos } = this;\n      to.length = length;\n      to.pos = pos;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      if (length % blockLen)\n        to.buffer.set(buffer);\n      return to;\n    }\n  };\n\n  // ../node_modules/@noble/hashes/esm/sha256.js\n  var Chi = (a, b, c) => a & b ^ ~a & c;\n  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;\n  var SHA256_K = new Uint32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  var IV = new Uint32Array([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n  var SHA256_W = new Uint32Array(64);\n  var SHA256 = class extends SHA2 {\n    constructor() {\n      super(64, 32, 8, false);\n      this.A = IV[0] | 0;\n      this.B = IV[1] | 0;\n      this.C = IV[2] | 0;\n      this.D = IV[3] | 0;\n      this.E = IV[4] | 0;\n      this.F = IV[5] | 0;\n      this.G = IV[6] | 0;\n      this.H = IV[7] | 0;\n    }\n    get() {\n      const { A, B, C, D, E, F, G, H } = this;\n      return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n      this.A = A | 0;\n      this.B = B | 0;\n      this.C = C | 0;\n      this.D = D | 0;\n      this.E = E | 0;\n      this.F = F | 0;\n      this.G = G | 0;\n      this.H = H | 0;\n    }\n    process(view, offset) {\n      for (let i = 0; i < 16; i++, offset += 4)\n        SHA256_W[i] = view.getUint32(offset, false);\n      for (let i = 16; i < 64; i++) {\n        const W15 = SHA256_W[i - 15];\n        const W2 = SHA256_W[i - 2];\n        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n      }\n      let { A, B, C, D, E, F, G, H } = this;\n      for (let i = 0; i < 64; i++) {\n        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n        const T2 = sigma0 + Maj(A, B, C) | 0;\n        H = G;\n        G = F;\n        F = E;\n        E = D + T1 | 0;\n        D = C;\n        C = B;\n        B = A;\n        A = T1 + T2 | 0;\n      }\n      A = A + this.A | 0;\n      B = B + this.B | 0;\n      C = C + this.C | 0;\n      D = D + this.D | 0;\n      E = E + this.E | 0;\n      F = F + this.F | 0;\n      G = G + this.G | 0;\n      H = H + this.H | 0;\n      this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n      SHA256_W.fill(0);\n    }\n    destroy() {\n      this.set(0, 0, 0, 0, 0, 0, 0, 0);\n      this.buffer.fill(0);\n    }\n  };\n  var SHA224 = class extends SHA256 {\n    constructor() {\n      super();\n      this.A = 3238371032 | 0;\n      this.B = 914150663 | 0;\n      this.C = 812702999 | 0;\n      this.D = 4144912697 | 0;\n      this.E = 4290775857 | 0;\n      this.F = 1750603025 | 0;\n      this.G = 1694076839 | 0;\n      this.H = 3204075428 | 0;\n      this.outputLen = 28;\n    }\n  };\n  var sha256 = wrapConstructor(() => new SHA256());\n  var sha224 = wrapConstructor(() => new SHA224());\n\n  // ../esm/abstract/modular.js\n  var _0n2 = BigInt(0);\n  var _1n2 = BigInt(1);\n  var _2n2 = BigInt(2);\n  var _3n = BigInt(3);\n  var _4n = BigInt(4);\n  var _5n = BigInt(5);\n  var _8n = BigInt(8);\n  var _9n = BigInt(9);\n  var _16n = BigInt(16);\n  function mod(a, b) {\n    const result = a % b;\n    return result >= _0n2 ? result : b + result;\n  }\n  function pow(num, power, modulo) {\n    if (modulo <= _0n2 || power < _0n2)\n      throw new Error(\"Expected power/modulo > 0\");\n    if (modulo === _1n2)\n      return _0n2;\n    let res = _1n2;\n    while (power > _0n2) {\n      if (power & _1n2)\n        res = res * num % modulo;\n      num = num * num % modulo;\n      power >>= _1n2;\n    }\n    return res;\n  }\n  function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n2) {\n      res *= res;\n      res %= modulo;\n    }\n    return res;\n  }\n  function invert(number2, modulo) {\n    if (number2 === _0n2 || modulo <= _0n2) {\n      throw new Error(\\`invert: expected positive integers, got n=\\${number2} mod=\\${modulo}\\`);\n    }\n    let a = mod(number2, modulo);\n    let b = modulo;\n    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;\n    while (a !== _0n2) {\n      const q = b / a;\n      const r = b % a;\n      const m = x - u * q;\n      const n = y - v * q;\n      b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n2)\n      throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n  }\n  function tonelliShanks(P3) {\n    const legendreC = (P3 - _1n2) / _2n2;\n    let Q, S, Z;\n    for (Q = P3 - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)\n      ;\n    for (Z = _2n2; Z < P3 && pow(Z, legendreC, P3) !== P3 - _1n2; Z++)\n      ;\n    if (S === 1) {\n      const p1div4 = (P3 + _1n2) / _4n;\n      return function tonelliFast(Fp8, n) {\n        const root = Fp8.pow(n, p1div4);\n        if (!Fp8.eql(Fp8.sqr(root), n))\n          throw new Error(\"Cannot find square root\");\n        return root;\n      };\n    }\n    const Q1div2 = (Q + _1n2) / _2n2;\n    return function tonelliSlow(Fp8, n) {\n      if (Fp8.pow(n, legendreC) === Fp8.neg(Fp8.ONE))\n        throw new Error(\"Cannot find square root\");\n      let r = S;\n      let g = Fp8.pow(Fp8.mul(Fp8.ONE, Z), Q);\n      let x = Fp8.pow(n, Q1div2);\n      let b = Fp8.pow(n, Q);\n      while (!Fp8.eql(b, Fp8.ONE)) {\n        if (Fp8.eql(b, Fp8.ZERO))\n          return Fp8.ZERO;\n        let m = 1;\n        for (let t2 = Fp8.sqr(b); m < r; m++) {\n          if (Fp8.eql(t2, Fp8.ONE))\n            break;\n          t2 = Fp8.sqr(t2);\n        }\n        const ge = Fp8.pow(g, _1n2 << BigInt(r - m - 1));\n        g = Fp8.sqr(ge);\n        x = Fp8.mul(x, ge);\n        b = Fp8.mul(b, g);\n        r = m;\n      }\n      return x;\n    };\n  }\n  function FpSqrt(P3) {\n    if (P3 % _4n === _3n) {\n      const p1div4 = (P3 + _1n2) / _4n;\n      return function sqrt3mod4(Fp8, n) {\n        const root = Fp8.pow(n, p1div4);\n        if (!Fp8.eql(Fp8.sqr(root), n))\n          throw new Error(\"Cannot find square root\");\n        return root;\n      };\n    }\n    if (P3 % _8n === _5n) {\n      const c1 = (P3 - _5n) / _8n;\n      return function sqrt5mod8(Fp8, n) {\n        const n2 = Fp8.mul(n, _2n2);\n        const v = Fp8.pow(n2, c1);\n        const nv = Fp8.mul(n, v);\n        const i = Fp8.mul(Fp8.mul(nv, _2n2), v);\n        const root = Fp8.mul(nv, Fp8.sub(i, Fp8.ONE));\n        if (!Fp8.eql(Fp8.sqr(root), n))\n          throw new Error(\"Cannot find square root\");\n        return root;\n      };\n    }\n    if (P3 % _16n === _9n) {\n    }\n    return tonelliShanks(P3);\n  }\n  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;\n  var FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n  ];\n  function validateField(field) {\n    const initial = {\n      ORDER: \"bigint\",\n      MASK: \"bigint\",\n      BYTES: \"isSafeInteger\",\n      BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n      map[val] = \"function\";\n      return map;\n    }, initial);\n    return validateObject(field, opts);\n  }\n  function FpPow(f, num, power) {\n    if (power < _0n2)\n      throw new Error(\"Expected power > 0\");\n    if (power === _0n2)\n      return f.ONE;\n    if (power === _1n2)\n      return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n2) {\n      if (power & _1n2)\n        p = f.mul(p, d);\n      d = f.sqr(d);\n      power >>= _1n2;\n    }\n    return p;\n  }\n  function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n      if (f.is0(num))\n        return acc;\n      tmp[i] = acc;\n      return f.mul(acc, num);\n    }, f.ONE);\n    const inverted = f.inv(lastMultiplied);\n    nums.reduceRight((acc, num, i) => {\n      if (f.is0(num))\n        return acc;\n      tmp[i] = f.mul(acc, tmp[i]);\n      return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n  }\n  function nLength(n, nBitLength) {\n    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n  }\n  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {\n    if (ORDER <= _0n2)\n      throw new Error(\\`Expected Fp ORDER > 0, got \\${ORDER}\\`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);\n    if (BYTES > 2048)\n      throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n      ORDER,\n      BITS,\n      BYTES,\n      MASK: bitMask(BITS),\n      ZERO: _0n2,\n      ONE: _1n2,\n      create: (num) => mod(num, ORDER),\n      isValid: (num) => {\n        if (typeof num !== \"bigint\")\n          throw new Error(\\`Invalid field element: expected bigint, got \\${typeof num}\\`);\n        return _0n2 <= num && num < ORDER;\n      },\n      is0: (num) => num === _0n2,\n      isOdd: (num) => (num & _1n2) === _1n2,\n      neg: (num) => mod(-num, ORDER),\n      eql: (lhs, rhs) => lhs === rhs,\n      sqr: (num) => mod(num * num, ORDER),\n      add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n      pow: (num, power) => FpPow(f, num, power),\n      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n      // Same as above, but doesn't normalize\n      sqrN: (num) => num * num,\n      addN: (lhs, rhs) => lhs + rhs,\n      subN: (lhs, rhs) => lhs - rhs,\n      mulN: (lhs, rhs) => lhs * rhs,\n      inv: (num) => invert(num, ORDER),\n      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n      invertBatch: (lst) => FpInvertBatch(f, lst),\n      // TODO: do we really need constant cmov?\n      // We don't have const-time bigints anyway, so probably will be not very useful\n      cmov: (a, b, c) => c ? b : a,\n      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),\n      fromBytes: (bytes2) => {\n        if (bytes2.length !== BYTES)\n          throw new Error(\\`Fp.fromBytes: expected \\${BYTES}, got \\${\n  bytes2.length\n}\\`);\n        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);\n      }\n    });\n    return Object.freeze(f);\n  }\n  function FpSqrtEven(Fp8, elm) {\n    if (!Fp8.isOdd)\n      throw new Error(\\`Field doesn't have isOdd\\`);\n    const root = Fp8.sqrt(elm);\n    return Fp8.isOdd(root) ? Fp8.neg(root) : root;\n  }\n  function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {\n    hash2 = ensureBytes(\"privateHash\", hash2);\n    const hashLen = hash2.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n      throw new Error(\\`hashToPrivateScalar: expected \\${minLen}-1024 bytes of input, got \\${hashLen}\\`);\n    const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);\n    return mod(num, groupOrder - _1n2) + _1n2;\n  }\n\n  // ../esm/abstract/curve.js\n  var _0n3 = BigInt(0);\n  var _1n3 = BigInt(1);\n  function wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n      const neg = item.negate();\n      return condition ? neg : item;\n    };\n    const opts = (W) => {\n      const windows = Math.ceil(bits / W) + 1;\n      const windowSize = 2 ** (W - 1);\n      return { windows, windowSize };\n    };\n    return {\n      constTimeNegate,\n      // non-const time multiplication ladder\n      unsafeLadder(elm, n) {\n        let p = c.ZERO;\n        let d = elm;\n        while (n > _0n3) {\n          if (n & _1n3)\n            p = p.add(d);\n          d = d.double();\n          n >>= _1n3;\n        }\n        return p;\n      },\n      /**\n       * Creates a wNAF precomputation window. Used for caching.\n       * Default window size is set by \\`utils.precompute()\\` and is equal to 8.\n       * Number of precomputed points depends on the curve size:\n       * 2^(\ud835\udc4a\u22121) * (Math.ceil(\ud835\udc5b / \ud835\udc4a) + 1), where:\n       * - \ud835\udc4a is the window size\n       * - \ud835\udc5b is the bitlength of the curve order.\n       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n       * @returns precomputed point tables flattened to a single array\n       */\n      precomputeWindow(elm, W) {\n        const { windows, windowSize } = opts(W);\n        const points = [];\n        let p = elm;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n          base = p;\n          points.push(base);\n          for (let i = 1; i < windowSize; i++) {\n            base = base.add(p);\n            points.push(base);\n          }\n          p = base.double();\n        }\n        return points;\n      },\n      /**\n       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n       * @param W window size\n       * @param precomputes precomputed tables\n       * @param n scalar (we don't check here, but should be less than curve order)\n       * @returns real and fake (for const-time) points\n       */\n      wNAF(W, precomputes, n) {\n        const { windows, windowSize } = opts(W);\n        let p = c.ZERO;\n        let f = c.BASE;\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n          const offset = window * windowSize;\n          let wbits = Number(n & mask);\n          n >>= shiftBy;\n          if (wbits > windowSize) {\n            wbits -= maxNumber;\n            n += _1n3;\n          }\n          const offset1 = offset;\n          const offset2 = offset + Math.abs(wbits) - 1;\n          const cond1 = window % 2 !== 0;\n          const cond2 = wbits < 0;\n          if (wbits === 0) {\n            f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n          } else {\n            p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n          }\n        }\n        return { p, f };\n      },\n      wNAFCached(P3, precomputesMap, n, transform) {\n        const W = P3._WINDOW_SIZE || 1;\n        let comp = precomputesMap.get(P3);\n        if (!comp) {\n          comp = this.precomputeWindow(P3, W);\n          if (W !== 1) {\n            precomputesMap.set(P3, transform(comp));\n          }\n        }\n        return this.wNAF(W, comp, n);\n      }\n    };\n  }\n  function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n      n: \"bigint\",\n      h: \"bigint\",\n      Gx: \"field\",\n      Gy: \"field\"\n    }, {\n      nBitLength: \"isSafeInteger\",\n      nByteLength: \"isSafeInteger\"\n    });\n    return Object.freeze({\n      ...nLength(curve.n, curve.nBitLength),\n      ...curve,\n      ...{ p: curve.Fp.ORDER }\n    });\n  }\n\n  // ../esm/abstract/weierstrass.js\n  function validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n      a: \"field\",\n      b: \"field\"\n    }, {\n      allowedPrivateKeyLengths: \"array\",\n      wrapPrivateKey: \"boolean\",\n      isTorsionFree: \"function\",\n      clearCofactor: \"function\",\n      allowInfinityPoint: \"boolean\",\n      fromBytes: \"function\",\n      toBytes: \"function\"\n    });\n    const { endo, Fp: Fp8, a } = opts;\n    if (endo) {\n      if (!Fp8.eql(a, Fp8.ZERO)) {\n        throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n      }\n      if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n        throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n      }\n    }\n    return Object.freeze({ ...opts });\n  }\n  var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;\n  var DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n      constructor(m = \"\") {\n        super(m);\n      }\n    },\n    _parseInt(data) {\n      const { Err: E } = DER;\n      if (data.length < 2 || data[0] !== 2)\n        throw new E(\"Invalid signature integer tag\");\n      const len = data[1];\n      const res = data.subarray(2, len + 2);\n      if (!len || res.length !== len)\n        throw new E(\"Invalid signature integer: wrong length\");\n      if (res[0] & 128)\n        throw new E(\"Invalid signature integer: negative\");\n      if (res[0] === 0 && !(res[1] & 128))\n        throw new E(\"Invalid signature integer: unnecessary leading zero\");\n      return { d: b2n(res), l: data.subarray(len + 2) };\n    },\n    toSig(hex) {\n      const { Err: E } = DER;\n      const data = typeof hex === \"string\" ? h2b(hex) : hex;\n      if (!(data instanceof Uint8Array))\n        throw new Error(\"ui8a expected\");\n      let l = data.length;\n      if (l < 2 || data[0] != 48)\n        throw new E(\"Invalid signature tag\");\n      if (data[1] !== l - 2)\n        throw new E(\"Invalid signature: incorrect length\");\n      const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n      const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n      if (rBytesLeft.length)\n        throw new E(\"Invalid signature: left bytes after parsing\");\n      return { r, s };\n    },\n    hexFromSig(sig) {\n      const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? \"00\" + s2 : s2;\n      const h = (num) => {\n        const hex = num.toString(16);\n        return hex.length & 1 ? \\`0\\${hex}\\` : hex;\n      };\n      const s = slice(h(sig.s));\n      const r = slice(h(sig.r));\n      const shl = s.length / 2;\n      const rhl = r.length / 2;\n      const sl = h(shl);\n      const rl = h(rhl);\n      return \\`30\\${h(rhl + shl + 4)}02\\${rl}\\${r}02\\${sl}\\${s}\\`;\n    }\n  };\n  var _0n4 = BigInt(0);\n  var _1n4 = BigInt(1);\n  var _2n3 = BigInt(2);\n  var _3n2 = BigInt(3);\n  var _4n2 = BigInt(4);\n  function weierstrassPoints(opts) {\n    const CURVE2 = validatePointOpts(opts);\n    const { Fp: Fp8 } = CURVE2;\n    const toBytes2 = CURVE2.toBytes || ((c, point, isCompressed) => {\n      const a = point.toAffine();\n      return concatBytes(Uint8Array.from([4]), Fp8.toBytes(a.x), Fp8.toBytes(a.y));\n    });\n    const fromBytes = CURVE2.fromBytes || ((bytes2) => {\n      const tail = bytes2.subarray(1);\n      const x = Fp8.fromBytes(tail.subarray(0, Fp8.BYTES));\n      const y = Fp8.fromBytes(tail.subarray(Fp8.BYTES, 2 * Fp8.BYTES));\n      return { x, y };\n    });\n    function weierstrassEquation(x) {\n      const { a, b } = CURVE2;\n      const x2 = Fp8.sqr(x);\n      const x3 = Fp8.mul(x2, x);\n      return Fp8.add(Fp8.add(x3, Fp8.mul(x, a)), b);\n    }\n    if (!Fp8.eql(Fp8.sqr(CURVE2.Gy), weierstrassEquation(CURVE2.Gx)))\n      throw new Error(\"bad generator point: equation left != right\");\n    function isWithinCurveOrder(num) {\n      return typeof num === \"bigint\" && _0n4 < num && num < CURVE2.n;\n    }\n    function assertGE(num) {\n      if (!isWithinCurveOrder(num))\n        throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n    }\n    function normPrivateKeyToScalar(key) {\n      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE2;\n      if (lengths && typeof key !== \"bigint\") {\n        if (key instanceof Uint8Array)\n          key = bytesToHex(key);\n        if (typeof key !== \"string\" || !lengths.includes(key.length))\n          throw new Error(\"Invalid key\");\n        key = key.padStart(nByteLength * 2, \"0\");\n      }\n      let num;\n      try {\n        num = typeof key === \"bigint\" ? key : bytesToNumberBE(ensureBytes(\"private key\", key, nByteLength));\n      } catch (error) {\n        throw new Error(\\`private key must be \\${nByteLength} bytes, hex or bigint, not \\${typeof key}\\`);\n      }\n      if (wrapPrivateKey)\n        num = mod(num, n);\n      assertGE(num);\n      return num;\n    }\n    const pointPrecomputes = /* @__PURE__ */ new Map();\n    function assertPrjPoint(other) {\n      if (!(other instanceof Point2))\n        throw new Error(\"ProjectivePoint expected\");\n    }\n    class Point2 {\n      constructor(px, py, pz) {\n        this.px = px;\n        this.py = py;\n        this.pz = pz;\n        if (px == null || !Fp8.isValid(px))\n          throw new Error(\"x required\");\n        if (py == null || !Fp8.isValid(py))\n          throw new Error(\"y required\");\n        if (pz == null || !Fp8.isValid(pz))\n          throw new Error(\"z required\");\n      }\n      // Does not validate if the point is on-curve.\n      // Use fromHex instead, or call assertValidity() later.\n      static fromAffine(p) {\n        const { x, y } = p || {};\n        if (!p || !Fp8.isValid(x) || !Fp8.isValid(y))\n          throw new Error(\"invalid affine point\");\n        if (p instanceof Point2)\n          throw new Error(\"projective point not allowed\");\n        const is0 = (i) => Fp8.eql(i, Fp8.ZERO);\n        if (is0(x) && is0(y))\n          return Point2.ZERO;\n        return new Point2(x, y, Fp8.ONE);\n      }\n      get x() {\n        return this.toAffine().x;\n      }\n      get y() {\n        return this.toAffine().y;\n      }\n      /**\n       * Takes a bunch of Projective Points but executes only one\n       * inversion on all of them. Inversion is very slow operation,\n       * so this improves performance massively.\n       * Optimization: converts a list of projective points to a list of identical points with Z=1.\n       */\n      static normalizeZ(points) {\n        const toInv = Fp8.invertBatch(points.map((p) => p.pz));\n        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);\n      }\n      /**\n       * Converts hash string or Uint8Array to Point.\n       * @param hex short/long ECDSA hex\n       */\n      static fromHex(hex) {\n        const P3 = Point2.fromAffine(fromBytes(ensureBytes(\"pointHex\", hex)));\n        P3.assertValidity();\n        return P3;\n      }\n      // Multiplies generator point by privateKey.\n      static fromPrivateKey(privateKey) {\n        return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));\n      }\n      // \"Private method\", don't use it directly\n      _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n      }\n      // A point on curve is valid if it conforms to equation.\n      assertValidity() {\n        if (this.is0()) {\n          if (CURVE2.allowInfinityPoint)\n            return;\n          throw new Error(\"bad point: ZERO\");\n        }\n        const { x, y } = this.toAffine();\n        if (!Fp8.isValid(x) || !Fp8.isValid(y))\n          throw new Error(\"bad point: x or y not FE\");\n        const left = Fp8.sqr(y);\n        const right = weierstrassEquation(x);\n        if (!Fp8.eql(left, right))\n          throw new Error(\"bad point: equation left != right\");\n        if (!this.isTorsionFree())\n          throw new Error(\"bad point: not in prime-order subgroup\");\n      }\n      hasEvenY() {\n        const { y } = this.toAffine();\n        if (Fp8.isOdd)\n          return !Fp8.isOdd(y);\n        throw new Error(\"Field doesn't support isOdd\");\n      }\n      /**\n       * Compare one point to another.\n       */\n      equals(other) {\n        assertPrjPoint(other);\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = other;\n        const U1 = Fp8.eql(Fp8.mul(X1, Z2), Fp8.mul(X2, Z1));\n        const U2 = Fp8.eql(Fp8.mul(Y1, Z2), Fp8.mul(Y2, Z1));\n        return U1 && U2;\n      }\n      /**\n       * Flips point to one corresponding to (x, -y) in Affine coordinates.\n       */\n      negate() {\n        return new Point2(this.px, Fp8.neg(this.py), this.pz);\n      }\n      // Renes-Costello-Batina exception-free doubling formula.\n      // There is 30% faster Jacobian formula, but it is not complete.\n      // https://eprint.iacr.org/2015/1060, algorithm 3\n      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n      double() {\n        const { a, b } = CURVE2;\n        const b3 = Fp8.mul(b, _3n2);\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        let X3 = Fp8.ZERO, Y3 = Fp8.ZERO, Z3 = Fp8.ZERO;\n        let t0 = Fp8.mul(X1, X1);\n        let t1 = Fp8.mul(Y1, Y1);\n        let t2 = Fp8.mul(Z1, Z1);\n        let t3 = Fp8.mul(X1, Y1);\n        t3 = Fp8.add(t3, t3);\n        Z3 = Fp8.mul(X1, Z1);\n        Z3 = Fp8.add(Z3, Z3);\n        X3 = Fp8.mul(a, Z3);\n        Y3 = Fp8.mul(b3, t2);\n        Y3 = Fp8.add(X3, Y3);\n        X3 = Fp8.sub(t1, Y3);\n        Y3 = Fp8.add(t1, Y3);\n        Y3 = Fp8.mul(X3, Y3);\n        X3 = Fp8.mul(t3, X3);\n        Z3 = Fp8.mul(b3, Z3);\n        t2 = Fp8.mul(a, t2);\n        t3 = Fp8.sub(t0, t2);\n        t3 = Fp8.mul(a, t3);\n        t3 = Fp8.add(t3, Z3);\n        Z3 = Fp8.add(t0, t0);\n        t0 = Fp8.add(Z3, t0);\n        t0 = Fp8.add(t0, t2);\n        t0 = Fp8.mul(t0, t3);\n        Y3 = Fp8.add(Y3, t0);\n        t2 = Fp8.mul(Y1, Z1);\n        t2 = Fp8.add(t2, t2);\n        t0 = Fp8.mul(t2, t3);\n        X3 = Fp8.sub(X3, t0);\n        Z3 = Fp8.mul(t2, t1);\n        Z3 = Fp8.add(Z3, Z3);\n        Z3 = Fp8.add(Z3, Z3);\n        return new Point2(X3, Y3, Z3);\n      }\n      // Renes-Costello-Batina exception-free addition formula.\n      // There is 30% faster Jacobian formula, but it is not complete.\n      // https://eprint.iacr.org/2015/1060, algorithm 1\n      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n      add(other) {\n        assertPrjPoint(other);\n        const { px: X1, py: Y1, pz: Z1 } = this;\n        const { px: X2, py: Y2, pz: Z2 } = other;\n        let X3 = Fp8.ZERO, Y3 = Fp8.ZERO, Z3 = Fp8.ZERO;\n        const a = CURVE2.a;\n        const b3 = Fp8.mul(CURVE2.b, _3n2);\n        let t0 = Fp8.mul(X1, X2);\n        let t1 = Fp8.mul(Y1, Y2);\n        let t2 = Fp8.mul(Z1, Z2);\n        let t3 = Fp8.add(X1, Y1);\n        let t4 = Fp8.add(X2, Y2);\n        t3 = Fp8.mul(t3, t4);\n        t4 = Fp8.add(t0, t1);\n        t3 = Fp8.sub(t3, t4);\n        t4 = Fp8.add(X1, Z1);\n        let t5 = Fp8.add(X2, Z2);\n        t4 = Fp8.mul(t4, t5);\n        t5 = Fp8.add(t0, t2);\n        t4 = Fp8.sub(t4, t5);\n        t5 = Fp8.add(Y1, Z1);\n        X3 = Fp8.add(Y2, Z2);\n        t5 = Fp8.mul(t5, X3);\n        X3 = Fp8.add(t1, t2);\n        t5 = Fp8.sub(t5, X3);\n        Z3 = Fp8.mul(a, t4);\n        X3 = Fp8.mul(b3, t2);\n        Z3 = Fp8.add(X3, Z3);\n        X3 = Fp8.sub(t1, Z3);\n        Z3 = Fp8.add(t1, Z3);\n        Y3 = Fp8.mul(X3, Z3);\n        t1 = Fp8.add(t0, t0);\n        t1 = Fp8.add(t1, t0);\n        t2 = Fp8.mul(a, t2);\n        t4 = Fp8.mul(b3, t4);\n        t1 = Fp8.add(t1, t2);\n        t2 = Fp8.sub(t0, t2);\n        t2 = Fp8.mul(a, t2);\n        t4 = Fp8.add(t4, t2);\n        t0 = Fp8.mul(t1, t4);\n        Y3 = Fp8.add(Y3, t0);\n        t0 = Fp8.mul(t5, t4);\n        X3 = Fp8.mul(t3, X3);\n        X3 = Fp8.sub(X3, t0);\n        t0 = Fp8.mul(t3, t1);\n        Z3 = Fp8.mul(t5, Z3);\n        Z3 = Fp8.add(Z3, t0);\n        return new Point2(X3, Y3, Z3);\n      }\n      subtract(other) {\n        return this.add(other.negate());\n      }\n      is0() {\n        return this.equals(Point2.ZERO);\n      }\n      wNAF(n) {\n        return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n          const toInv = Fp8.invertBatch(comp.map((p) => p.pz));\n          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);\n        });\n      }\n      /**\n       * Non-constant-time multiplication. Uses double-and-add algorithm.\n       * It's faster, but should only be used when you don't care about\n       * an exposed private key e.g. sig verification, which works over *public* keys.\n       */\n      multiplyUnsafe(n) {\n        const I = Point2.ZERO;\n        if (n === _0n4)\n          return I;\n        assertGE(n);\n        if (n === _1n4)\n          return this;\n        const { endo } = CURVE2;\n        if (!endo)\n          return wnaf.unsafeLadder(this, n);\n        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let k1p = I;\n        let k2p = I;\n        let d = this;\n        while (k1 > _0n4 || k2 > _0n4) {\n          if (k1 & _1n4)\n            k1p = k1p.add(d);\n          if (k2 & _1n4)\n            k2p = k2p.add(d);\n          d = d.double();\n          k1 >>= _1n4;\n          k2 >>= _1n4;\n        }\n        if (k1neg)\n          k1p = k1p.negate();\n        if (k2neg)\n          k2p = k2p.negate();\n        k2p = new Point2(Fp8.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        return k1p.add(k2p);\n      }\n      /**\n       * Constant time multiplication.\n       * Uses wNAF method. Windowed method may be 10% faster,\n       * but takes 2x longer to generate and consumes 2x memory.\n       * Uses precomputes when available.\n       * Uses endomorphism for Koblitz curves.\n       * @param scalar by which the point would be multiplied\n       * @returns New point\n       */\n      multiply(scalar) {\n        assertGE(scalar);\n        let n = scalar;\n        let point, fake;\n        const { endo } = CURVE2;\n        if (endo) {\n          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n          let { p: k1p, f: f1p } = this.wNAF(k1);\n          let { p: k2p, f: f2p } = this.wNAF(k2);\n          k1p = wnaf.constTimeNegate(k1neg, k1p);\n          k2p = wnaf.constTimeNegate(k2neg, k2p);\n          k2p = new Point2(Fp8.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n          point = k1p.add(k2p);\n          fake = f1p.add(f2p);\n        } else {\n          const { p, f } = this.wNAF(n);\n          point = p;\n          fake = f;\n        }\n        return Point2.normalizeZ([point, fake])[0];\n      }\n      /**\n       * Efficiently calculate \\`aP + bQ\\`. Unsafe, can expose private key, if used incorrectly.\n       * Not using Strauss-Shamir trick: precomputation tables are faster.\n       * The trick could be useful if both P and Q are not G (not in our case).\n       * @returns non-zero affine point\n       */\n      multiplyAndAddUnsafe(Q, a, b) {\n        const G = Point2.BASE;\n        const mul = (P3, a2) => a2 === _0n4 || a2 === _1n4 || !P3.equals(G) ? P3.multiplyUnsafe(a2) : P3.multiply(a2);\n        const sum = mul(this, a).add(mul(Q, b));\n        return sum.is0() ? void 0 : sum;\n      }\n      // Converts Projective point to affine (x, y) coordinates.\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\n      // (x, y, z) \u220b (x=x/z, y=y/z)\n      toAffine(iz) {\n        const { px: x, py: y, pz: z } = this;\n        const is0 = this.is0();\n        if (iz == null)\n          iz = is0 ? Fp8.ONE : Fp8.inv(z);\n        const ax = Fp8.mul(x, iz);\n        const ay = Fp8.mul(y, iz);\n        const zz = Fp8.mul(z, iz);\n        if (is0)\n          return { x: Fp8.ZERO, y: Fp8.ZERO };\n        if (!Fp8.eql(zz, Fp8.ONE))\n          throw new Error(\"invZ was invalid\");\n        return { x: ax, y: ay };\n      }\n      isTorsionFree() {\n        const { h: cofactor, isTorsionFree } = CURVE2;\n        if (cofactor === _1n4)\n          return true;\n        if (isTorsionFree)\n          return isTorsionFree(Point2, this);\n        throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n      }\n      clearCofactor() {\n        const { h: cofactor, clearCofactor } = CURVE2;\n        if (cofactor === _1n4)\n          return this;\n        if (clearCofactor)\n          return clearCofactor(Point2, this);\n        return this.multiplyUnsafe(CURVE2.h);\n      }\n      toRawBytes(isCompressed = true) {\n        this.assertValidity();\n        return toBytes2(Point2, this, isCompressed);\n      }\n      toHex(isCompressed = true) {\n        return bytesToHex(this.toRawBytes(isCompressed));\n      }\n    }\n    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, Fp8.ONE);\n    Point2.ZERO = new Point2(Fp8.ZERO, Fp8.ONE, Fp8.ZERO);\n    const _bits = CURVE2.nBitLength;\n    const wnaf = wNAF(Point2, CURVE2.endo ? Math.ceil(_bits / 2) : _bits);\n    return {\n      CURVE: CURVE2,\n      ProjectivePoint: Point2,\n      normPrivateKeyToScalar,\n      weierstrassEquation,\n      isWithinCurveOrder\n    };\n  }\n  function validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n      hash: \"hash\",\n      hmac: \"function\",\n      randomBytes: \"function\"\n    }, {\n      bits2int: \"function\",\n      bits2int_modN: \"function\",\n      lowS: \"boolean\"\n    });\n    return Object.freeze({ lowS: true, ...opts });\n  }\n  function weierstrass(curveDef) {\n    const CURVE2 = validateOpts(curveDef);\n    const { Fp: Fp8, n: CURVE_ORDER } = CURVE2;\n    const compressedLen = Fp8.BYTES + 1;\n    const uncompressedLen = 2 * Fp8.BYTES + 1;\n    function isValidFieldElement(num) {\n      return _0n4 < num && num < Fp8.ORDER;\n    }\n    function modN(a) {\n      return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n      return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n      ...CURVE2,\n      toBytes(c, point, isCompressed) {\n        const a = point.toAffine();\n        const x = Fp8.toBytes(a.x);\n        const cat = concatBytes;\n        if (isCompressed) {\n          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);\n        } else {\n          return cat(Uint8Array.from([4]), x, Fp8.toBytes(a.y));\n        }\n      },\n      fromBytes(bytes2) {\n        const len = bytes2.length;\n        const head = bytes2[0];\n        const tail = bytes2.subarray(1);\n        if (len === compressedLen && (head === 2 || head === 3)) {\n          const x = bytesToNumberBE(tail);\n          if (!isValidFieldElement(x))\n            throw new Error(\"Point is not on curve\");\n          const y2 = weierstrassEquation(x);\n          let y = Fp8.sqrt(y2);\n          const isYOdd = (y & _1n4) === _1n4;\n          const isHeadOdd = (head & 1) === 1;\n          if (isHeadOdd !== isYOdd)\n            y = Fp8.neg(y);\n          return { x, y };\n        } else if (len === uncompressedLen && head === 4) {\n          const x = Fp8.fromBytes(tail.subarray(0, Fp8.BYTES));\n          const y = Fp8.fromBytes(tail.subarray(Fp8.BYTES, 2 * Fp8.BYTES));\n          return { x, y };\n        } else {\n          throw new Error(\\`Point of length \\${len} was invalid. Expected \\${compressedLen} compressed bytes or \\${uncompressedLen} uncompressed bytes\\`);\n        }\n      }\n    });\n    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE2.nByteLength));\n    function isBiggerThanHalfOrder(number2) {\n      const HALF = CURVE_ORDER >> _1n4;\n      return number2 > HALF;\n    }\n    function normalizeS(s) {\n      return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n    class Signature {\n      constructor(r, s, recovery) {\n        this.r = r;\n        this.s = s;\n        this.recovery = recovery;\n        this.assertValidity();\n      }\n      // pair (bytes of r, bytes of s)\n      static fromCompact(hex) {\n        const l = CURVE2.nByteLength;\n        hex = ensureBytes(\"compactSignature\", hex, l * 2);\n        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n      }\n      // DER encoded ECDSA signature\n      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n      static fromDER(hex) {\n        const { r, s } = DER.toSig(ensureBytes(\"DER\", hex));\n        return new Signature(r, s);\n      }\n      assertValidity() {\n        if (!isWithinCurveOrder(this.r))\n          throw new Error(\"r must be 0 < r < CURVE.n\");\n        if (!isWithinCurveOrder(this.s))\n          throw new Error(\"s must be 0 < s < CURVE.n\");\n      }\n      addRecoveryBit(recovery) {\n        return new Signature(this.r, this.s, recovery);\n      }\n      recoverPublicKey(msgHash) {\n        const { r, s, recovery: rec } = this;\n        const h = bits2int_modN(ensureBytes(\"msgHash\", msgHash));\n        if (rec == null || ![0, 1, 2, 3].includes(rec))\n          throw new Error(\"recovery id invalid\");\n        const radj = rec === 2 || rec === 3 ? r + CURVE2.n : r;\n        if (radj >= Fp8.ORDER)\n          throw new Error(\"recovery id 2 or 3 invalid\");\n        const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n        const R = Point2.fromHex(prefix + numToNByteStr(radj));\n        const ir = invN(radj);\n        const u1 = modN(-h * ir);\n        const u2 = modN(s * ir);\n        const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);\n        if (!Q)\n          throw new Error(\"point at infinify\");\n        Q.assertValidity();\n        return Q;\n      }\n      // Signatures should be low-s, to prevent malleability.\n      hasHighS() {\n        return isBiggerThanHalfOrder(this.s);\n      }\n      normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n      }\n      // DER-encoded\n      toDERRawBytes() {\n        return hexToBytes(this.toDERHex());\n      }\n      toDERHex() {\n        return DER.hexFromSig({ r: this.r, s: this.s });\n      }\n      // padded bytes of r, then padded bytes of s\n      toCompactRawBytes() {\n        return hexToBytes(this.toCompactHex());\n      }\n      toCompactHex() {\n        return numToNByteStr(this.r) + numToNByteStr(this.s);\n      }\n    }\n    const utils2 = {\n      isValidPrivateKey(privateKey) {\n        try {\n          normPrivateKeyToScalar(privateKey);\n          return true;\n        } catch (error) {\n          return false;\n        }\n      },\n      normPrivateKeyToScalar,\n      /**\n       * Produces cryptographically secure private key from random of size (nBitLength+64)\n       * as per FIPS 186 B.4.1 with modulo bias being neglible.\n       */\n      randomPrivateKey: () => {\n        const rand = CURVE2.randomBytes(Fp8.BYTES + 8);\n        const num = hashToPrivateScalar(rand, CURVE_ORDER);\n        return numberToBytesBE(num, CURVE2.nByteLength);\n      },\n      /**\n       * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n       * Allows to massively speed-up \\`point.multiply(scalar)\\`.\n       * @returns cached point\n       * @example\n       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n       * fast.multiply(privKey); // much faster ECDH now\n       */\n      precompute(windowSize = 8, point = Point2.BASE) {\n        point._setWindowSize(windowSize);\n        point.multiply(BigInt(3));\n        return point;\n      }\n    };\n    function getPublicKey(privateKey, isCompressed = true) {\n      return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    function isProbPub(item) {\n      const arr = item instanceof Uint8Array;\n      const str = typeof item === \"string\";\n      const len = (arr || str) && item.length;\n      if (arr)\n        return len === compressedLen || len === uncompressedLen;\n      if (str)\n        return len === 2 * compressedLen || len === 2 * uncompressedLen;\n      if (item instanceof Point2)\n        return true;\n      return false;\n    }\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n      if (isProbPub(privateA))\n        throw new Error(\"first arg must be private key\");\n      if (!isProbPub(publicB))\n        throw new Error(\"second arg must be public key\");\n      const b = Point2.fromHex(publicB);\n      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    const bits2int = CURVE2.bits2int || function(bytes2) {\n      const num = bytesToNumberBE(bytes2);\n      const delta = bytes2.length * 8 - CURVE2.nBitLength;\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE2.bits2int_modN || function(bytes2) {\n      return modN(bits2int(bytes2));\n    };\n    const ORDER_MASK = bitMask(CURVE2.nBitLength);\n    function int2octets(num) {\n      if (typeof num !== \"bigint\")\n        throw new Error(\"bigint expected\");\n      if (!(_0n4 <= num && num < ORDER_MASK))\n        throw new Error(\\`bigint expected < 2^\\${CURVE2.nBitLength}\\`);\n      return numberToBytesBE(num, CURVE2.nByteLength);\n    }\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n      if ([\"recovered\", \"canonical\"].some((k) => k in opts))\n        throw new Error(\"sign() legacy options not supported\");\n      const { hash: hash2, randomBytes: randomBytes2 } = CURVE2;\n      let { lowS, prehash, extraEntropy: ent } = opts;\n      if (lowS == null)\n        lowS = true;\n      msgHash = ensureBytes(\"msgHash\", msgHash);\n      if (prehash)\n        msgHash = ensureBytes(\"prehashed msgHash\", hash2(msgHash));\n      const h1int = bits2int_modN(msgHash);\n      const d = normPrivateKeyToScalar(privateKey);\n      const seedArgs = [int2octets(d), int2octets(h1int)];\n      if (ent != null) {\n        const e = ent === true ? randomBytes2(Fp8.BYTES) : ent;\n        seedArgs.push(ensureBytes(\"extraEntropy\", e, Fp8.BYTES));\n      }\n      const seed = concatBytes(...seedArgs);\n      const m = h1int;\n      function k2sig(kBytes) {\n        const k = bits2int(kBytes);\n        if (!isWithinCurveOrder(k))\n          return;\n        const ik = invN(k);\n        const q = Point2.BASE.multiply(k).toAffine();\n        const r = modN(q.x);\n        if (r === _0n4)\n          return;\n        const s = modN(ik * modN(m + r * d));\n        if (s === _0n4)\n          return;\n        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);\n        let normS = s;\n        if (lowS && isBiggerThanHalfOrder(s)) {\n          normS = normalizeS(s);\n          recovery ^= 1;\n        }\n        return new Signature(r, normS, recovery);\n      }\n      return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE2.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE2.lowS, prehash: false };\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n      const { seed, k2sig } = prepSig(msgHash, privKey, opts);\n      const C = CURVE2;\n      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n      return drbg(seed, k2sig);\n    }\n    Point2.BASE._setWindowSize(8);\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n      const sg = signature;\n      msgHash = ensureBytes(\"msgHash\", msgHash);\n      publicKey = ensureBytes(\"publicKey\", publicKey);\n      if (\"strict\" in opts)\n        throw new Error(\"options.strict was renamed to lowS\");\n      const { lowS, prehash } = opts;\n      let _sig = void 0;\n      let P3;\n      try {\n        if (typeof sg === \"string\" || sg instanceof Uint8Array) {\n          try {\n            _sig = Signature.fromDER(sg);\n          } catch (derError) {\n            if (!(derError instanceof DER.Err))\n              throw derError;\n            _sig = Signature.fromCompact(sg);\n          }\n        } else if (typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\") {\n          const { r: r2, s: s2 } = sg;\n          _sig = new Signature(r2, s2);\n        } else {\n          throw new Error(\"PARSE\");\n        }\n        P3 = Point2.fromHex(publicKey);\n      } catch (error) {\n        if (error.message === \"PARSE\")\n          throw new Error(\\`signature must be Signature instance, Uint8Array or hex string\\`);\n        return false;\n      }\n      if (lowS && _sig.hasHighS())\n        return false;\n      if (prehash)\n        msgHash = CURVE2.hash(msgHash);\n      const { r, s } = _sig;\n      const h = bits2int_modN(msgHash);\n      const is = invN(s);\n      const u1 = modN(h * is);\n      const u2 = modN(r * is);\n      const R = Point2.BASE.multiplyAndAddUnsafe(P3, u1, u2)?.toAffine();\n      if (!R)\n        return false;\n      const v = modN(R.x);\n      return v === r;\n    }\n    return {\n      CURVE: CURVE2,\n      getPublicKey,\n      getSharedSecret,\n      sign,\n      verify,\n      ProjectivePoint: Point2,\n      Signature,\n      utils: utils2\n    };\n  }\n  function SWUFpSqrtRatio(Fp8, Z) {\n    const q = Fp8.ORDER;\n    let l = _0n4;\n    for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)\n      l += _1n4;\n    const c1 = l;\n    const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;\n    const c2 = (q - _1n4) / _2n_pow_c1;\n    const c3 = (c2 - _1n4) / _2n3;\n    const c4 = _2n_pow_c1 - _1n4;\n    const c5 = _2n_pow_c1_1;\n    const c6 = Fp8.pow(Z, c2);\n    const c7 = Fp8.pow(Z, (c2 + _1n4) / _2n3);\n    let sqrtRatio = (u, v) => {\n      let tv1 = c6;\n      let tv2 = Fp8.pow(v, c4);\n      let tv3 = Fp8.sqr(tv2);\n      tv3 = Fp8.mul(tv3, v);\n      let tv5 = Fp8.mul(u, tv3);\n      tv5 = Fp8.pow(tv5, c3);\n      tv5 = Fp8.mul(tv5, tv2);\n      tv2 = Fp8.mul(tv5, v);\n      tv3 = Fp8.mul(tv5, u);\n      let tv4 = Fp8.mul(tv3, tv2);\n      tv5 = Fp8.pow(tv4, c5);\n      let isQR = Fp8.eql(tv5, Fp8.ONE);\n      tv2 = Fp8.mul(tv3, c7);\n      tv5 = Fp8.mul(tv4, tv1);\n      tv3 = Fp8.cmov(tv2, tv3, isQR);\n      tv4 = Fp8.cmov(tv5, tv4, isQR);\n      for (let i = c1; i > _1n4; i--) {\n        let tv52 = i - _2n3;\n        tv52 = _2n3 << tv52 - _1n4;\n        let tvv5 = Fp8.pow(tv4, tv52);\n        const e1 = Fp8.eql(tvv5, Fp8.ONE);\n        tv2 = Fp8.mul(tv3, tv1);\n        tv1 = Fp8.mul(tv1, tv1);\n        tvv5 = Fp8.mul(tv4, tv1);\n        tv3 = Fp8.cmov(tv2, tv3, e1);\n        tv4 = Fp8.cmov(tvv5, tv4, e1);\n      }\n      return { isValid: isQR, value: tv3 };\n    };\n    if (Fp8.ORDER % _4n2 === _3n2) {\n      const c12 = (Fp8.ORDER - _3n2) / _4n2;\n      const c22 = Fp8.sqrt(Fp8.neg(Z));\n      sqrtRatio = (u, v) => {\n        let tv1 = Fp8.sqr(v);\n        const tv2 = Fp8.mul(u, v);\n        tv1 = Fp8.mul(tv1, tv2);\n        let y1 = Fp8.pow(tv1, c12);\n        y1 = Fp8.mul(y1, tv2);\n        const y2 = Fp8.mul(y1, c22);\n        const tv3 = Fp8.mul(Fp8.sqr(y1), v);\n        const isQR = Fp8.eql(tv3, u);\n        let y = Fp8.cmov(y2, y1, isQR);\n        return { isValid: isQR, value: y };\n      };\n    }\n    return sqrtRatio;\n  }\n  function mapToCurveSimpleSWU(Fp8, opts) {\n    validateField(Fp8);\n    if (!Fp8.isValid(opts.A) || !Fp8.isValid(opts.B) || !Fp8.isValid(opts.Z))\n      throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp8, opts.Z);\n    if (!Fp8.isOdd)\n      throw new Error(\"Fp.isOdd is not implemented!\");\n    return (u) => {\n      let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n      tv1 = Fp8.sqr(u);\n      tv1 = Fp8.mul(tv1, opts.Z);\n      tv2 = Fp8.sqr(tv1);\n      tv2 = Fp8.add(tv2, tv1);\n      tv3 = Fp8.add(tv2, Fp8.ONE);\n      tv3 = Fp8.mul(tv3, opts.B);\n      tv4 = Fp8.cmov(opts.Z, Fp8.neg(tv2), !Fp8.eql(tv2, Fp8.ZERO));\n      tv4 = Fp8.mul(tv4, opts.A);\n      tv2 = Fp8.sqr(tv3);\n      tv6 = Fp8.sqr(tv4);\n      tv5 = Fp8.mul(tv6, opts.A);\n      tv2 = Fp8.add(tv2, tv5);\n      tv2 = Fp8.mul(tv2, tv3);\n      tv6 = Fp8.mul(tv6, tv4);\n      tv5 = Fp8.mul(tv6, opts.B);\n      tv2 = Fp8.add(tv2, tv5);\n      x = Fp8.mul(tv1, tv3);\n      const { isValid, value } = sqrtRatio(tv2, tv6);\n      y = Fp8.mul(tv1, u);\n      y = Fp8.mul(y, value);\n      x = Fp8.cmov(x, tv3, isValid);\n      y = Fp8.cmov(y, value, isValid);\n      const e1 = Fp8.isOdd(u) === Fp8.isOdd(y);\n      y = Fp8.cmov(Fp8.neg(y), y, e1);\n      x = Fp8.div(x, tv4);\n      return { x, y };\n    };\n  }\n\n  // ../esm/abstract/hash-to-curve.js\n  function validateDST(dst) {\n    if (dst instanceof Uint8Array)\n      return dst;\n    if (typeof dst === \"string\")\n      return utf8ToBytes(dst);\n    throw new Error(\"DST must be Uint8Array or string\");\n  }\n  var os2ip = bytesToNumberBE;\n  function i2osp(value, length) {\n    if (value < 0 || value >= 1 << 8 * length) {\n      throw new Error(\\`bad I2OSP call: value=\\${value} length=\\${length}\\`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n      res[i] = value & 255;\n      value >>>= 8;\n    }\n    return new Uint8Array(res);\n  }\n  function strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n      arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n  }\n  function isBytes(item) {\n    if (!(item instanceof Uint8Array))\n      throw new Error(\"Uint8Array expected\");\n  }\n  function isNum(item) {\n    if (!Number.isSafeInteger(item))\n      throw new Error(\"number expected\");\n  }\n  function expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    if (DST.length > 255)\n      DST = H(concatBytes(utf8ToBytes(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n      throw new Error(\"Invalid xmd length\");\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2);\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n      const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n      b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n  }\n  function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    if (DST.length > 255) {\n      const dkLen = Math.ceil(2 * k / 8);\n      DST = H.create({ dkLen }).update(utf8ToBytes(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n      throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();\n  }\n  function hash_to_field(msg, count, options) {\n    validateObject(options, {\n      DST: \"string\",\n      p: \"bigint\",\n      m: \"isSafeInteger\",\n      k: \"isSafeInteger\",\n      hash: \"hash\"\n    });\n    const { p, k, m, hash: hash2, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8);\n    const len_in_bytes = count * m * L;\n    let prb;\n    if (expand === \"xmd\") {\n      prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);\n    } else if (expand === \"xof\") {\n      prb = expand_message_xof(msg, DST, len_in_bytes, k, hash2);\n    } else if (expand === \"_internal_pass\") {\n      prb = msg;\n    } else {\n      throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n      const e = new Array(m);\n      for (let j = 0; j < m; j++) {\n        const elm_offset = L * (j + i * m);\n        const tv = prb.subarray(elm_offset, elm_offset + L);\n        e[j] = mod(os2ip(tv), p);\n      }\n      u[i] = e;\n    }\n    return u;\n  }\n  function isogenyMap(field, map) {\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n      const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n      x = field.div(xNum, xDen);\n      y = field.mul(y, field.div(yNum, yDen));\n      return { x, y };\n    };\n  }\n  function createHasher(Point2, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\")\n      throw new Error(\"mapToCurve() must be defined\");\n    return {\n      // Encodes byte string to elliptic curve\n      // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n      hashToCurve(msg, options) {\n        const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n        const u0 = Point2.fromAffine(mapToCurve(u[0]));\n        const u1 = Point2.fromAffine(mapToCurve(u[1]));\n        const P3 = u0.add(u1).clearCofactor();\n        P3.assertValidity();\n        return P3;\n      },\n      // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n      encodeToCurve(msg, options) {\n        const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n        const P3 = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();\n        P3.assertValidity();\n        return P3;\n      }\n    };\n  }\n\n  // ../node_modules/@noble/hashes/esm/hmac.js\n  var HMAC = class extends Hash {\n    constructor(hash2, _key) {\n      super();\n      this.finished = false;\n      this.destroyed = false;\n      assert_default.hash(hash2);\n      const key = toBytes(_key);\n      this.iHash = hash2.create();\n      if (typeof this.iHash.update !== \"function\")\n        throw new Error(\"Expected instance of class which extends utils.Hash\");\n      this.blockLen = this.iHash.blockLen;\n      this.outputLen = this.iHash.outputLen;\n      const blockLen = this.blockLen;\n      const pad = new Uint8Array(blockLen);\n      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);\n      for (let i = 0; i < pad.length; i++)\n        pad[i] ^= 54;\n      this.iHash.update(pad);\n      this.oHash = hash2.create();\n      for (let i = 0; i < pad.length; i++)\n        pad[i] ^= 54 ^ 92;\n      this.oHash.update(pad);\n      pad.fill(0);\n    }\n    update(buf) {\n      assert_default.exists(this);\n      this.iHash.update(buf);\n      return this;\n    }\n    digestInto(out) {\n      assert_default.exists(this);\n      assert_default.bytes(out, this.outputLen);\n      this.finished = true;\n      this.iHash.digestInto(out);\n      this.oHash.update(out);\n      this.oHash.digestInto(out);\n      this.destroy();\n    }\n    digest() {\n      const out = new Uint8Array(this.oHash.outputLen);\n      this.digestInto(out);\n      return out;\n    }\n    _cloneInto(to) {\n      to || (to = Object.create(Object.getPrototypeOf(this), {}));\n      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n      to = to;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      to.blockLen = blockLen;\n      to.outputLen = outputLen;\n      to.oHash = oHash._cloneInto(to.oHash);\n      to.iHash = iHash._cloneInto(to.iHash);\n      return to;\n    }\n    destroy() {\n      this.destroyed = true;\n      this.oHash.destroy();\n      this.iHash.destroy();\n    }\n  };\n  var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();\n  hmac.create = (hash2, key) => new HMAC(hash2, key);\n\n  // ../esm/_shortw_utils.js\n  function getHash(hash2) {\n    return {\n      hash: hash2,\n      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes2(...msgs)),\n      randomBytes\n    };\n  }\n  function createCurve(curveDef, defHash) {\n    const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });\n    return Object.freeze({ ...create(defHash), create });\n  }\n\n  // ../esm/secp256k1.js\n  var secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\n  var secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n  var _1n5 = BigInt(1);\n  var _2n4 = BigInt(2);\n  var divNearest = (a, b) => (a + b / _2n4) / b;\n  function sqrtMod(y) {\n    const P3 = secp256k1P;\n    const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P3;\n    const b3 = b2 * b2 * y % P3;\n    const b6 = pow2(b3, _3n5, P3) * b3 % P3;\n    const b9 = pow2(b6, _3n5, P3) * b3 % P3;\n    const b11 = pow2(b9, _2n4, P3) * b2 % P3;\n    const b22 = pow2(b11, _11n, P3) * b11 % P3;\n    const b44 = pow2(b22, _22n, P3) * b22 % P3;\n    const b88 = pow2(b44, _44n, P3) * b44 % P3;\n    const b176 = pow2(b88, _88n, P3) * b88 % P3;\n    const b220 = pow2(b176, _44n, P3) * b44 % P3;\n    const b223 = pow2(b220, _3n5, P3) * b3 % P3;\n    const t1 = pow2(b223, _23n, P3) * b22 % P3;\n    const t2 = pow2(t1, _6n, P3) * b2 % P3;\n    const root = pow2(t2, _2n4, P3);\n    if (!Fp.eql(Fp.sqr(root), y))\n      throw new Error(\"Cannot find square root\");\n    return root;\n  }\n  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });\n  var secp256k1 = createCurve({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n      beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n      splitScalar: (k) => {\n        const n = secp256k1N;\n        const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n        const b1 = -_1n5 * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n        const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n        const b2 = a1;\n        const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\");\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg)\n          k1 = n - k1;\n        if (k2neg)\n          k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      }\n    }\n  }, sha256);\n  var _0n5 = BigInt(0);\n  var Point = secp256k1.ProjectivePoint;\n\n  // ../node_modules/@noble/hashes/esm/_u64.js\n  var U32_MASK64 = BigInt(2 ** 32 - 1);\n  var _32n = BigInt(32);\n  function fromBig(n, le = false) {\n    if (le)\n      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };\n    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n  }\n  function split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n      const { h, l } = fromBig(lst[i], le);\n      [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n  }\n  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n  var shrSH = (h, l, s) => h >>> s;\n  var shrSL = (h, l, s) => h << 32 - s | l >>> s;\n  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;\n  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;\n  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\n  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;\n  var rotr32H = (h, l) => l;\n  var rotr32L = (h, l) => h;\n  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;\n  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;\n  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\n  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\n  function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };\n  }\n  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\n  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\n  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n  var u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n  };\n  var u64_default = u64;\n\n  // ../node_modules/@noble/hashes/esm/sha512.js\n  var [SHA512_Kh, SHA512_Kl] = u64_default.split([\n    \"0x428a2f98d728ae22\",\n    \"0x7137449123ef65cd\",\n    \"0xb5c0fbcfec4d3b2f\",\n    \"0xe9b5dba58189dbbc\",\n    \"0x3956c25bf348b538\",\n    \"0x59f111f1b605d019\",\n    \"0x923f82a4af194f9b\",\n    \"0xab1c5ed5da6d8118\",\n    \"0xd807aa98a3030242\",\n    \"0x12835b0145706fbe\",\n    \"0x243185be4ee4b28c\",\n    \"0x550c7dc3d5ffb4e2\",\n    \"0x72be5d74f27b896f\",\n    \"0x80deb1fe3b1696b1\",\n    \"0x9bdc06a725c71235\",\n    \"0xc19bf174cf692694\",\n    \"0xe49b69c19ef14ad2\",\n    \"0xefbe4786384f25e3\",\n    \"0x0fc19dc68b8cd5b5\",\n    \"0x240ca1cc77ac9c65\",\n    \"0x2de92c6f592b0275\",\n    \"0x4a7484aa6ea6e483\",\n    \"0x5cb0a9dcbd41fbd4\",\n    \"0x76f988da831153b5\",\n    \"0x983e5152ee66dfab\",\n    \"0xa831c66d2db43210\",\n    \"0xb00327c898fb213f\",\n    \"0xbf597fc7beef0ee4\",\n    \"0xc6e00bf33da88fc2\",\n    \"0xd5a79147930aa725\",\n    \"0x06ca6351e003826f\",\n    \"0x142929670a0e6e70\",\n    \"0x27b70a8546d22ffc\",\n    \"0x2e1b21385c26c926\",\n    \"0x4d2c6dfc5ac42aed\",\n    \"0x53380d139d95b3df\",\n    \"0x650a73548baf63de\",\n    \"0x766a0abb3c77b2a8\",\n    \"0x81c2c92e47edaee6\",\n    \"0x92722c851482353b\",\n    \"0xa2bfe8a14cf10364\",\n    \"0xa81a664bbc423001\",\n    \"0xc24b8b70d0f89791\",\n    \"0xc76c51a30654be30\",\n    \"0xd192e819d6ef5218\",\n    \"0xd69906245565a910\",\n    \"0xf40e35855771202a\",\n    \"0x106aa07032bbd1b8\",\n    \"0x19a4c116b8d2d0c8\",\n    \"0x1e376c085141ab53\",\n    \"0x2748774cdf8eeb99\",\n    \"0x34b0bcb5e19b48a8\",\n    \"0x391c0cb3c5c95a63\",\n    \"0x4ed8aa4ae3418acb\",\n    \"0x5b9cca4f7763e373\",\n    \"0x682e6ff3d6b2b8a3\",\n    \"0x748f82ee5defb2fc\",\n    \"0x78a5636f43172f60\",\n    \"0x84c87814a1f0ab72\",\n    \"0x8cc702081a6439ec\",\n    \"0x90befffa23631e28\",\n    \"0xa4506cebde82bde9\",\n    \"0xbef9a3f7b2c67915\",\n    \"0xc67178f2e372532b\",\n    \"0xca273eceea26619c\",\n    \"0xd186b8c721c0c207\",\n    \"0xeada7dd6cde0eb1e\",\n    \"0xf57d4f7fee6ed178\",\n    \"0x06f067aa72176fba\",\n    \"0x0a637dc5a2c898a6\",\n    \"0x113f9804bef90dae\",\n    \"0x1b710b35131c471b\",\n    \"0x28db77f523047d84\",\n    \"0x32caab7b40c72493\",\n    \"0x3c9ebe0a15c9bebc\",\n    \"0x431d67c49c100d4c\",\n    \"0x4cc5d4becb3e42b6\",\n    \"0x597f299cfc657e2a\",\n    \"0x5fcb6fab3ad6faec\",\n    \"0x6c44198c4a475817\"\n  ].map((n) => BigInt(n)));\n  var SHA512_W_H = new Uint32Array(80);\n  var SHA512_W_L = new Uint32Array(80);\n  var SHA512 = class extends SHA2 {\n    constructor() {\n      super(128, 64, 16, false);\n      this.Ah = 1779033703 | 0;\n      this.Al = 4089235720 | 0;\n      this.Bh = 3144134277 | 0;\n      this.Bl = 2227873595 | 0;\n      this.Ch = 1013904242 | 0;\n      this.Cl = 4271175723 | 0;\n      this.Dh = 2773480762 | 0;\n      this.Dl = 1595750129 | 0;\n      this.Eh = 1359893119 | 0;\n      this.El = 2917565137 | 0;\n      this.Fh = 2600822924 | 0;\n      this.Fl = 725511199 | 0;\n      this.Gh = 528734635 | 0;\n      this.Gl = 4215389547 | 0;\n      this.Hh = 1541459225 | 0;\n      this.Hl = 327033209 | 0;\n    }\n    // prettier-ignore\n    get() {\n      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n      this.Ah = Ah | 0;\n      this.Al = Al | 0;\n      this.Bh = Bh | 0;\n      this.Bl = Bl | 0;\n      this.Ch = Ch | 0;\n      this.Cl = Cl | 0;\n      this.Dh = Dh | 0;\n      this.Dl = Dl | 0;\n      this.Eh = Eh | 0;\n      this.El = El | 0;\n      this.Fh = Fh | 0;\n      this.Fl = Fl | 0;\n      this.Gh = Gh | 0;\n      this.Gl = Gl | 0;\n      this.Hh = Hh | 0;\n      this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n      for (let i = 0; i < 16; i++, offset += 4) {\n        SHA512_W_H[i] = view.getUint32(offset);\n        SHA512_W_L[i] = view.getUint32(offset += 4);\n      }\n      for (let i = 16; i < 80; i++) {\n        const W15h = SHA512_W_H[i - 15] | 0;\n        const W15l = SHA512_W_L[i - 15] | 0;\n        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);\n        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);\n        const W2h = SHA512_W_H[i - 2] | 0;\n        const W2l = SHA512_W_L[i - 2] | 0;\n        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);\n        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);\n        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n        SHA512_W_H[i] = SUMh | 0;\n        SHA512_W_L[i] = SUMl | 0;\n      }\n      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n      for (let i = 0; i < 80; i++) {\n        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);\n        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);\n        const CHIh = Eh & Fh ^ ~Eh & Gh;\n        const CHIl = El & Fl ^ ~El & Gl;\n        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n        const T1l = T1ll | 0;\n        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);\n        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);\n        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n        Hh = Gh | 0;\n        Hl = Gl | 0;\n        Gh = Fh | 0;\n        Gl = Fl | 0;\n        Fh = Eh | 0;\n        Fl = El | 0;\n        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n        Dh = Ch | 0;\n        Dl = Cl | 0;\n        Ch = Bh | 0;\n        Cl = Bl | 0;\n        Bh = Ah | 0;\n        Bl = Al | 0;\n        const All = u64_default.add3L(T1l, sigma0l, MAJl);\n        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);\n        Al = All | 0;\n      }\n      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n      SHA512_W_H.fill(0);\n      SHA512_W_L.fill(0);\n    }\n    destroy() {\n      this.buffer.fill(0);\n      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n  };\n  var SHA512_224 = class extends SHA512 {\n    constructor() {\n      super();\n      this.Ah = 2352822216 | 0;\n      this.Al = 424955298 | 0;\n      this.Bh = 1944164710 | 0;\n      this.Bl = 2312950998 | 0;\n      this.Ch = 502970286 | 0;\n      this.Cl = 855612546 | 0;\n      this.Dh = 1738396948 | 0;\n      this.Dl = 1479516111 | 0;\n      this.Eh = 258812777 | 0;\n      this.El = 2077511080 | 0;\n      this.Fh = 2011393907 | 0;\n      this.Fl = 79989058 | 0;\n      this.Gh = 1067287976 | 0;\n      this.Gl = 1780299464 | 0;\n      this.Hh = 286451373 | 0;\n      this.Hl = 2446758561 | 0;\n      this.outputLen = 28;\n    }\n  };\n  var SHA512_256 = class extends SHA512 {\n    constructor() {\n      super();\n      this.Ah = 573645204 | 0;\n      this.Al = 4230739756 | 0;\n      this.Bh = 2673172387 | 0;\n      this.Bl = 3360449730 | 0;\n      this.Ch = 596883563 | 0;\n      this.Cl = 1867755857 | 0;\n      this.Dh = 2520282905 | 0;\n      this.Dl = 1497426621 | 0;\n      this.Eh = 2519219938 | 0;\n      this.El = 2827943907 | 0;\n      this.Fh = 3193839141 | 0;\n      this.Fl = 1401305490 | 0;\n      this.Gh = 721525244 | 0;\n      this.Gl = 746961066 | 0;\n      this.Hh = 246885852 | 0;\n      this.Hl = 2177182882 | 0;\n      this.outputLen = 32;\n    }\n  };\n  var SHA384 = class extends SHA512 {\n    constructor() {\n      super();\n      this.Ah = 3418070365 | 0;\n      this.Al = 3238371032 | 0;\n      this.Bh = 1654270250 | 0;\n      this.Bl = 914150663 | 0;\n      this.Ch = 2438529370 | 0;\n      this.Cl = 812702999 | 0;\n      this.Dh = 355462360 | 0;\n      this.Dl = 4144912697 | 0;\n      this.Eh = 1731405415 | 0;\n      this.El = 4290775857 | 0;\n      this.Fh = 2394180231 | 0;\n      this.Fl = 1750603025 | 0;\n      this.Gh = 3675008525 | 0;\n      this.Gl = 1694076839 | 0;\n      this.Hh = 1203062813 | 0;\n      this.Hl = 3204075428 | 0;\n      this.outputLen = 48;\n    }\n  };\n  var sha512 = wrapConstructor(() => new SHA512());\n  var sha512_224 = wrapConstructor(() => new SHA512_224());\n  var sha512_256 = wrapConstructor(() => new SHA512_256());\n  var sha384 = wrapConstructor(() => new SHA384());\n\n  // ../esm/abstract/edwards.js\n  var _0n6 = BigInt(0);\n  var _1n6 = BigInt(1);\n  var _2n5 = BigInt(2);\n  var _8n2 = BigInt(8);\n  var VERIFY_DEFAULT = { zip215: true };\n  function validateOpts2(curve) {\n    const opts = validateBasic(curve);\n    validateObject(curve, {\n      hash: \"function\",\n      a: \"bigint\",\n      d: \"bigint\",\n      randomBytes: \"function\"\n    }, {\n      adjustScalarBytes: \"function\",\n      domain: \"function\",\n      uvRatio: \"function\",\n      mapToCurve: \"function\"\n    });\n    return Object.freeze({ ...opts });\n  }\n  function twistedEdwards(curveDef) {\n    const CURVE2 = validateOpts2(curveDef);\n    const { Fp: Fp8, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE2;\n    const MASK = _2n5 << BigInt(nByteLength * 8) - _1n6;\n    const modP = Fp8.create;\n    const uvRatio2 = CURVE2.uvRatio || ((u, v) => {\n      try {\n        return { isValid: true, value: Fp8.sqrt(u * Fp8.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n6 };\n      }\n    });\n    const adjustScalarBytes3 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);\n    const domain = CURVE2.domain || ((data, ctx, phflag) => {\n      if (ctx.length || phflag)\n        throw new Error(\"Contexts/pre-hash are not supported\");\n      return data;\n    });\n    const inBig = (n) => typeof n === \"bigint\" && _0n6 < n;\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max;\n    const in0MaskRange = (n) => n === _0n6 || inRange(n, MASK);\n    function assertInRange(n, max) {\n      if (inRange(n, max))\n        return n;\n      throw new Error(\\`Expected valid scalar < \\${max}, got \\${typeof n} \\${n}\\`);\n    }\n    function assertGE0(n) {\n      return n === _0n6 ? n : assertInRange(n, CURVE_ORDER);\n    }\n    const pointPrecomputes = /* @__PURE__ */ new Map();\n    function isPoint(other) {\n      if (!(other instanceof Point2))\n        throw new Error(\"ExtendedPoint expected\");\n    }\n    class Point2 {\n      constructor(ex, ey, ez, et) {\n        this.ex = ex;\n        this.ey = ey;\n        this.ez = ez;\n        this.et = et;\n        if (!in0MaskRange(ex))\n          throw new Error(\"x required\");\n        if (!in0MaskRange(ey))\n          throw new Error(\"y required\");\n        if (!in0MaskRange(ez))\n          throw new Error(\"z required\");\n        if (!in0MaskRange(et))\n          throw new Error(\"t required\");\n      }\n      get x() {\n        return this.toAffine().x;\n      }\n      get y() {\n        return this.toAffine().y;\n      }\n      static fromAffine(p) {\n        if (p instanceof Point2)\n          throw new Error(\"extended point not allowed\");\n        const { x, y } = p || {};\n        if (!in0MaskRange(x) || !in0MaskRange(y))\n          throw new Error(\"invalid affine point\");\n        return new Point2(x, y, _1n6, modP(x * y));\n      }\n      static normalizeZ(points) {\n        const toInv = Fp8.invertBatch(points.map((p) => p.ez));\n        return points.map((p, i) => p.toAffine(toInv[i])).map(Point2.fromAffine);\n      }\n      // \"Private method\", don't use it directly\n      _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n      }\n      // Not required for fromHex(), which always creates valid points.\n      // Could be useful for fromAffine().\n      assertValidity() {\n        const { a, d } = CURVE2;\n        if (this.is0())\n          throw new Error(\"bad point: ZERO\");\n        const { ex: X, ey: Y, ez: Z, et: T } = this;\n        const X2 = modP(X * X);\n        const Y2 = modP(Y * Y);\n        const Z2 = modP(Z * Z);\n        const Z4 = modP(Z2 * Z2);\n        const aX2 = modP(X2 * a);\n        const left = modP(Z2 * modP(aX2 + Y2));\n        const right = modP(Z4 + modP(d * modP(X2 * Y2)));\n        if (left !== right)\n          throw new Error(\"bad point: equation left != right (1)\");\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n          throw new Error(\"bad point: equation left != right (2)\");\n      }\n      // Compare one point to another.\n      equals(other) {\n        isPoint(other);\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2 } = other;\n        const X1Z2 = modP(X1 * Z2);\n        const X2Z1 = modP(X2 * Z1);\n        const Y1Z2 = modP(Y1 * Z2);\n        const Y2Z1 = modP(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n      }\n      is0() {\n        return this.equals(Point2.ZERO);\n      }\n      negate() {\n        return new Point2(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n      }\n      // Fast algo for doubling Extended Point.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n      // Cost: 4M + 4S + 1*a + 6add + 1*2.\n      double() {\n        const { a } = CURVE2;\n        const { ex: X1, ey: Y1, ez: Z1 } = this;\n        const A = modP(X1 * X1);\n        const B = modP(Y1 * Y1);\n        const C = modP(_2n5 * modP(Z1 * Z1));\n        const D = modP(a * A);\n        const x1y1 = X1 + Y1;\n        const E = modP(modP(x1y1 * x1y1) - A - B);\n        const G2 = D + B;\n        const F = G2 - C;\n        const H = D - B;\n        const X3 = modP(E * F);\n        const Y3 = modP(G2 * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G2);\n        return new Point2(X3, Y3, Z3, T3);\n      }\n      // Fast algo for adding 2 Extended Points.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n      // Cost: 9M + 1*a + 1*d + 7add.\n      add(other) {\n        isPoint(other);\n        const { a, d } = CURVE2;\n        const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n        const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n        if (a === BigInt(-1)) {\n          const A2 = modP((Y1 - X1) * (Y2 + X2));\n          const B2 = modP((Y1 + X1) * (Y2 - X2));\n          const F2 = modP(B2 - A2);\n          if (F2 === _0n6)\n            return this.double();\n          const C2 = modP(Z1 * _2n5 * T2);\n          const D2 = modP(T1 * _2n5 * Z2);\n          const E2 = D2 + C2;\n          const G3 = B2 + A2;\n          const H2 = D2 - C2;\n          const X32 = modP(E2 * F2);\n          const Y32 = modP(G3 * H2);\n          const T32 = modP(E2 * H2);\n          const Z32 = modP(F2 * G3);\n          return new Point2(X32, Y32, Z32, T32);\n        }\n        const A = modP(X1 * X2);\n        const B = modP(Y1 * Y2);\n        const C = modP(T1 * d * T2);\n        const D = modP(Z1 * Z2);\n        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = D - C;\n        const G2 = D + C;\n        const H = modP(B - a * A);\n        const X3 = modP(E * F);\n        const Y3 = modP(G2 * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G2);\n        return new Point2(X3, Y3, Z3, T3);\n      }\n      subtract(other) {\n        return this.add(other.negate());\n      }\n      wNAF(n) {\n        return wnaf.wNAFCached(this, pointPrecomputes, n, Point2.normalizeZ);\n      }\n      // Constant-time multiplication.\n      multiply(scalar) {\n        const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n        return Point2.normalizeZ([p, f])[0];\n      }\n      // Non-constant-time multiplication. Uses double-and-add algorithm.\n      // It's faster, but should only be used when you don't care about\n      // an exposed private key e.g. sig verification.\n      // Does NOT allow scalars higher than CURVE.n.\n      multiplyUnsafe(scalar) {\n        let n = assertGE0(scalar);\n        if (n === _0n6)\n          return I;\n        if (this.equals(I) || n === _1n6)\n          return this;\n        if (this.equals(G))\n          return this.wNAF(n).p;\n        return wnaf.unsafeLadder(this, n);\n      }\n      // Checks if point is of small order.\n      // If you add something to small order point, you will have \"dirty\"\n      // point with torsion component.\n      // Multiplies point by cofactor and checks if the result is 0.\n      isSmallOrder() {\n        return this.multiplyUnsafe(cofactor).is0();\n      }\n      // Multiplies point by curve order and checks if the result is 0.\n      // Returns \\`false\\` is the point is dirty.\n      isTorsionFree() {\n        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n      }\n      // Converts Extended point to default (x, y) coordinates.\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\n      toAffine(iz) {\n        const { ex: x, ey: y, ez: z } = this;\n        const is0 = this.is0();\n        if (iz == null)\n          iz = is0 ? _8n2 : Fp8.inv(z);\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n          return { x: _0n6, y: _1n6 };\n        if (zz !== _1n6)\n          throw new Error(\"invZ was invalid\");\n        return { x: ax, y: ay };\n      }\n      clearCofactor() {\n        const { h: cofactor2 } = CURVE2;\n        if (cofactor2 === _1n6)\n          return this;\n        return this.multiplyUnsafe(cofactor2);\n      }\n      // Converts hash string or Uint8Array to Point.\n      // Uses algo from RFC8032 5.1.3.\n      static fromHex(hex, zip215 = false) {\n        const { d, a } = CURVE2;\n        const len = Fp8.BYTES;\n        hex = ensureBytes(\"pointHex\", hex, len);\n        const normed = hex.slice();\n        const lastByte = hex[len - 1];\n        normed[len - 1] = lastByte & ~128;\n        const y = bytesToNumberLE(normed);\n        if (y === _0n6) {\n        } else {\n          if (zip215)\n            assertInRange(y, MASK);\n          else\n            assertInRange(y, Fp8.ORDER);\n        }\n        const y2 = modP(y * y);\n        const u = modP(y2 - _1n6);\n        const v = modP(d * y2 - a);\n        let { isValid, value: x } = uvRatio2(u, v);\n        if (!isValid)\n          throw new Error(\"Point.fromHex: invalid y coordinate\");\n        const isXOdd = (x & _1n6) === _1n6;\n        const isLastByteOdd = (lastByte & 128) !== 0;\n        if (!zip215 && x === _0n6 && isLastByteOdd)\n          throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n        if (isLastByteOdd !== isXOdd)\n          x = modP(-x);\n        return Point2.fromAffine({ x, y });\n      }\n      static fromPrivateKey(privKey) {\n        return getExtendedPublicKey(privKey).point;\n      }\n      toRawBytes() {\n        const { x, y } = this.toAffine();\n        const bytes2 = numberToBytesLE(y, Fp8.BYTES);\n        bytes2[bytes2.length - 1] |= x & _1n6 ? 128 : 0;\n        return bytes2;\n      }\n      toHex() {\n        return bytesToHex(this.toRawBytes());\n      }\n    }\n    Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy, _1n6, modP(CURVE2.Gx * CURVE2.Gy));\n    Point2.ZERO = new Point2(_0n6, _1n6, _1n6, _0n6);\n    const { BASE: G, ZERO: I } = Point2;\n    const wnaf = wNAF(Point2, nByteLength * 8);\n    function modN(a) {\n      return mod(a, CURVE_ORDER);\n    }\n    function modN_LE(hash2) {\n      return modN(bytesToNumberLE(hash2));\n    }\n    function getExtendedPublicKey(key) {\n      const len = nByteLength;\n      key = ensureBytes(\"private key\", key, len);\n      const hashed = ensureBytes(\"hashed private key\", cHash(key), 2 * len);\n      const head = adjustScalarBytes3(hashed.slice(0, len));\n      const prefix = hashed.slice(len, 2 * len);\n      const scalar = modN_LE(head);\n      const point = G.multiply(scalar);\n      const pointBytes = point.toRawBytes();\n      return { head, prefix, scalar, point, pointBytes };\n    }\n    function getPublicKey(privKey) {\n      return getExtendedPublicKey(privKey).pointBytes;\n    }\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n      const msg = concatBytes(...msgs);\n      return modN_LE(cHash(domain(msg, ensureBytes(\"context\", context), !!prehash)));\n    }\n    function sign(msg, privKey, options = {}) {\n      msg = ensureBytes(\"message\", msg);\n      if (prehash)\n        msg = prehash(msg);\n      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n      const r = hashDomainToScalar(options.context, prefix, msg);\n      const R = G.multiply(r).toRawBytes();\n      const k = hashDomainToScalar(options.context, R, pointBytes, msg);\n      const s = modN(r + k * scalar);\n      assertGE0(s);\n      const res = concatBytes(R, numberToBytesLE(s, Fp8.BYTES));\n      return ensureBytes(\"result\", res, nByteLength * 2);\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n      const { context, zip215 } = options;\n      const len = Fp8.BYTES;\n      sig = ensureBytes(\"signature\", sig, 2 * len);\n      msg = ensureBytes(\"message\", msg);\n      if (prehash)\n        msg = prehash(msg);\n      const s = bytesToNumberLE(sig.slice(len, 2 * len));\n      let A, R, SB;\n      try {\n        A = Point2.fromHex(publicKey, zip215);\n        R = Point2.fromHex(sig.slice(0, len), zip215);\n        SB = G.multiplyUnsafe(s);\n      } catch (error) {\n        return false;\n      }\n      if (!zip215 && A.isSmallOrder())\n        return false;\n      const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n      const RkA = R.add(A.multiplyUnsafe(k));\n      return RkA.subtract(SB).clearCofactor().equals(Point2.ZERO);\n    }\n    G._setWindowSize(8);\n    const utils2 = {\n      getExtendedPublicKey,\n      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n      randomPrivateKey: () => randomBytes2(Fp8.BYTES),\n      /**\n       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n       * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n       * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n       * @param windowSize 2, 4, 8, 16\n       */\n      precompute(windowSize = 8, point = Point2.BASE) {\n        point._setWindowSize(windowSize);\n        point.multiply(BigInt(3));\n        return point;\n      }\n    };\n    return {\n      CURVE: CURVE2,\n      getPublicKey,\n      sign,\n      verify,\n      ExtendedPoint: Point2,\n      utils: utils2\n    };\n  }\n\n  // ../esm/abstract/montgomery.js\n  var _0n7 = BigInt(0);\n  var _1n7 = BigInt(1);\n  function validateOpts3(curve) {\n    validateObject(curve, {\n      a: \"bigint\"\n    }, {\n      montgomeryBits: \"isSafeInteger\",\n      nByteLength: \"isSafeInteger\",\n      adjustScalarBytes: \"function\",\n      domain: \"function\",\n      powPminus2: \"function\",\n      Gu: \"bigint\"\n    });\n    return Object.freeze({ ...curve });\n  }\n  function montgomery(curveDef) {\n    const CURVE2 = validateOpts3(curveDef);\n    const { P: P3 } = CURVE2;\n    const modP = (n) => mod(n, P3);\n    const montgomeryBits = CURVE2.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE2.nByteLength;\n    const adjustScalarBytes3 = CURVE2.adjustScalarBytes || ((bytes2) => bytes2);\n    const powPminus2 = CURVE2.powPminus2 || ((x) => pow(x, P3 - BigInt(2), P3));\n    function cswap(swap, x_2, x_3) {\n      const dummy = modP(swap * (x_2 - x_3));\n      x_2 = modP(x_2 - dummy);\n      x_3 = modP(x_3 + dummy);\n      return [x_2, x_3];\n    }\n    function assertFieldElement(n) {\n      if (typeof n === \"bigint\" && _0n7 <= n && n < P3)\n        return n;\n      throw new Error(\"Expected valid scalar 0 < scalar < CURVE.P\");\n    }\n    const a24 = (CURVE2.a - BigInt(2)) / BigInt(4);\n    function montgomeryLadder(pointU, scalar) {\n      const u = assertFieldElement(pointU);\n      const k = assertFieldElement(scalar);\n      const x_1 = u;\n      let x_2 = _1n7;\n      let z_2 = _0n7;\n      let x_3 = u;\n      let z_3 = _1n7;\n      let swap = _0n7;\n      let sw;\n      for (let t = BigInt(montgomeryBits - 1); t >= _0n7; t--) {\n        const k_t = k >> t & _1n7;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = modP(A * A);\n        const B = x_2 - z_2;\n        const BB = modP(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = modP(D * A);\n        const CB = modP(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = modP(dacb * dacb);\n        z_3 = modP(x_1 * modP(da_cb * da_cb));\n        x_2 = modP(AA * BB);\n        z_2 = modP(E * (AA + modP(a24 * E)));\n      }\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      const z2 = powPminus2(z_2);\n      return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n      return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n      const u = ensureBytes(\"u coordinate\", uEnc, montgomeryBytes);\n      if (fieldLen === montgomeryBytes)\n        u[fieldLen - 1] &= 127;\n      return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n      const bytes2 = ensureBytes(\"scalar\", n);\n      if (bytes2.length !== montgomeryBytes && bytes2.length !== fieldLen)\n        throw new Error(\\`Expected \\${montgomeryBytes} or \\${fieldLen} bytes, got \\${\n  bytes2.length\n}\\`);\n      return bytesToNumberLE(adjustScalarBytes3(bytes2));\n    }\n    function scalarMult(scalar, u) {\n      const pointU = decodeUCoordinate(u);\n      const _scalar = decodeScalar(scalar);\n      const pu = montgomeryLadder(pointU, _scalar);\n      if (pu === _0n7)\n        throw new Error(\"Invalid private or public key received\");\n      return encodeUCoordinate(pu);\n    }\n    const GuBytes = encodeUCoordinate(CURVE2.Gu);\n    function scalarMultBase(scalar) {\n      return scalarMult(scalar, GuBytes);\n    }\n    return {\n      scalarMult,\n      scalarMultBase,\n      getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n      getPublicKey: (privateKey) => scalarMultBase(privateKey),\n      utils: { randomPrivateKey: () => CURVE2.randomBytes(CURVE2.nByteLength) },\n      GuBytes\n    };\n  }\n\n  // ../esm/ed25519.js\n  var ED25519_P = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\");\n  var ED25519_SQRT_M1 = BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n  var _0n8 = BigInt(0);\n  var _1n8 = BigInt(1);\n  var _2n6 = BigInt(2);\n  var _5n2 = BigInt(5);\n  var _10n = BigInt(10);\n  var _20n = BigInt(20);\n  var _40n = BigInt(40);\n  var _80n = BigInt(80);\n  function ed25519_pow_2_252_3(x) {\n    const P3 = ED25519_P;\n    const x2 = x * x % P3;\n    const b2 = x2 * x % P3;\n    const b4 = pow2(b2, _2n6, P3) * b2 % P3;\n    const b5 = pow2(b4, _1n8, P3) * x % P3;\n    const b10 = pow2(b5, _5n2, P3) * b5 % P3;\n    const b20 = pow2(b10, _10n, P3) * b10 % P3;\n    const b40 = pow2(b20, _20n, P3) * b20 % P3;\n    const b80 = pow2(b40, _40n, P3) * b40 % P3;\n    const b160 = pow2(b80, _80n, P3) * b80 % P3;\n    const b240 = pow2(b160, _80n, P3) * b80 % P3;\n    const b250 = pow2(b240, _10n, P3) * b10 % P3;\n    const pow_p_5_8 = pow2(b250, _2n6, P3) * x % P3;\n    return { pow_p_5_8, b2 };\n  }\n  function adjustScalarBytes(bytes2) {\n    bytes2[0] &= 248;\n    bytes2[31] &= 127;\n    bytes2[31] |= 64;\n    return bytes2;\n  }\n  function uvRatio(u, v) {\n    const P3 = ED25519_P;\n    const v3 = mod(v * v * v, P3);\n    const v7 = mod(v3 * v3 * v, P3);\n    const pow3 = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow3, P3);\n    const vx2 = mod(v * x * x, P3);\n    const root1 = x;\n    const root2 = mod(x * ED25519_SQRT_M1, P3);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u, P3);\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P3);\n    if (useRoot1)\n      x = root1;\n    if (useRoot2 || noRoot)\n      x = root2;\n    if (isNegativeLE(x, P3))\n      x = mod(-x, P3);\n    return { isValid: useRoot1 || useRoot2, value: x };\n  }\n  var Fp2 = Field(ED25519_P, void 0, true);\n  var ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1),\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n    // Finite field \ud835\udd3dp over which we'll do calculations; 2n**255n - 19n\n    Fp: Fp2,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\"),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n    Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\"),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/\u221av\n    uvRatio\n  };\n  var ed25519 = twistedEdwards(ed25519Defaults);\n  function ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n      throw new Error(\"Context is too big\");\n    return concatBytes2(utf8ToBytes2(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n  }\n  var ed25519ctx = twistedEdwards({ ...ed25519Defaults, domain: ed25519_domain });\n  var ed25519ph = twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: sha512\n  });\n  var x25519 = /* @__PURE__ */ (() => montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255,\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n      const P3 = ED25519_P;\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, BigInt(3), P3) * b2, P3);\n    },\n    adjustScalarBytes,\n    randomBytes\n  }))();\n  var ELL2_C1 = (Fp2.ORDER + BigInt(3)) / BigInt(8);\n  var ELL2_C2 = Fp2.pow(_2n6, ELL2_C1);\n  var ELL2_C3 = Fp2.sqrt(Fp2.neg(Fp2.ONE));\n  var ELL2_C4 = (Fp2.ORDER - BigInt(5)) / BigInt(8);\n  var ELL2_J = BigInt(486662);\n  var ELL2_C1_EDWARDS = FpSqrtEven(Fp2, Fp2.neg(BigInt(486664)));\n  var SQRT_AD_MINUS_ONE = BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n  var INVSQRT_A_MINUS_D = BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n  var ONE_MINUS_D_SQ = BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n  var D_MINUS_ONE_SQ = BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n  var MAX_255B = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\n  // ../node_modules/@noble/hashes/esm/sha3.js\n  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\n  var _0n9 = BigInt(0);\n  var _1n9 = BigInt(1);\n  var _2n7 = BigInt(2);\n  var _7n = BigInt(7);\n  var _256n = BigInt(256);\n  var _0x71n = BigInt(113);\n  for (let round = 0, R = _1n9, x = 1, y = 0; round < 24; round++) {\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    let t = _0n9;\n    for (let j = 0; j < 7; j++) {\n      R = (R << _1n9 ^ (R >> _7n) * _0x71n) % _256n;\n      if (R & _2n7)\n        t ^= _1n9 << (_1n9 << BigInt(j)) - _1n9;\n    }\n    _SHA3_IOTA.push(t);\n  }\n  var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);\n  var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);\n  var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);\n  function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    for (let round = 24 - rounds; round < 24; round++) {\n      for (let x = 0; x < 10; x++)\n        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n      for (let x = 0; x < 10; x += 2) {\n        const idx1 = (x + 8) % 10;\n        const idx0 = (x + 2) % 10;\n        const B0 = B[idx0];\n        const B1 = B[idx0 + 1];\n        const Th = rotlH(B0, B1, 1) ^ B[idx1];\n        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n        for (let y = 0; y < 50; y += 10) {\n          s[x + y] ^= Th;\n          s[x + y + 1] ^= Tl;\n        }\n      }\n      let curH = s[2];\n      let curL = s[3];\n      for (let t = 0; t < 24; t++) {\n        const shift = SHA3_ROTL[t];\n        const Th = rotlH(curH, curL, shift);\n        const Tl = rotlL(curH, curL, shift);\n        const PI = SHA3_PI[t];\n        curH = s[PI];\n        curL = s[PI + 1];\n        s[PI] = Th;\n        s[PI + 1] = Tl;\n      }\n      for (let y = 0; y < 50; y += 10) {\n        for (let x = 0; x < 10; x++)\n          B[x] = s[y + x];\n        for (let x = 0; x < 10; x++)\n          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n      }\n      s[0] ^= SHA3_IOTA_H[round];\n      s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n  }\n  var Keccak = class extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n      super();\n      this.blockLen = blockLen;\n      this.suffix = suffix;\n      this.outputLen = outputLen;\n      this.enableXOF = enableXOF;\n      this.rounds = rounds;\n      this.pos = 0;\n      this.posOut = 0;\n      this.finished = false;\n      this.destroyed = false;\n      assert_default.number(outputLen);\n      if (0 >= this.blockLen || this.blockLen >= 200)\n        throw new Error(\"Sha3 supports only keccak-f1600 function\");\n      this.state = new Uint8Array(200);\n      this.state32 = u32(this.state);\n    }\n    keccak() {\n      keccakP(this.state32, this.rounds);\n      this.posOut = 0;\n      this.pos = 0;\n    }\n    update(data) {\n      assert_default.exists(this);\n      const { blockLen, state } = this;\n      data = toBytes(data);\n      const len = data.length;\n      for (let pos = 0; pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        for (let i = 0; i < take; i++)\n          state[this.pos++] ^= data[pos++];\n        if (this.pos === blockLen)\n          this.keccak();\n      }\n      return this;\n    }\n    finish() {\n      if (this.finished)\n        return;\n      this.finished = true;\n      const { state, suffix, pos, blockLen } = this;\n      state[pos] ^= suffix;\n      if ((suffix & 128) !== 0 && pos === blockLen - 1)\n        this.keccak();\n      state[blockLen - 1] ^= 128;\n      this.keccak();\n    }\n    writeInto(out) {\n      assert_default.exists(this, false);\n      assert_default.bytes(out);\n      this.finish();\n      const bufferOut = this.state;\n      const { blockLen } = this;\n      for (let pos = 0, len = out.length; pos < len; ) {\n        if (this.posOut >= blockLen)\n          this.keccak();\n        const take = Math.min(blockLen - this.posOut, len - pos);\n        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n        this.posOut += take;\n        pos += take;\n      }\n      return out;\n    }\n    xofInto(out) {\n      if (!this.enableXOF)\n        throw new Error(\"XOF is not possible for this instance\");\n      return this.writeInto(out);\n    }\n    xof(bytes2) {\n      assert_default.number(bytes2);\n      return this.xofInto(new Uint8Array(bytes2));\n    }\n    digestInto(out) {\n      assert_default.output(out, this);\n      if (this.finished)\n        throw new Error(\"digest() was already called\");\n      this.writeInto(out);\n      this.destroy();\n      return out;\n    }\n    digest() {\n      return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n      this.destroyed = true;\n      this.state.fill(0);\n    }\n    _cloneInto(to) {\n      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n      to.state32.set(this.state32);\n      to.pos = this.pos;\n      to.posOut = this.posOut;\n      to.finished = this.finished;\n      to.rounds = rounds;\n      to.suffix = suffix;\n      to.outputLen = outputLen;\n      to.enableXOF = enableXOF;\n      to.destroyed = this.destroyed;\n      return to;\n    }\n  };\n  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n  var sha3_224 = gen(6, 144, 224 / 8);\n  var sha3_256 = gen(6, 136, 256 / 8);\n  var sha3_384 = gen(6, 104, 384 / 8);\n  var sha3_512 = gen(6, 72, 512 / 8);\n  var keccak_224 = gen(1, 144, 224 / 8);\n  var keccak_256 = gen(1, 136, 256 / 8);\n  var keccak_384 = gen(1, 104, 384 / 8);\n  var keccak_512 = gen(1, 72, 512 / 8);\n  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));\n  var shake128 = genShake(31, 168, 128 / 8);\n  var shake256 = genShake(31, 136, 256 / 8);\n\n  // ../esm/ed448.js\n  var shake256_114 = wrapConstructor(() => shake256.create({ dkLen: 114 }));\n  var shake256_64 = wrapConstructor(() => shake256.create({ dkLen: 64 }));\n  var ed448P = BigInt(\"726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439\");\n  function ed448_pow_Pminus3div4(x) {\n    const P3 = ed448P;\n    const _1n11 = BigInt(1), _2n10 = BigInt(2), _3n5 = BigInt(3), _11n = BigInt(11);\n    const _22n = BigInt(22), _44n = BigInt(44), _88n = BigInt(88), _223n = BigInt(223);\n    const b2 = x * x * x % P3;\n    const b3 = b2 * b2 * x % P3;\n    const b6 = pow2(b3, _3n5, P3) * b3 % P3;\n    const b9 = pow2(b6, _3n5, P3) * b3 % P3;\n    const b11 = pow2(b9, _2n10, P3) * b2 % P3;\n    const b22 = pow2(b11, _11n, P3) * b11 % P3;\n    const b44 = pow2(b22, _22n, P3) * b22 % P3;\n    const b88 = pow2(b44, _44n, P3) * b44 % P3;\n    const b176 = pow2(b88, _88n, P3) * b88 % P3;\n    const b220 = pow2(b176, _44n, P3) * b44 % P3;\n    const b222 = pow2(b220, _2n10, P3) * b2 % P3;\n    const b223 = pow2(b222, _1n11, P3) * x % P3;\n    return pow2(b223, _223n, P3) * b222 % P3;\n  }\n  function adjustScalarBytes2(bytes2) {\n    bytes2[0] &= 252;\n    bytes2[55] |= 128;\n    bytes2[56] = 0;\n    return bytes2;\n  }\n  var Fp3 = Field(ed448P, 456, true);\n  var _4n3 = BigInt(4);\n  var ED448_DEF = {\n    // Param: a\n    a: BigInt(1),\n    // -39081. Negative number is P - number\n    d: BigInt(\"726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018326358\"),\n    // Finite field \ud835\udd3dp over which we'll do calculations; 2n**448n - 2n**224n - 1n\n    Fp: Fp3,\n    // Subgroup order: how many points curve has;\n    // 2n**446n - 13818066809895115352007386748515426880336692474882178609894547503885n\n    n: BigInt(\"181709681073901722637330951972001133588410340171829515070372549795146003961539585716195755291692375963310293709091662304773755859649779\"),\n    nBitLength: 456,\n    // Cofactor\n    h: BigInt(4),\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"224580040295924300187604334099896036246789641632564134246125461686950415467406032909029192869357953282578032075146446173674602635247710\"),\n    Gy: BigInt(\"298819210078481492676017930443930673437544040154080242095928241372331506189835876003536878655418784733982303233503462500531545062832660\"),\n    // SHAKE256(dom4(phflag,context)||x, 114)\n    hash: shake256_114,\n    randomBytes,\n    adjustScalarBytes: adjustScalarBytes2,\n    // dom4\n    domain: (data, ctx, phflag) => {\n      if (ctx.length > 255)\n        throw new Error(\\`Context is too big: \\${ctx.length}\\`);\n      return concatBytes2(utf8ToBytes2(\"SigEd448\"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n    },\n    // Constant-time ratio of u to v. Allows to combine inversion and square root u/\u221av.\n    // Uses algo from RFC8032 5.1.3.\n    uvRatio: (u, v) => {\n      const P3 = ed448P;\n      const u2v = mod(u * u * v, P3);\n      const u3v = mod(u2v * u, P3);\n      const u5v3 = mod(u3v * u2v * v, P3);\n      const root = ed448_pow_Pminus3div4(u5v3);\n      const x = mod(u3v * root, P3);\n      const x2 = mod(x * x, P3);\n      return { isValid: mod(x2 * v, P3) === u, value: x };\n    }\n  };\n  var ed448 = twistedEdwards(ED448_DEF);\n  var ed448ph = twistedEdwards({ ...ED448_DEF, prehash: shake256_64 });\n  var x448 = /* @__PURE__ */ (() => montgomery({\n    a: BigInt(156326),\n    montgomeryBits: 448,\n    nByteLength: 57,\n    P: ed448P,\n    Gu: BigInt(5),\n    powPminus2: (x) => {\n      const P3 = ed448P;\n      const Pminus3div4 = ed448_pow_Pminus3div4(x);\n      const Pminus3 = pow2(Pminus3div4, BigInt(2), P3);\n      return mod(Pminus3 * x, P3);\n    },\n    adjustScalarBytes: adjustScalarBytes2,\n    randomBytes\n  }))();\n  var ELL2_C12 = (Fp3.ORDER - BigInt(3)) / BigInt(4);\n  var ELL2_J2 = BigInt(156326);\n\n  // ../esm/p256.js\n  var Fp4 = Field(BigInt(\"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\"));\n  var CURVE_A = Fp4.create(BigInt(\"-3\"));\n  var CURVE_B = BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\");\n  var p256 = createCurve({\n    a: CURVE_A,\n    b: CURVE_B,\n    Fp: Fp4,\n    // Curve order, total count of valid points in the field\n    n: BigInt(\"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\"),\n    // Base (generator) point (x, y)\n    Gx: BigInt(\"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\"),\n    Gy: BigInt(\"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\"),\n    h: BigInt(1),\n    lowS: false\n  }, sha256);\n\n  // ../esm/p384.js\n  var P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff\");\n  var Fp5 = Field(P);\n  var CURVE_A2 = Fp5.create(BigInt(\"-3\"));\n  var CURVE_B2 = BigInt(\"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\");\n  var p384 = createCurve({\n    a: CURVE_A2,\n    b: CURVE_B2,\n    Fp: Fp5,\n    // Curve order, total count of valid points in the field.\n    n: BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\"),\n    // Base (generator) point (x, y)\n    Gx: BigInt(\"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\"),\n    Gy: BigInt(\"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\"),\n    h: BigInt(1),\n    lowS: false\n  }, sha384);\n\n  // ../esm/p521.js\n  var P2 = BigInt(\"0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n  var Fp6 = Field(P2);\n  var CURVE = {\n    a: Fp6.create(BigInt(\"-3\")),\n    b: BigInt(\"0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\"),\n    Fp: Fp6,\n    n: BigInt(\"0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\"),\n    Gx: BigInt(\"0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\"),\n    Gy: BigInt(\"0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\"),\n    h: BigInt(1)\n  };\n  var p521 = createCurve({\n    a: CURVE.a,\n    b: CURVE.b,\n    Fp: Fp6,\n    // Curve order, total count of valid points in the field\n    n: CURVE.n,\n    Gx: CURVE.Gx,\n    Gy: CURVE.Gy,\n    h: CURVE.h,\n    lowS: false,\n    allowedPrivateKeyLengths: [130, 131, 132]\n    // P521 keys are variable-length. Normalize to 132b\n  }, sha512);\n\n  // ../esm/abstract/bls.js\n  var _2n8 = BigInt(2);\n  var _3n3 = BigInt(3);\n  function bls(CURVE2) {\n    const { Fp: Fp8, Fr: Fr2, Fp2: Fp23, Fp6: Fp63, Fp12: Fp122 } = CURVE2.fields;\n    const BLS_X_LEN2 = bitLen(CURVE2.params.x);\n    const groupLen = 32;\n    function calcPairingPrecomputes(p) {\n      const { x, y } = p;\n      const Qx = x, Qy = y, Qz = Fp23.ONE;\n      let Rx = Qx, Ry = Qy, Rz = Qz;\n      let ell_coeff = [];\n      for (let i = BLS_X_LEN2 - 2; i >= 0; i--) {\n        let t0 = Fp23.sqr(Ry);\n        let t1 = Fp23.sqr(Rz);\n        let t2 = Fp23.multiplyByB(Fp23.mul(t1, _3n3));\n        let t3 = Fp23.mul(t2, _3n3);\n        let t4 = Fp23.sub(Fp23.sub(Fp23.sqr(Fp23.add(Ry, Rz)), t1), t0);\n        ell_coeff.push([\n          Fp23.sub(t2, t0),\n          Fp23.mul(Fp23.sqr(Rx), _3n3),\n          Fp23.neg(t4)\n          // -T4\n        ]);\n        Rx = Fp23.div(Fp23.mul(Fp23.mul(Fp23.sub(t0, t3), Rx), Ry), _2n8);\n        Ry = Fp23.sub(Fp23.sqr(Fp23.div(Fp23.add(t0, t3), _2n8)), Fp23.mul(Fp23.sqr(t2), _3n3));\n        Rz = Fp23.mul(t0, t4);\n        if (bitGet(CURVE2.params.x, i)) {\n          let t02 = Fp23.sub(Ry, Fp23.mul(Qy, Rz));\n          let t12 = Fp23.sub(Rx, Fp23.mul(Qx, Rz));\n          ell_coeff.push([\n            Fp23.sub(Fp23.mul(t02, Qx), Fp23.mul(t12, Qy)),\n            Fp23.neg(t02),\n            t12\n            // T1\n          ]);\n          let t22 = Fp23.sqr(t12);\n          let t32 = Fp23.mul(t22, t12);\n          let t42 = Fp23.mul(t22, Rx);\n          let t5 = Fp23.add(Fp23.sub(t32, Fp23.mul(t42, _2n8)), Fp23.mul(Fp23.sqr(t02), Rz));\n          Rx = Fp23.mul(t12, t5);\n          Ry = Fp23.sub(Fp23.mul(Fp23.sub(t42, t5), t02), Fp23.mul(t32, Ry));\n          Rz = Fp23.mul(Rz, t32);\n        }\n      }\n      return ell_coeff;\n    }\n    function millerLoop(ell, g1) {\n      const { x } = CURVE2.params;\n      const Px = g1[0];\n      const Py = g1[1];\n      let f12 = Fp122.ONE;\n      for (let j = 0, i = BLS_X_LEN2 - 2; i >= 0; i--, j++) {\n        const E = ell[j];\n        f12 = Fp122.multiplyBy014(f12, E[0], Fp23.mul(E[1], Px), Fp23.mul(E[2], Py));\n        if (bitGet(x, i)) {\n          j += 1;\n          const F = ell[j];\n          f12 = Fp122.multiplyBy014(f12, F[0], Fp23.mul(F[1], Px), Fp23.mul(F[2], Py));\n        }\n        if (i !== 0)\n          f12 = Fp122.sqr(f12);\n      }\n      return Fp122.conjugate(f12);\n    }\n    const utils2 = {\n      randomPrivateKey: () => {\n        return Fr2.toBytes(hashToPrivateScalar(CURVE2.randomBytes(groupLen + 8), CURVE2.params.r));\n      },\n      calcPairingPrecomputes\n    };\n    const G1_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE2.G1 });\n    const G1 = Object.assign(G1_, createHasher(G1_.ProjectivePoint, CURVE2.G1.mapToCurve, {\n      ...CURVE2.htfDefaults,\n      ...CURVE2.G1.htfDefaults\n    }));\n    function pairingPrecomputes(point) {\n      const p = point;\n      if (p._PPRECOMPUTES)\n        return p._PPRECOMPUTES;\n      p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());\n      return p._PPRECOMPUTES;\n    }\n    const G2_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE2.G2 });\n    const G2 = Object.assign(G2_, createHasher(G2_.ProjectivePoint, CURVE2.G2.mapToCurve, {\n      ...CURVE2.htfDefaults,\n      ...CURVE2.G2.htfDefaults\n    }));\n    const { Signature } = CURVE2.G2;\n    function pairing(Q, P3, withFinalExponent = true) {\n      if (Q.equals(G1.ProjectivePoint.ZERO) || P3.equals(G2.ProjectivePoint.ZERO))\n        throw new Error(\"pairing is not available for ZERO point\");\n      Q.assertValidity();\n      P3.assertValidity();\n      const Qa = Q.toAffine();\n      const looped = millerLoop(pairingPrecomputes(P3), [Qa.x, Qa.y]);\n      return withFinalExponent ? Fp122.finalExponentiate(looped) : looped;\n    }\n    function normP1(point) {\n      return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);\n    }\n    function normP2(point) {\n      return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n    }\n    function normP2Hash(point, htfOpts) {\n      return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes(\"point\", point), htfOpts);\n    }\n    function getPublicKey(privateKey) {\n      return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n      const msgPoint = normP2Hash(message, htfOpts);\n      msgPoint.assertValidity();\n      const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n      if (message instanceof G2.ProjectivePoint)\n        return sigPoint;\n      return Signature.toRawBytes(sigPoint);\n    }\n    function verify(signature, message, publicKey, htfOpts) {\n      const P3 = normP1(publicKey);\n      const Hm = normP2Hash(message, htfOpts);\n      const G = G1.ProjectivePoint.BASE;\n      const S = normP2(signature);\n      const ePHm = pairing(P3.negate(), Hm, false);\n      const eGS = pairing(G, S, false);\n      const exp = Fp122.finalExponentiate(Fp122.mul(eGS, ePHm));\n      return Fp122.eql(exp, Fp122.ONE);\n    }\n    function aggregatePublicKeys(publicKeys) {\n      if (!publicKeys.length)\n        throw new Error(\"Expected non-empty array\");\n      const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n      const aggAffine = agg;\n      if (publicKeys[0] instanceof G1.ProjectivePoint) {\n        aggAffine.assertValidity();\n        return aggAffine;\n      }\n      return aggAffine.toRawBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n      if (!signatures.length)\n        throw new Error(\"Expected non-empty array\");\n      const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n      const aggAffine = agg;\n      if (signatures[0] instanceof G2.ProjectivePoint) {\n        aggAffine.assertValidity();\n        return aggAffine;\n      }\n      return Signature.toRawBytes(aggAffine);\n    }\n    function verifyBatch(signature, messages, publicKeys, htfOpts) {\n      if (!messages.length)\n        throw new Error(\"Expected non-empty messages array\");\n      if (publicKeys.length !== messages.length)\n        throw new Error(\"Pubkey count should equal msg count\");\n      const sig = normP2(signature);\n      const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n      const nPublicKeys = publicKeys.map(normP1);\n      try {\n        const paired = [];\n        for (const message of new Set(nMessages)) {\n          const groupPublicKey = nMessages.reduce((groupPublicKey2, subMessage, i) => subMessage === message ? groupPublicKey2.add(nPublicKeys[i]) : groupPublicKey2, G1.ProjectivePoint.ZERO);\n          paired.push(pairing(groupPublicKey, message, false));\n        }\n        paired.push(pairing(G1.ProjectivePoint.BASE.negate(), sig, false));\n        const product = paired.reduce((a, b) => Fp122.mul(a, b), Fp122.ONE);\n        const exp = Fp122.finalExponentiate(product);\n        return Fp122.eql(exp, Fp122.ONE);\n      } catch {\n        return false;\n      }\n    }\n    G1.ProjectivePoint.BASE._setWindowSize(4);\n    return {\n      getPublicKey,\n      sign,\n      verify,\n      verifyBatch,\n      aggregatePublicKeys,\n      aggregateSignatures,\n      millerLoop,\n      pairing,\n      G1,\n      G2,\n      Signature,\n      fields: {\n        Fr: Fr2,\n        Fp: Fp8,\n        Fp2: Fp23,\n        Fp6: Fp63,\n        Fp12: Fp122\n      },\n      params: {\n        x: CURVE2.params.x,\n        r: CURVE2.params.r,\n        G1b: CURVE2.G1.b,\n        G2b: CURVE2.G2.b\n      },\n      utils: utils2\n    };\n  }\n\n  // ../esm/bls12-381.js\n  var _0n10 = BigInt(0);\n  var _1n10 = BigInt(1);\n  var _2n9 = BigInt(2);\n  var _3n4 = BigInt(3);\n  var _4n4 = BigInt(4);\n  var _8n3 = BigInt(8);\n  var _16n2 = BigInt(16);\n  var Fp_raw = BigInt(\"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\");\n  var Fp7 = Field(Fp_raw);\n  var Fr = Field(BigInt(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\"));\n  var Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp7.add(c0, r0),\n    c1: Fp7.add(c1, r1)\n  });\n  var Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp7.sub(c0, r0),\n    c1: Fp7.sub(c1, r1)\n  });\n  var Fp2Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === \"bigint\")\n      return { c0: Fp7.mul(c0, rhs), c1: Fp7.mul(c1, rhs) };\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp7.mul(c0, r0);\n    let t2 = Fp7.mul(c1, r1);\n    const o0 = Fp7.sub(t1, t2);\n    const o1 = Fp7.sub(Fp7.mul(Fp7.add(c0, c1), Fp7.add(r0, r1)), Fp7.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  };\n  var Fp2Square = ({ c0, c1 }) => {\n    const a = Fp7.add(c0, c1);\n    const b = Fp7.sub(c0, c1);\n    const c = Fp7.add(c0, c0);\n    return { c0: Fp7.mul(a, b), c1: Fp7.mul(c, c1) };\n  };\n  var FP2_ORDER = Fp_raw * Fp_raw;\n  var Fp22 = {\n    ORDER: FP2_ORDER,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: { c0: Fp7.ZERO, c1: Fp7.ZERO },\n    ONE: { c0: Fp7.ONE, c1: Fp7.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === \"bigint\" && typeof c1 === \"bigint\",\n    is0: ({ c0, c1 }) => Fp7.is0(c0) && Fp7.is0(c1),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp7.eql(c0, r0) && Fp7.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp7.neg(c0), c1: Fp7.neg(c1) }),\n    pow: (num, power) => FpPow(Fp22, num, power),\n    invertBatch: (nums) => FpInvertBatch(Fp22, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) => Fp22.mul(lhs, typeof rhs === \"bigint\" ? Fp7.inv(Fp7.create(rhs)) : Fp22.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n      const factor = Fp7.inv(Fp7.create(a * a + b * b));\n      return { c0: Fp7.mul(factor, Fp7.create(a)), c1: Fp7.mul(factor, Fp7.create(-b)) };\n    },\n    sqrt: (num) => {\n      if (Fp22.eql(num, Fp22.ZERO))\n        return Fp22.ZERO;\n      const candidateSqrt = Fp22.pow(num, (Fp22.ORDER + _8n3) / _16n2);\n      const check = Fp22.div(Fp22.sqr(candidateSqrt), num);\n      const R = FP2_ROOTS_OF_UNITY;\n      const divisor = [R[0], R[2], R[4], R[6]].find((r) => Fp22.eql(r, check));\n      if (!divisor)\n        throw new Error(\"No root\");\n      const index = R.indexOf(divisor);\n      const root = R[index / 2];\n      if (!root)\n        throw new Error(\"Invalid root\");\n      const x1 = Fp22.div(candidateSqrt, root);\n      const x2 = Fp22.neg(x1);\n      const { re: re1, im: im1 } = Fp22.reim(x1);\n      const { re: re2, im: im2 } = Fp22.reim(x2);\n      if (im1 > im2 || im1 === im2 && re1 > re2)\n        return x1;\n      return x2;\n    },\n    // Same as sgn0_fp2 in draft-irtf-cfrg-hash-to-curve-16\n    isOdd: (x) => {\n      const { re: x0, im: x1 } = Fp22.reim(x);\n      const sign_0 = x0 % _2n9;\n      const zero_0 = x0 === _0n10;\n      const sign_1 = x1 % _2n9;\n      return BigInt(sign_0 || zero_0 && sign_1) == _1n10;\n    },\n    // Bytes util\n    fromBytes(b) {\n      if (b.length !== Fp22.BYTES)\n        throw new Error(\\`fromBytes wrong length=\\${b.length}\\`);\n      return { c0: Fp7.fromBytes(b.subarray(0, Fp7.BYTES)), c1: Fp7.fromBytes(b.subarray(Fp7.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp7.toBytes(c0), Fp7.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp7.cmov(c0, r0, c),\n      c1: Fp7.cmov(c1, r1, c)\n    }),\n    // Specific utils\n    // toString() {\n    //   return \\`Fp2(\\${this.c0} + \\${this.c1}\u00d7i)\\`;\n    // }\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => ({ c0: Fp7.sub(c0, c1), c1: Fp7.add(c0, c1) }),\n    multiplyByB: ({ c0, c1 }) => {\n      let t0 = Fp7.mul(c0, _4n4);\n      let t1 = Fp7.mul(c1, _4n4);\n      return { c0: Fp7.sub(t0, t1), c1: Fp7.add(t0, t1) };\n    },\n    fromBigTuple: (tuple) => {\n      if (tuple.length !== 2)\n        throw new Error(\"Invalid tuple\");\n      const fps = tuple.map((n) => Fp7.create(n));\n      return { c0: fps[0], c1: fps[1] };\n    },\n    frobeniusMap: ({ c0, c1 }, power) => ({\n      c0,\n      c1: Fp7.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])\n    })\n  };\n  var FP2_FROBENIUS_COEFFICIENTS = [\n    BigInt(\"0x1\"),\n    BigInt(\"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa\")\n  ].map((item) => Fp7.create(item));\n  var rv1 = BigInt(\"0x6af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09\");\n  var FP2_ROOTS_OF_UNITY = [\n    [_1n10, _0n10],\n    [rv1, -rv1],\n    [_0n10, _1n10],\n    [rv1, rv1],\n    [-_1n10, _0n10],\n    [-rv1, rv1],\n    [_0n10, -_1n10],\n    [-rv1, -rv1]\n  ].map((pair) => Fp22.fromBigTuple(pair));\n  var Fp6Add = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp22.add(c0, r0),\n    c1: Fp22.add(c1, r1),\n    c2: Fp22.add(c2, r2)\n  });\n  var Fp6Subtract = ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => ({\n    c0: Fp22.sub(c0, r0),\n    c1: Fp22.sub(c1, r1),\n    c2: Fp22.sub(c2, r2)\n  });\n  var Fp6Multiply = ({ c0, c1, c2 }, rhs) => {\n    if (typeof rhs === \"bigint\") {\n      return {\n        c0: Fp22.mul(c0, rhs),\n        c1: Fp22.mul(c1, rhs),\n        c2: Fp22.mul(c2, rhs)\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp22.mul(c0, r0);\n    const t1 = Fp22.mul(c1, r1);\n    const t2 = Fp22.mul(c2, r2);\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), Fp22.add(r1, r2)), Fp22.add(t1, t2)))),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t2)),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c2), Fp22.add(r0, r2))), Fp22.add(t0, t2))\n    };\n  };\n  var Fp6Square = ({ c0, c1, c2 }) => {\n    let t0 = Fp22.sqr(c0);\n    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n9);\n    let t3 = Fp22.mul(Fp22.mul(c1, c2), _2n9);\n    let t4 = Fp22.sqr(c2);\n    return {\n      c0: Fp22.add(Fp22.mulByNonresidue(t3), t0),\n      c1: Fp22.add(Fp22.mulByNonresidue(t4), t1),\n      // T1 + (c0 - c1 + c2)\u00b2 + T3 - T0 - T4\n      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c2))), t3), t0), t4)\n    };\n  };\n  var Fp62 = {\n    ORDER: Fp22.ORDER,\n    BITS: 3 * Fp22.BITS,\n    BYTES: 3 * Fp22.BYTES,\n    MASK: bitMask(3 * Fp22.BITS),\n    ZERO: { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO },\n    ONE: { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) => Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c2, r2),\n    sqrt: () => {\n      throw new Error(\"Not implemented\");\n    },\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) => Fp62.mul(lhs, typeof rhs === \"bigint\" ? Fp7.inv(Fp7.create(rhs)) : Fp62.inv(rhs)),\n    pow: (num, power) => FpPow(Fp62, num, power),\n    invertBatch: (nums) => FpInvertBatch(Fp62, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n    inv: ({ c0, c1, c2 }) => {\n      let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c2, c1)));\n      let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c2)), Fp22.mul(c0, c1));\n      let t2 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c2));\n      let t4 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c2, t1), Fp22.mul(c1, t2))), Fp22.mul(c0, t0)));\n      return { c0: Fp22.mul(t4, t0), c1: Fp22.mul(t4, t1), c2: Fp22.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b) => {\n      if (b.length !== Fp62.BYTES)\n        throw new Error(\\`fromBytes wrong length=\\${b.length}\\`);\n      return {\n        c0: Fp22.fromBytes(b.subarray(0, Fp22.BYTES)),\n        c1: Fp22.fromBytes(b.subarray(Fp22.BYTES, 2 * Fp22.BYTES)),\n        c2: Fp22.fromBytes(b.subarray(2 * Fp22.BYTES))\n      };\n    },\n    toBytes: ({ c0, c1, c2 }) => concatBytes(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) => ({\n      c0: Fp22.cmov(c0, r0, c),\n      c1: Fp22.cmov(c1, r1, c),\n      c2: Fp22.cmov(c2, r2, c)\n    }),\n    // Utils\n    //   fromTriple(triple: [Fp2, Fp2, Fp2]) {\n    //     return new Fp6(...triple);\n    //   }\n    //   toString() {\n    //     return \\`Fp6(\\${this.c0} + \\${this.c1} * v, \\${this.c2} * v^2)\\`;\n    //   }\n    fromBigSix: (t) => {\n      if (!Array.isArray(t) || t.length !== 6)\n        throw new Error(\"Invalid Fp6 usage\");\n      return {\n        c0: Fp22.fromBigTuple(t.slice(0, 2)),\n        c1: Fp22.fromBigTuple(t.slice(2, 4)),\n        c2: Fp22.fromBigTuple(t.slice(4, 6))\n      };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power) => ({\n      c0: Fp22.frobeniusMap(c0, power),\n      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp22.mul(Fp22.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp22.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    multiplyBy1: ({ c0, c1, c2 }, b1) => ({\n      c0: Fp22.mulByNonresidue(Fp22.mul(c2, b1)),\n      c1: Fp22.mul(c0, b1),\n      c2: Fp22.mul(c1, b1)\n    }),\n    // Sparse multiplication\n    multiplyBy01({ c0, c1, c2 }, b0, b1) {\n      let t0 = Fp22.mul(c0, b0);\n      let t1 = Fp22.mul(c1, b1);\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c2), b0), t0), t1)\n      };\n    },\n    multiplyByFp2: ({ c0, c1, c2 }, rhs) => ({\n      c0: Fp22.mul(c0, rhs),\n      c1: Fp22.mul(c1, rhs),\n      c2: Fp22.mul(c2, rhs)\n    })\n  };\n  var FP6_FROBENIUS_COEFFICIENTS_1 = [\n    [BigInt(\"0x1\"), BigInt(\"0x0\")],\n    [\n      BigInt(\"0x0\"),\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac\")\n    ],\n    [\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\"),\n      BigInt(\"0x0\")\n    ],\n    [BigInt(\"0x0\"), BigInt(\"0x1\")],\n    [\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x0\"),\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\")\n    ]\n  ].map((pair) => Fp22.fromBigTuple(pair));\n  var FP6_FROBENIUS_COEFFICIENTS_2 = [\n    [BigInt(\"0x1\"), BigInt(\"0x0\")],\n    [\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff\"),\n      BigInt(\"0x0\")\n    ]\n  ].map((pair) => Fp22.fromBigTuple(pair));\n  var BLS_X = BigInt(\"0xd201000000010000\");\n  var BLS_X_LEN = bitLen(BLS_X);\n  var Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp62.add(c0, r0),\n    c1: Fp62.add(c1, r1)\n  });\n  var Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({\n    c0: Fp62.sub(c0, r0),\n    c1: Fp62.sub(c1, r1)\n  });\n  var Fp12Multiply = ({ c0, c1 }, rhs) => {\n    if (typeof rhs === \"bigint\")\n      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp62.mul(c0, r0);\n    let t2 = Fp62.mul(c1, r1);\n    return {\n      c0: Fp62.add(t1, Fp62.mulByNonresidue(t2)),\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t2))\n    };\n  };\n  var Fp12Square = ({ c0, c1 }) => {\n    let ab = Fp62.mul(c0, c1);\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),\n      c1: Fp62.add(ab, ab)\n    };\n  };\n  function Fp4Square(a, b) {\n    const a2 = Fp22.sqr(a);\n    const b2 = Fp22.sqr(b);\n    return {\n      first: Fp22.add(Fp22.mulByNonresidue(b2), a2),\n      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a, b)), a2), b2)\n      // (a + b)\u00b2 - a\u00b2 - b\u00b2\n    };\n  }\n  var Fp12 = {\n    ORDER: Fp22.ORDER,\n    BITS: 2 * Fp22.BITS,\n    BYTES: 2 * Fp22.BYTES,\n    MASK: bitMask(2 * Fp22.BITS),\n    ZERO: { c0: Fp62.ZERO, c1: Fp62.ZERO },\n    ONE: { c0: Fp62.ONE, c1: Fp62.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp62.isValid(c0) && Fp62.isValid(c1),\n    is0: ({ c0, c1 }) => Fp62.is0(c0) && Fp62.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp62.neg(c0), c1: Fp62.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp62.eql(c0, r0) && Fp62.eql(c1, r1),\n    sqrt: () => {\n      throw new Error(\"Not implemented\");\n    },\n    inv: ({ c0, c1 }) => {\n      let t = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));\n      return { c0: Fp62.mul(c0, t), c1: Fp62.neg(Fp62.mul(c1, t)) };\n    },\n    div: (lhs, rhs) => Fp12.mul(lhs, typeof rhs === \"bigint\" ? Fp7.inv(Fp7.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => FpPow(Fp12, num, power),\n    invertBatch: (nums) => FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n    // Bytes utils\n    fromBytes: (b) => {\n      if (b.length !== Fp12.BYTES)\n        throw new Error(\\`fromBytes wrong length=\\${b.length}\\`);\n      return {\n        c0: Fp62.fromBytes(b.subarray(0, Fp62.BYTES)),\n        c1: Fp62.fromBytes(b.subarray(Fp62.BYTES))\n      };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp62.toBytes(c0), Fp62.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp62.cmov(c0, r0, c),\n      c1: Fp62.cmov(c1, r1, c)\n    }),\n    // Utils\n    // toString() {\n    //   return \\`Fp12(\\${this.c0} + \\${this.c1} * w)\\`;\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t) => ({\n      c0: Fp62.fromBigSix(t.slice(0, 6)),\n      c1: Fp62.fromBigSix(t.slice(6, 12))\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n      const r0 = Fp62.frobeniusMap(lhs.c0, power);\n      const { c0, c1, c2 } = Fp62.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: r0,\n        c1: Fp62.create({\n          c0: Fp22.mul(c0, coeff),\n          c1: Fp22.mul(c1, coeff),\n          c2: Fp22.mul(c2, coeff)\n        })\n      };\n    },\n    // Sparse multiplication\n    multiplyBy014: ({ c0, c1 }, o0, o1, o4) => {\n      let t0 = Fp62.multiplyBy01(c0, o0, o1);\n      let t1 = Fp62.multiplyBy1(c1, o4);\n      return {\n        c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp62.sub(Fp62.sub(Fp62.multiplyBy01(Fp62.add(c1, c0), o0, Fp22.add(o1, o4)), t0), t1)\n      };\n    },\n    multiplyByFp2: ({ c0, c1 }, rhs) => ({\n      c0: Fp62.multiplyByFp2(c0, rhs),\n      c1: Fp62.multiplyByFp2(c1, rhs)\n    }),\n    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp62.neg(c1) }),\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   G\u03a6\u2099(p) = {\u03b1 \u2208 Fp\u207f : \u03b1^\u03a6\u2099(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: ({ c0, c1 }) => {\n      const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n      const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n      const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n      const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n      const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n      let t9 = Fp22.mulByNonresidue(t8);\n      return {\n        c0: Fp62.create({\n          c0: Fp22.add(Fp22.mul(Fp22.sub(t3, c0c0), _2n9), t3),\n          c1: Fp22.add(Fp22.mul(Fp22.sub(t5, c0c1), _2n9), t5),\n          c2: Fp22.add(Fp22.mul(Fp22.sub(t7, c0c2), _2n9), t7)\n        }),\n        c1: Fp62.create({\n          c0: Fp22.add(Fp22.mul(Fp22.add(t9, c1c0), _2n9), t9),\n          c1: Fp22.add(Fp22.mul(Fp22.add(t4, c1c1), _2n9), t4),\n          c2: Fp22.add(Fp22.mul(Fp22.add(t6, c1c2), _2n9), t6)\n        })\n      };\n    },\n    _cyclotomicExp(num, n) {\n      let z = Fp12.ONE;\n      for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n        z = Fp12._cyclotomicSquare(z);\n        if (bitGet(n, i))\n          z = Fp12.mul(z, num);\n      }\n      return z;\n    },\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: (num) => {\n      const x = BLS_X;\n      const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n      const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n      const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n      const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n      const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n      const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n      const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n      const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n      const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n      const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n      const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n      const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n      return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    }\n  };\n  var FP12_FROBENIUS_COEFFICIENTS = [\n    [BigInt(\"0x1\"), BigInt(\"0x0\")],\n    [\n      BigInt(\"0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8\"),\n      BigInt(\"0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3\")\n    ],\n    [\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffeffff\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2\"),\n      BigInt(\"0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09\")\n    ],\n    [\n      BigInt(\"0x00000000000000005f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995\"),\n      BigInt(\"0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116\")\n    ],\n    [\n      BigInt(\"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x00fc3e2b36c4e03288e9e902231f9fb854a14787b6c7b36fec0c8ec971f63c5f282d5ac14d6c7ec22cf78a126ddc4af3\"),\n      BigInt(\"0x1904d3bf02bb0667c231beb4202c0d1f0fd603fd3cbd5f4f7b2443d784bab9c4f67ea53d63e7813d8d0775ed92235fb8\")\n    ],\n    [\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x06af0e0437ff400b6831e36d6bd17ffe48395dabc2d3435e77f76e17009241c5ee67992f72ec05f4c81084fbede3cc09\"),\n      BigInt(\"0x135203e60180a68ee2e9c448d77a2cd91c3dedd930b1cf60ef396489f61eb45e304466cf3e67fa0af1ee7b04121bdea2\")\n    ],\n    [\n      BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaad\"),\n      BigInt(\"0x0\")\n    ],\n    [\n      BigInt(\"0x05b2cfd9013a5fd8df47fa6b48b1e045f39816240c0b8fee8beadf4d8e9c0566c63a3e6e257f87329b18fae980078116\"),\n      BigInt(\"0x144e4211384586c16bd3ad4afa99cc9170df3560e77982d0db45f3536814f0bd5871c1908bd478cd1ee605167ff82995\")\n    ]\n  ].map((n) => Fp22.fromBigTuple(n));\n  var isogenyMapG2 = isogenyMap(Fp22, [\n    // xNum\n    [\n      [\n        \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6\",\n        \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6\"\n      ],\n      [\n        \"0x0\",\n        \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a\"\n      ],\n      [\n        \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e\",\n        \"0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d\"\n      ],\n      [\n        \"0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1\",\n        \"0x0\"\n      ]\n    ],\n    // xDen\n    [\n      [\n        \"0x0\",\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63\"\n      ],\n      [\n        \"0xc\",\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f\"\n      ],\n      [\"0x1\", \"0x0\"]\n      // LAST 1\n    ],\n    // yNum\n    [\n      [\n        \"0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706\",\n        \"0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706\"\n      ],\n      [\n        \"0x0\",\n        \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be\"\n      ],\n      [\n        \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c\",\n        \"0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f\"\n      ],\n      [\n        \"0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10\",\n        \"0x0\"\n      ]\n    ],\n    // yDen\n    [\n      [\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb\",\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb\"\n      ],\n      [\n        \"0x0\",\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3\"\n      ],\n      [\n        \"0x12\",\n        \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99\"\n      ],\n      [\"0x1\", \"0x0\"]\n      // LAST 1\n    ]\n  ].map((i) => i.map((pair) => Fp22.fromBigTuple(pair.map(BigInt)))));\n  var isogenyMapG1 = isogenyMap(Fp7, [\n    // xNum\n    [\n      \"0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7\",\n      \"0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb\",\n      \"0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0\",\n      \"0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861\",\n      \"0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9\",\n      \"0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983\",\n      \"0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84\",\n      \"0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e\",\n      \"0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317\",\n      \"0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e\",\n      \"0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b\",\n      \"0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229\"\n    ],\n    // xDen\n    [\n      \"0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c\",\n      \"0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff\",\n      \"0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19\",\n      \"0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8\",\n      \"0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e\",\n      \"0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5\",\n      \"0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a\",\n      \"0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e\",\n      \"0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641\",\n      \"0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a\",\n      \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"\n      // LAST 1\n    ],\n    // yNum\n    [\n      \"0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33\",\n      \"0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696\",\n      \"0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6\",\n      \"0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb\",\n      \"0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb\",\n      \"0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0\",\n      \"0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2\",\n      \"0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29\",\n      \"0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587\",\n      \"0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30\",\n      \"0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132\",\n      \"0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e\",\n      \"0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8\",\n      \"0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133\",\n      \"0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b\",\n      \"0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604\"\n    ],\n    // yDen\n    [\n      \"0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1\",\n      \"0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d\",\n      \"0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2\",\n      \"0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416\",\n      \"0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d\",\n      \"0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac\",\n      \"0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c\",\n      \"0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9\",\n      \"0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a\",\n      \"0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55\",\n      \"0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8\",\n      \"0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092\",\n      \"0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc\",\n      \"0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7\",\n      \"0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f\",\n      \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"\n      // LAST 1\n    ]\n  ].map((i) => i.map((j) => BigInt(j))));\n  var G2_SWU = mapToCurveSimpleSWU(Fp22, {\n    A: Fp22.create({ c0: Fp7.create(_0n10), c1: Fp7.create(BigInt(240)) }),\n    B: Fp22.create({ c0: Fp7.create(BigInt(1012)), c1: Fp7.create(BigInt(1012)) }),\n    Z: Fp22.create({ c0: Fp7.create(BigInt(-2)), c1: Fp7.create(BigInt(-1)) })\n    // Z: -(2 + I)\n  });\n  var G1_SWU = mapToCurveSimpleSWU(Fp7, {\n    A: Fp7.create(BigInt(\"0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d\")),\n    B: Fp7.create(BigInt(\"0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0\")),\n    Z: Fp7.create(BigInt(11))\n  });\n  var ut_root = Fp62.create({ c0: Fp22.ZERO, c1: Fp22.ONE, c2: Fp22.ZERO });\n  var wsq = Fp12.create({ c0: ut_root, c1: Fp62.ZERO });\n  var wcu = Fp12.create({ c0: Fp62.ZERO, c1: ut_root });\n  var [wsq_inv, wcu_inv] = Fp12.invertBatch([wsq, wcu]);\n  function psi(x, y) {\n    const x2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wsq_inv, x), 1), wsq).c0.c0;\n    const y2 = Fp12.mul(Fp12.frobeniusMap(Fp12.multiplyByFp2(wcu_inv, y), 1), wcu).c0.c0;\n    return [x2, y2];\n  }\n  function G2psi(c, P3) {\n    const affine = P3.toAffine();\n    const p = psi(affine.x, affine.y);\n    return new c(p[0], p[1], Fp22.ONE);\n  }\n  var PSI2_C1 = BigInt(\"0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaac\");\n  function psi2(x, y) {\n    return [Fp22.mul(x, PSI2_C1), Fp22.neg(y)];\n  }\n  function G2psi2(c, P3) {\n    const affine = P3.toAffine();\n    const p = psi2(affine.x, affine.y);\n    return new c(p[0], p[1], Fp22.ONE);\n  }\n  var htfDefaults = Object.freeze({\n    // DST: a domain separation tag\n    // defined in section 2.2.5\n    // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n    DST: \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\",\n    encodeDST: \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\",\n    // p: the characteristic of F\n    //    where F is a finite field of characteristic p and order q = p^m\n    p: Fp7.ORDER,\n    // m: the extension degree of F, m >= 1\n    //     where F is a finite field of characteristic p and order q = p^m\n    m: 2,\n    // k: the target security level for the suite in bits\n    // defined in section 5.1\n    k: 128,\n    // option to use a message that has already been processed by\n    // expand_message_xmd\n    expand: \"xmd\",\n    // Hash functions for: expand_message_xmd is appropriate for use with a\n    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n    hash: sha256\n  });\n  var C_BIT_POS = Fp7.BITS;\n  var I_BIT_POS = Fp7.BITS + 1;\n  var S_BIT_POS = Fp7.BITS + 2;\n  var COMPRESSED_ZERO = Fp7.toBytes(bitSet(bitSet(_0n10, I_BIT_POS, true), S_BIT_POS, true));\n  function signatureG2ToRawBytes(point) {\n    point.assertValidity();\n    const len = Fp7.BYTES;\n    if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n      return concatBytes(COMPRESSED_ZERO, numberToBytesBE(_0n10, len));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp22.reim(x);\n    const { re: y0, im: y1 } = Fp22.reim(y);\n    const tmp = y1 > _0n10 ? y1 * _2n9 : y0 * _2n9;\n    const aflag1 = Boolean(tmp / Fp7.ORDER & _1n10);\n    const z1 = bitSet(bitSet(x1, 381, aflag1), S_BIT_POS, true);\n    const z2 = x0;\n    return concatBytes(numberToBytesBE(z1, len), numberToBytesBE(z2, len));\n  }\n  var bls12_381 = bls({\n    // Fields\n    fields: {\n      Fp: Fp7,\n      Fp2: Fp22,\n      Fp6: Fp62,\n      Fp12,\n      Fr\n    },\n    // G1 is the order-q subgroup of E1(Fp) : y\u00b2 = x\u00b3 + 4, #E1(Fp) = h1q, where\n    // characteristic; z + (z\u2074 - z\u00b2 + 1)(z - 1)\u00b2/3\n    G1: {\n      Fp: Fp7,\n      // cofactor; (z - 1)\u00b2/3\n      h: BigInt(\"0x396c8c005555e1568c00aaab0000aaab\"),\n      // generator's coordinates\n      // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n      // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n      Gx: BigInt(\"0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"),\n      Gy: BigInt(\"0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\"),\n      a: Fp7.ZERO,\n      b: _4n4,\n      htfDefaults: { ...htfDefaults, m: 1 },\n      wrapPrivateKey: true,\n      allowInfinityPoint: true,\n      // Checks is the point resides in prime-order subgroup.\n      // point.isTorsionFree() should return true for valid points\n      // It returns false for shitty points.\n      // https://eprint.iacr.org/2021/1130.pdf\n      isTorsionFree: (c, point) => {\n        const cubicRootOfUnityModP = BigInt(\"0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\");\n        const phi = new c(Fp7.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);\n        const xP = point.multiplyUnsafe(bls12_381.params.x).negate();\n        const u2P = xP.multiplyUnsafe(bls12_381.params.x);\n        return u2P.equals(phi);\n      },\n      // Clear cofactor of G1\n      // https://eprint.iacr.org/2019/403\n      clearCofactor: (c, point) => {\n        return point.multiplyUnsafe(bls12_381.params.x).add(point);\n      },\n      mapToCurve: (scalars) => {\n        const { x, y } = G1_SWU(Fp7.create(scalars[0]));\n        return isogenyMapG1(x, y);\n      },\n      fromBytes: (bytes2) => {\n        bytes2 = bytes2.slice();\n        if (bytes2.length === 48) {\n          const P3 = Fp7.ORDER;\n          const compressedValue = bytesToNumberBE(bytes2);\n          const bflag = bitGet(compressedValue, I_BIT_POS);\n          if (bflag === _1n10)\n            return { x: _0n10, y: _0n10 };\n          const x = Fp7.create(compressedValue & Fp7.MASK);\n          const right = Fp7.add(Fp7.pow(x, _3n4), Fp7.create(bls12_381.params.G1b));\n          let y = Fp7.sqrt(right);\n          if (!y)\n            throw new Error(\"Invalid compressed G1 point\");\n          const aflag = bitGet(compressedValue, C_BIT_POS);\n          if (y * _2n9 / P3 !== aflag)\n            y = Fp7.neg(y);\n          return { x: Fp7.create(x), y: Fp7.create(y) };\n        } else if (bytes2.length === 96) {\n          if ((bytes2[0] & 1 << 6) !== 0)\n            return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n          const x = bytesToNumberBE(bytes2.subarray(0, Fp7.BYTES));\n          const y = bytesToNumberBE(bytes2.subarray(Fp7.BYTES));\n          return { x: Fp7.create(x), y: Fp7.create(y) };\n        } else {\n          throw new Error(\"Invalid point G1, expected 48/96 bytes\");\n        }\n      },\n      toBytes: (c, point, isCompressed) => {\n        const isZero = point.equals(c.ZERO);\n        const { x, y } = point.toAffine();\n        if (isCompressed) {\n          if (isZero)\n            return COMPRESSED_ZERO.slice();\n          const P3 = Fp7.ORDER;\n          let num;\n          num = bitSet(x, C_BIT_POS, Boolean(y * _2n9 / P3));\n          num = bitSet(num, S_BIT_POS, true);\n          return numberToBytesBE(num, Fp7.BYTES);\n        } else {\n          if (isZero) {\n            const x2 = concatBytes(new Uint8Array([64]), new Uint8Array(2 * Fp7.BYTES - 1));\n            return x2;\n          } else {\n            return concatBytes(numberToBytesBE(x, Fp7.BYTES), numberToBytesBE(y, Fp7.BYTES));\n          }\n        }\n      }\n    },\n    // G2 is the order-q subgroup of E2(Fp\u00b2) : y\u00b2 = x\u00b3+4(1+\u221a\u22121),\n    // where Fp2 is Fp[\u221a\u22121]/(x2+1). #E2(Fp2 ) = h2q, where\n    // G\u00b2 - 1\n    // h2q\n    G2: {\n      Fp: Fp22,\n      // cofactor\n      h: BigInt(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\"),\n      Gx: Fp22.fromBigTuple([\n        BigInt(\"0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"),\n        BigInt(\"0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e\")\n      ]),\n      // y =\n      // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n      // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n      Gy: Fp22.fromBigTuple([\n        BigInt(\"0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801\"),\n        BigInt(\"0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be\")\n      ]),\n      a: Fp22.ZERO,\n      b: Fp22.fromBigTuple([_4n4, _4n4]),\n      hEff: BigInt(\"0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551\"),\n      htfDefaults: { ...htfDefaults },\n      wrapPrivateKey: true,\n      allowInfinityPoint: true,\n      mapToCurve: (scalars) => {\n        const { x, y } = G2_SWU(Fp22.fromBigTuple(scalars));\n        return isogenyMapG2(x, y);\n      },\n      // Checks is the point resides in prime-order subgroup.\n      // point.isTorsionFree() should return true for valid points\n      // It returns false for shitty points.\n      // https://eprint.iacr.org/2021/1130.pdf\n      isTorsionFree: (c, P3) => {\n        return P3.multiplyUnsafe(bls12_381.params.x).negate().equals(G2psi(c, P3));\n      },\n      // Maps the point into the prime-order subgroup G2.\n      // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11\n      // https://eprint.iacr.org/2017/419.pdf\n      // prettier-ignore\n      clearCofactor: (c, P3) => {\n        const x = bls12_381.params.x;\n        let t1 = P3.multiplyUnsafe(x).negate();\n        let t2 = G2psi(c, P3);\n        let t3 = P3.double();\n        t3 = G2psi2(c, t3);\n        t3 = t3.subtract(t2);\n        t2 = t1.add(t2);\n        t2 = t2.multiplyUnsafe(x).negate();\n        t3 = t3.add(t2);\n        t3 = t3.subtract(t1);\n        const Q = t3.subtract(P3);\n        return Q;\n      },\n      fromBytes: (bytes2) => {\n        bytes2 = bytes2.slice();\n        const m_byte = bytes2[0] & 224;\n        if (m_byte === 32 || m_byte === 96 || m_byte === 224) {\n          throw new Error(\"Invalid encoding flag: \" + m_byte);\n        }\n        const bitC = m_byte & 128;\n        const bitI = m_byte & 64;\n        const bitS = m_byte & 32;\n        const L = Fp7.BYTES;\n        const slc = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n        if (bytes2.length === 96 && bitC) {\n          const b = bls12_381.params.G2b;\n          const P3 = Fp7.ORDER;\n          bytes2[0] = bytes2[0] & 31;\n          if (bitI) {\n            if (bytes2.reduce((p, c) => p !== 0 ? c + 1 : c, 0) > 0) {\n              throw new Error(\"Invalid compressed G2 point\");\n            }\n            return { x: Fp22.ZERO, y: Fp22.ZERO };\n          }\n          const x_1 = slc(bytes2, 0, L);\n          const x_0 = slc(bytes2, L, 2 * L);\n          const x = Fp22.create({ c0: Fp7.create(x_0), c1: Fp7.create(x_1) });\n          const right = Fp22.add(Fp22.pow(x, _3n4), b);\n          let y = Fp22.sqrt(right);\n          const Y_bit = y.c1 === _0n10 ? y.c0 * _2n9 / P3 : y.c1 * _2n9 / P3 ? _1n10 : _0n10;\n          y = bitS > 0 && Y_bit > 0 ? y : Fp22.neg(y);\n          return { x, y };\n        } else if (bytes2.length === 192 && !bitC) {\n          if ((bytes2[0] & 1 << 6) !== 0) {\n            return { x: Fp22.ZERO, y: Fp22.ZERO };\n          }\n          const x1 = slc(bytes2, 0, L);\n          const x0 = slc(bytes2, L, 2 * L);\n          const y1 = slc(bytes2, 2 * L, 3 * L);\n          const y0 = slc(bytes2, 3 * L, 4 * L);\n          return { x: Fp22.fromBigTuple([x0, x1]), y: Fp22.fromBigTuple([y0, y1]) };\n        } else {\n          throw new Error(\"Invalid point G2, expected 96/192 bytes\");\n        }\n      },\n      toBytes: (c, point, isCompressed) => {\n        const { BYTES: len, ORDER: P3 } = Fp7;\n        const isZero = point.equals(c.ZERO);\n        const { x, y } = point.toAffine();\n        if (isCompressed) {\n          if (isZero)\n            return concatBytes(COMPRESSED_ZERO, numberToBytesBE(_0n10, len));\n          const flag = Boolean(y.c1 === _0n10 ? y.c0 * _2n9 / P3 : y.c1 * _2n9 / P3);\n          let x_1 = bitSet(x.c1, C_BIT_POS, flag);\n          x_1 = bitSet(x_1, S_BIT_POS, true);\n          return concatBytes(numberToBytesBE(x_1, len), numberToBytesBE(x.c0, len));\n        } else {\n          if (isZero)\n            return concatBytes(new Uint8Array([64]), new Uint8Array(4 * len - 1));\n          const { re: x0, im: x1 } = Fp22.reim(x);\n          const { re: y0, im: y1 } = Fp22.reim(y);\n          return concatBytes(numberToBytesBE(x1, len), numberToBytesBE(x0, len), numberToBytesBE(y1, len), numberToBytesBE(y0, len));\n        }\n      },\n      Signature: {\n        // TODO: Optimize, it's very slow because of sqrt.\n        fromHex(hex) {\n          hex = ensureBytes(\"signatureHex\", hex);\n          const P3 = Fp7.ORDER;\n          const half = hex.length / 2;\n          if (half !== 48 && half !== 96)\n            throw new Error(\"Invalid compressed signature length, must be 96 or 192\");\n          const z1 = bytesToNumberBE(hex.slice(0, half));\n          const z2 = bytesToNumberBE(hex.slice(half));\n          const bflag1 = bitGet(z1, I_BIT_POS);\n          if (bflag1 === _1n10)\n            return bls12_381.G2.ProjectivePoint.ZERO;\n          const x1 = Fp7.create(z1 & Fp7.MASK);\n          const x2 = Fp7.create(z2);\n          const x = Fp22.create({ c0: x2, c1: x1 });\n          const y2 = Fp22.add(Fp22.pow(x, _3n4), bls12_381.params.G2b);\n          let y = Fp22.sqrt(y2);\n          if (!y)\n            throw new Error(\"Failed to find a square root\");\n          const { re: y0, im: y1 } = Fp22.reim(y);\n          const aflag1 = bitGet(z1, 381);\n          const isGreater = y1 > _0n10 && y1 * _2n9 / P3 !== aflag1;\n          const isZero = y1 === _0n10 && y0 * _2n9 / P3 !== aflag1;\n          if (isGreater || isZero)\n            y = Fp22.neg(y);\n          const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n          point.assertValidity();\n          return point;\n        },\n        toRawBytes(point) {\n          return signatureG2ToRawBytes(point);\n        },\n        toHex(point) {\n          return bytesToHex(signatureG2ToRawBytes(point));\n        }\n      }\n    },\n    params: {\n      x: BLS_X,\n      r: Fr.ORDER\n      // order; z\u2074 \u2212 z\u00b2 + 1; CURVE.n from other curves\n    },\n    htfDefaults,\n    hash: sha256,\n    randomBytes\n  });\n\n  // input.js\n  var utils = { bytesToHex, concatBytes, hexToBytes };\n  return __toCommonJS(input_exports);  \n})();\nwindow.top.postMessage(\"loaded\", \"*\");\n</script>\n\n<script>\nconst FR = nobleCurves.bls12_381.fields.Fr;\nconst G1 = nobleCurves.bls12_381.G1.CURVE;\nconst G2 = nobleCurves.bls12_381.G2.CURVE;\n\nfunction decodeContributions(contributions) {\n  for (var i = 0; i < contributions.length; i++) {\n    for(var j = 0; j < contributions[i].numG1Powers; j++){\n        var hexStr = contributions[i].powersOfTau.G1Powers[j].substring(2);\n        var hex = nobleCurves.utils.hexToBytes(hexStr);\n        var affinePoint = G1.fromBytes(hex);\n        contributions[i].powersOfTau.G1Powers[j] = affinePoint; \n    }\n\n    for(var j = 0; j < contributions[i].numG2Powers; j++){\n        var hexStr = contributions[i].powersOfTau.G2Powers[j].substring(2);\n        var hex = nobleCurves.utils.hexToBytes(hexStr);\n        var affinePoint = G2.fromBytes(hex);\n        contributions[i].powersOfTau.G2Powers[j] = affinePoint;\n    }\n  }\n  return contributions;\n}\n\nfunction hashFnv32a(str, asString, seed) {\n    /*jshint bitwise:false */\n    var i, l,\n        hval = (seed === undefined) ? 0x811c9dc5 : seed;\n\n    for (i = 0, l = str.length; i < l; i++) {\n        hval ^= str.charCodeAt(i);\n        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n    }\n    if( asString ){\n        // Convert to 8 digit hex string\n        return (\"0000000\" + (hval >>> 0).toString(16)).substr(-8);\n    }\n    return hval >>> 0;\n}\n\nfunction generateRandom(entropy){\n    const seedInt = hashFnv32a(entropy)\n    randomBytes = crypto.randomUUID();\n    const randomInt = (parseInt(randomBytes, 16) + seedInt);\n    const randomBigInt = BigInt(randomInt);\n    return randomBigInt;\n}\n\nfunction contribute(contributions, rands) {\n  for(var i = 0; i < contributions.length; i++) {\n      const g1Powers = contributions[i].powersOfTau.G1Powers;\n      const g2Powers = contributions[i].powersOfTau.G2Powers;\n      var xi = BigInt(1);\n      for(var j = 0; j < contributions[i].numG1Powers; j++) {\n          const g1Affine = g1Powers[j];\n          const g1PrjPoint = G1Point.fromAffine(g1Affine);\n\n          const g1NewPrjPoint = g1PrjPoint.multiply(xi);\n          const g1NewAffine = g1NewPrjPoint.toAffine();\n\n          contributions[i].powersOfTau.G1Powers[j] = g1NewAffine;\n\n          if (j < contributions[i].numG2Powers) {\n              const g2Affine = g2Powers[j];\n              const g2PrjPoint = G2Point.fromAffine(g2Affine);\n\n              const g2NewPrjPoint = g2PrjPoint.multiply(xi);\n              const g2NewAffine = g2NewPrjPoint.toAffine();\n\n              contributions[i].powersOfTau.G2Powers[j] = g2NewAffine;\n          }\n          xi = (xi * rands[i]) % Fr.ORDER;\n      }\n  };\n  return contributions;\n}\n\nfunction updateWitness(contributions, rand) {\n    for(var i = 0; i < contributions.length; i++) {\n        const potPubkey = contributions[i].potPubkey;\n        const hexStr = potPubkey.substring(2);\n\n        // PotPub -> G2Affine\n        const hex = nobleCurves.utils.hexToBytes(hexStr);\n\n        const potPubkeyAffine = G2.fromBytes(hex);\n\n        const potPubkeyPrj = G2Point.fromAffine(potPubkeyAffine);\n        const newPubkeyPrj = potPubkeyPrj.multiply(rand[i])\n\n        const newPotPubkey = nobleCurves.utils.bytesToHex(G2.toBytes(G2Point, newPubkeyPrj, true));\n\n        contributions[i].potPubkey = '0x' + newPotPubkey;\n    }\n\n    return contributions;\n}\n\nfunction runCeremony(entropy, contributions) {\n  const prevContributions = decodeContributions(contributions);\n  var rands = [];\n  for (var i = 0; i < prevContributions.length; i++) {\n    rands[i] = generateRandom(entropy);\n    rands[i] = Fr.create(rands[i]);\n  }\n  let newContributions = contribute(prevContributions, rands);\n  newContributions = updateWitness(newContributions, rands);\n\n  delete newContributions[0].blsSignature\n  delete newContributions[1].blsSignature\n  delete newContributions[2].blsSignature\n  delete newContributions[3].blsSignature\n\n  return newContributions;\n}\n\nwindow.addEventListener(\"message\", (event) => {\n  const { stage } = event;\n\n  if (stage === 'computing') {\n    const { contributions, entropy } = event.data\n    try {\n      const contributions = runCeremony(entropy, contributions);\n      window.top.postMessage(contributions, \"*\")\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}, false);\n</script>\n`;\n\nconst { sessionID } = props;\n\nconst nounFont = fetch(\n  \"https://fonts.googleapis.com/css2?family=Londrina+Solid:wght@100;300;400;900&display=swap\"\n).body;\nconst glyphFont = `\n  @font-face {\n    font-family: GraublauWeb;\n    src: url(\"https://nouns.center/assets/nountown.otf\") format(\"opentype\");\n  }\n`;\n\nconst Centered = styled.div`\n  padding-left: 12px;\n  padding-right: 12px;\n  display: flex;\n  flex-direction: column;\n  justify-content: start;\n  align-items: center;\n  min-height: 400px;\n`;\n\nconst Heading = styled.h1`\n  display: block;\n  ${glyphFont}\n  color: white;\n  background: blue;\n  width: 100%;\n  padding-top: 100px;\n  padding-left: 24px;\n  font-size: 96px;\n  margin: 0px;\n  font-family: GraublauWeb;\n\n  span {\n    position: absolute;\n    bottom: 0;\n    display: flex\n  }\n`;\n\nconst Subheading = styled.h3`\n  padding: 12px;\n  font-size: 20px;\n  margin-top: 20px;\n`;\n\nconst GrayText = styled.p`\n  font-size: 16px;\n  color: gray;\n`;\n\nconst BlackText = styled.p`\n  font-size:16px;\n  color: black;\n`;\n\nconst Town = styled.b`\n  ${glyphFont}\n  font-family: 'GraublauWeb';\n`;\n\nconst Glyph = styled.b`\n  ${nounFont}\n  font-size: 23px;\n  font-family: 'Londrina Solid', sans-serif;\n`;\n\nconst Hidden = styled.div`\n    height: 0;\n    overflow: hidden;\n    position: absolute;\n    top: 0;\n`;\n\nconst numRetries = Storage.get(\"nounkzg_retries\") ?? 0;\nif (!state?.contributions) {\n  function updateRetries() {\n    Storage.set(\"nounkzg_retries\", numRetries + 1);\n  }\n\n  function tryContribute() {\n    asyncFetch(\"https://seq.ceremony.ethereum.org/lobby/try_contribute\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${sessionID}`,\n      },\n    }).then((res) => {\n      console.log(res);\n      res?.body?.contributions &&\n        State.({\n          contributions: resp.body.contributions,\n        });\n    });\n  }\n  tryContribute();\n  setTimeout(updateRetries, 30000);\n}\n\nstate?.sessionID &&\n  state?.finishedContribution &&\n  asyncFetch(\"https://seq.ceremony.ethereum.org/lobby/contribute\", {\n    method: \"POST\",\n    headers: {\n      Authorization: `Bearer ${sessionID}`,\n      \"Content-Type\": \"application/json;charset=utf-8\",\n    },\n    body: JSON.stringify(state.finishedContribution),\n  }).then((res) => {\n    console.log(res);\n    State.update({\n      finished: true,\n    });\n  });\n\nconst entropy = props?.entropy ?? \"a totally random value\";\n\nreturn (\n  <>\n    <Hidden>\n      <iframe\n        srcDoc={code}\n        message={{\n          stage: state?.stage,\n          data:\n            state?.stage === \"calculating\"\n              ? {\n                  contributions: state.contributions,\n                  entropy,\n                }\n              : null,\n        }}\n        onMessage={(val) =>\n          State.update({\n            finishedContribution: val,\n          })\n        }\n      />\n    </Hidden>\n    <Heading>\n      {state?.finished ? \"Congrats\" : \"Lobby\"}\n      <span>\n        <img\n          src={\"https://api.cloudnouns.com/v1/pfp?background=n&size=100&text=l\"}\n        />\n        <img\n          src={\"https://api.cloudnouns.com/v1/pfp?background=n&size=100&text=O\"}\n        />\n        <img\n          src={\"https://api.cloudnouns.com/v1/pfp?background=n&size=100&text=b\"}\n        />\n      </span>\n    </Heading>\n    <Centered>\n      {state?.finished && (\n        <>\n          <Subheading>Congrats!</Subheading>\n          <GrayText>\n            Your message and Noun have been contributed to the KZG summoning\n            ceremony.\n          </GrayText>\n        </>\n      )}\n\n      {!state?.contributions && (\n        <>\n          <Subheading>Waiting for your turn...</Subheading>\n          <GrayText>\n            KZG commitments must be combined one at a time - you may need to\n            wait a while, depending on how many people are in the lobby.\n          </GrayText>\n          <GrayText>\n            Retried <b>{numRetries}</b> times.\n          </GrayText>\n        </>\n      )}\n\n      {!state?.finished && state?.contributions && (\n        <>\n          <Subheading>Cleaning the Prop House...</Subheading>\n          <BlackText>\n            This tab is hard at work mapping your <Glyph>Noun</Glyph> onto a\n            pairing-friendly elliptic curve, so <b>don't</b> close it!\n            <br />\n            <br />\n            <GrayText>\n              Why don't you{\" \"}\n              <a\n                href=\"https://ethereum.org/en/roadmap/danksharding\"\n                target=\"_blank\"\n              >\n                read about KZG in the meantime?\n              </a>\n            </GrayText>\n          </BlackText>\n        </>\n      )}\n    </Centered>\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/chirality.near/widget/NounishKZG.Lobby", "__row_index": 1}