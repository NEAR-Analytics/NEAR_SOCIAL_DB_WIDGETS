{"tx_hash": "J7X7SYtaDZ2BYR5Sp4fTphhyLzxWJL5jabtZhAYScA4e", "action_id_social": "DAMmWj8ddLVpnUfMSAiXUfxRRUrYcw22RWP3AXuK8Tkk-0-widget", "block_id": 93240256, "block_timestamp": "2023-06-01T22:44:21.060Z", "signer_id": "neardigitalcollective.near", "widget_name": "EasyPoll.DisplayVote", "source_code": "if (!props.isPreview && !props.poll) {\n    return \"Property poll not set\";\n  }\n  \n  const isPreview = props.isPreview ?? false;\n  \n  let widgetOwner = \"neardigitalcollective.near\";\n  \n  // Getting question\n  const poll = props.poll;\n  \n  let defaultVotes = [];\n  for (let i = 0; i < poll.value.questions.length; i++) {\n    if (poll.value.questions[i].questionType == \"2\") {\n      defaultVotes.push([\"\"]);\n    } else {\n      defaultVotes.push(\"\");\n    }\n  }\n  \n  State.init({\n    vote: userVote ?? defaultVotes,\n    answers: {},\n    showErrorsInForm: false,\n    hoveringElement: \"\",\n  });\n  \n  let bgBlue = \"#96C0FF\";\n  let bgRed = \"#FFB4B4\";\n  let bgYellow = \"#FFE999\";\n  let bgPurple = \"#E6C0FF\";\n  let bgGreen = \"#96FFE0\";\n  let bgPink = \"#FF96B9\";\n  let bgSkyBlue = \"#96EAFF\";\n  let bgIndigo = \"#96DCD2\";\n  \n  let allBgColors = [\n    bgBlue,\n    bgRed,\n    bgYellow,\n    bgPurple,\n    bgGreen,\n    bgPink,\n    bgSkyBlue,\n    bgIndigo,\n  ];\n  \n  let secondaryBgBlue = \"#E6F0FF\";\n  let secondaryBgRed = \"#FFEDED\";\n  let secondaryBgYellow = \"#FFFAE6\";\n  let secondaryBgPurple = \"#F9F0FF\";\n  let secondaryBgGreen = \"#E6FFF7\";\n  let secondaryBgPink = \"#FFE6EE\";\n  let secondaryBgSkyBlue = \"#E6FAFF\";\n  let secondaryBgIndigo = \"#E6F6F4\";\n  \n  let allSecondaryBgColors = [\n    secondaryBgBlue,\n    secondaryBgRed,\n    secondaryBgYellow,\n    secondaryBgPurple,\n    secondaryBgGreen,\n    secondaryBgPink,\n    secondaryBgSkyBlue,\n    secondaryBgIndigo,\n  ];\n  \n  let fontColorBlue = \"#003E9C\";\n  let fontColorRed = \"#9C2B2B\";\n  let fontColorYellow = \"#9C7B03\";\n  let fontColorPurple = \"#763E9C\";\n  let fontColorGreen = \"#009C6D\";\n  let fontColorPink = \"#9C0034\";\n  let fontColorSkyBlue = \"#007C9C\";\n  let fontColorIndigo = \"#006758\";\n  \n  let allFontColors = [\n    fontColorBlue,\n    fontColorRed,\n    fontColorYellow,\n    fontColorPurple,\n    fontColorGreen,\n    fontColorPink,\n    fontColorSkyBlue,\n    fontColorIndigo,\n  ];\n  \n  let secondaryColor = \"#E9EBF8\";\n  \n  function getBgColor(index, isPrimary) {\n    let allColorsOfThisType =\n      state.vote != `${index}` && isPrimary ? allBgColors : allSecondaryBgColors;\n  \n    return Number.isInteger((index + 1) / allColorsOfThisType.length)\n      ? allColorsOfThisType[0]\n      : allColorsOfThisType[\n          ((index + 1) / allColorsOfThisType.length -\n            Math.trunc((index + 1) / allColorsOfThisType.length)) *\n            allColorsOfThisType.length -\n            1\n        ];\n  }\n  \n  function getFontColor(index) {\n    return Number.isInteger((index + 1) / allFontColors.length)\n      ? allFontColors[0]\n      : allFontColors[\n          ((index + 1) / allFontColors.length -\n            Math.trunc((index + 1) / allFontColors.length)) *\n            allFontColors.length -\n            1\n        ];\n  }\n  \n  function getInputStyles(questionType, questionNumber, optionNumber) {\n    if (questionType == \"2\") {\n      return state.vote[questionNumber].includes(optionNumber + \"\")\n        ? {\n            borderColor: \"black\",\n            backgroundColor: \"black\",\n            width: \"1rem\",\n            marginRight: \"0.7rem\",\n          }\n        : {\n            width: \"1rem\",\n            marginRight: \"0.7rem\",\n          };\n    } else {\n      return optionNumber + \"\" == state.vote[questionNumber]\n        ? {\n            borderColor: \"black\",\n            backgroundColor: \"black\",\n            width: \"1rem\",\n            marginRight: \"0.7rem\",\n          }\n        : {\n            width: \"1rem\",\n            marginRight: \"0.7rem\",\n          };\n    }\n  }\n  \n  // Utility function\n  function getBlockTimestamp(blockHeight) {\n    // It is stored in nanoseconds which is 1e-6 miliseconds\n    return Near.block(blockHeight).header.timestamp / 1e6;\n  }\n  \n  // Discards answers that were posted after question's end date\n  function getTimeRelatedValidAnswers(answers) {\n    let low = 0;\n    let high = answers.length - 1;\n    const questionEndTimestamp = poll.value.endTimestamp;\n    let endBlockTimestamp = getBlockTimestamp(answers[high].blockHeight);\n    if (endBlockTimestamp < questionEndTimestamp) return answers;\n    // For tries to exceed 50 there should be more than 10e15 answers which will never happen. But if you mess up and make an infinite cycle it will crash. This way it will never be infinite\n    let tries = 10;\n    while (high - low > 1 && tries > 0) {\n      tries--;\n      let curr = Math.floor((high - low) / 2) + low;\n      let currBlockTimestamp = getBlockTimestamp(answers[curr].blockHeight);\n      if (currBlockTimestamp < questionEndTimestamp) {\n        low = curr;\n      } else {\n        high = curr;\n      }\n    }\n    // Slice ignores the index of the last one. Since high - low == 1, high = low + 1\n    return answers.slice(0, high);\n  }\n  \n  function getOptionRelatedValidAnswers(answers) {\n    return answers.filter((a) => {\n      const userAnswers = a.value.answer;\n      return userAnswers.every((an, i) => {\n        // If has choicesOptions, then it's needs validation answer is among the options. If not, any answer is just fine\n        if (poll.value.questions[i].choicesOptions.length > 0) {\n          if (Array.isArray(an)) {\n            return an.every(\n              (ans) =>\n                0 <= Number(ans) &&\n                Number(ans) < poll.value.questions[i].choicesOptions.length\n            );\n          } else {\n            return (\n              0 <= Number(an) &&\n              Number(an) < poll.value.questions[i].choicesOptions.length\n            );\n          }\n        } else {\n          return true;\n        }\n      });\n    });\n  }\n  \n  // Getting valid answers\n  const answers = Social.index(\"poll_question\", \"answer-v3.1.0\");\n  \n  if (JSON.stringify(answers) != JSON.stringify(state.answers)) {\n    State.update({ answers: answers });\n  }\n  \n  if (!state.answers) {\n    return \"Loading\";\n  }\n  const answersToThisPoll = state.answers.filter(\n    (a) => a.value.questionBlockHeight == props.poll.blockHeight\n  );\n  function getValidAnswers() {\n    let validTimeAnswers = getTimeRelatedValidAnswers(answersToThisPoll);\n    let validOptionAndTimeAnswers =\n      getOptionRelatedValidAnswers(validTimeAnswers);\n    const validate_addresees = validOptionAndTimeAnswers.filter((item) => {\n      const view = Near.view(\"registry.i-am-human.near\", \"sbt_tokens_by_owner\", {\n        account: item.accountId,\n        issuer: \"gooddollar-v1.i-am-human.near\",\n      });\n      return view?.[0]?.[1]?.[0];\n    });\n    return validate_addresees;\n  }\n  const validAnswersToThisPoll = getValidAnswers(answersToThisPoll);\n  \n  let userVote;\n  // Getting if user has already voted\n  const currAccountId = context.accountId ?? \"\";\n  function userHasVoted() {\n    return (\n      validAnswersToThisPoll.find((a) => a.accountId == currAccountId) !=\n      undefined\n    );\n  }\n  let hasVoted = userHasVoted();\n  const isQuestionOpen =\n    poll.value.startTimestamp < Date.now() &&\n    Date.now() < poll.value.endTimestamp;\n  const canVote = !hasVoted && isQuestionOpen;\n  \n  // Counting votes to display\n  function countVotes(questionNumber, questionType) {\n    if (questionType == \"3\") return;\n    return validAnswersToThisPoll.reduce((acc, curr) => {\n      let ans = curr.value.answer[questionNumber];\n      if (Array.isArray(ans)) {\n        ans.forEach((a) => {\n          acc[Number(a)] += 1;\n        });\n      } else {\n        acc[Number(ans)] += 1;\n      }\n  \n      return acc;\n    }, new Array(poll.value.questions[questionNumber].choicesOptions.length).fill(0));\n  }\n  \n  //TODO review this!\n  const getPublicationParams = () => {\n    return {\n      index: {\n        poll_question: JSON.stringify(\n          {\n            key: \"answer-v3.1.0\",\n            value: {\n              answer: state.vote,\n              questionBlockHeight: props.poll.blockHeight,\n            },\n          },\n          undefined,\n          0\n        ),\n      },\n    };\n  };\n  \n  function isVoteValid() {\n    let isValid = state.vote.length == poll.value.questions.length;\n    isValid = isValid && context.accountId;\n    for (let i = 0; i < state.vote.length; i++) {\n      const vote = state.vote[i];\n      // vote should always be a string, but in one case is treated as an array. Replace array with csv\n      if (Array.isArray(vote)) {\n        isValid = isValid && vote.filter((v) => v.trim() != \"\").length > 0;\n      } else {\n        isValid = isValid && vote.trim() != \"\";\n      }\n    }\n    return isValid;\n  }\n  \n  function calculatePercentage(votesToThisOption) {\n    if (validAnswersToThisPoll.length == 0) return 0;\n    return ((votesToThisOption / validAnswersToThisPoll.length) * 100).toFixed(2);\n  }\n  \n  function calculatePercentageOfOption(votes, index) {\n    const validAnswers = votes.reduce((acc, curr) => acc + curr, 0);\n  \n    if (validAnswers == 0 || votes.length == 0) return 0;\n  \n    const votesToThisOption = votes[index];\n    return ((votesToThisOption / validAnswers) * 100).toFixed(2);\n  }\n  \n  function getBorderRadious(questionNumber, optionNumber) {\n    if (optionNumber == 0) {\n      return \"12px 12px 4px 4px\";\n    } else if (\n      optionNumber ==\n      poll.value.questions[questionNumber].choicesOptions.length - 1\n    ) {\n      return \"4px 4px 12px 12px\";\n    } else {\n      return \"4px\";\n    }\n  }\n  \n  const isValidInput = () => {\n    let result = state.vote != \"\";\n    return result && !isPreview;\n  };\n  \n  const renderAnswers = (questionNumber) => {\n    return (\n      <Widget\n        src={`${widgetOwner}/widget/EasyPoll.AnswerCommentsContainer`}\n        props={{\n          answers: validAnswersToThisPoll,\n          questionNumber,\n        }}\n      />\n    );\n  };\n  \n  function clickRadioInputHandler(questionNumber, optionNumber) {\n    return () => {\n      let newVote = state.vote;\n  \n      newVote[questionNumber] = optionNumber + \"\";\n      State.update({ vote: newVote });\n    };\n  }\n  \n  function clickCheckboxInputHandler(questionNumber, optionNumber) {\n    return () => {\n      let newVote = state.vote;\n  \n      let oldQuestionVotes = newVote[questionNumber];\n      let newQuestionVotes = [];\n  \n      if (!oldQuestionVotes.includes(optionNumber + \"\")) {\n        newQuestionVotes = oldQuestionVotes;\n        newQuestionVotes.push(optionNumber + \"\");\n      } else {\n        for (let i = 0; i < oldQuestionVotes.length; i++) {\n          if (oldQuestionVotes[i] != optionNumber + \"\") {\n            newQuestionVotes.push(oldQuestionVotes[i]);\n          }\n        }\n      }\n  \n      newVote[questionNumber] = newQuestionVotes.filter((a) => a != \"\");\n  \n      State.update({ votes: newVote });\n    };\n  }\n  \n  return (\n    <Widget\n      src={`${widgetOwner}/widget/EasyPoll.DisplayVote2`}\n      props={{\n        state,\n        poll,\n        canVote,\n        getBgColor,\n        getFontColor,\n        countVotes,\n        getBorderRadious,\n        calculatePercentageOfOption,\n        getBlockTimestamp,\n        clickCheckboxInputHandler,\n        clickRadioInputHandler,\n        getInputStyles,\n        hasVoted,\n        getPublicationParams,\n        stateUpdate: (data) => State.update(data),\n        isQuestionOpen,\n        isVoteValid,\n        validAnswersToThisPoll,\n        renderAnswers,\n      }}\n    />\n  );\n  ", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/neardigitalcollective.near/widget/EasyPoll.DisplayVote", "__row_index": 4}