{"tx_hash": "AHqgGQsPGfahGA5sX32YeA1vuHrFZBgKrUa3DQ8xHgfs", "action_id_social": "AEKQdsnDjpCusjboiv7V3cK25YZ43wPN7RUuQDQ3WE91-0-widget", "block_id": 94549693, "block_timestamp": "2023-06-19T16:12:51.341Z", "signer_id": "neardigitalcollective.near", "widget_name": "EasyPoll.DisplayVote", "source_code": "if (!props.isPreview && !props.poll) {\n  return \"Property poll not set\";\n}\n\nif (!props.whitelist) {\n  return \"Property whitelist not set\";\n}\n\nconst isTest = props.isTest;\n\nconst isPreview = props.isPreview ?? false;\nconst indexVersion = props.indexVersion ?? \"3.2.0\";\nconst whitelist = props.whitelist;\n\nlet widgetOwner = \"neardigitalcollective.near\";\n\n// Getting question\nconst poll = props.poll;\n\nState.init({\n  answers: {},\n});\n\n// Utility function\nfunction getBlockTimestamp(blockHeight) {\n  // It is stored in nanoseconds which is 1e-6 miliseconds\n  return Near.block(blockHeight).header.timestamp / 1e6;\n}\n\n// Discards answers that were posted after question's end date\nfunction getTimeRelatedValidAnswers(answers) {\n  let low = 0;\n  let high = answers.length - 1;\n  const questionEndTimestamp = poll.value.endTimestamp;\n  let endBlockTimestamp = getBlockTimestamp(answers[high].blockHeight);\n  if (endBlockTimestamp < questionEndTimestamp) return answers;\n  // For tries to exceed 50 there should be more than 10e15 answers which will never happen. But if you mess up and make an infinite cycle it will crash. This way it will never be infinite\n  let tries = 10;\n  while (high - low > 1 && tries > 0) {\n    tries--;\n    let curr = Math.floor((high - low) / 2) + low;\n    let currBlockTimestamp = getBlockTimestamp(answers[curr].blockHeight);\n    if (currBlockTimestamp < questionEndTimestamp) {\n      low = curr;\n    } else {\n      high = curr;\n    }\n  }\n  // Slice ignores the index of the last one. Since high - low == 1, high = low + 1\n  return answers.slice(0, high);\n}\n\nfunction getOptionRelatedValidAnswers(answers) {\n  return answers.filter((a) => {\n    const userAnswers = a.value.answer;\n    return userAnswers.every((an, i) => {\n      // If has choicesOptions, then it's needs validation answer is among the options. If not, any answer is just fine\n      if (poll.value.questions[i].choicesOptions.length > 0) {\n        if (Array.isArray(an)) {\n          return an.every(\n            (ans) =>\n              0 <= Number(ans) &&\n              Number(ans) < poll.value.questions[i].choicesOptions.length\n          );\n        } else {\n          return (\n            0 <= Number(an) &&\n            Number(an) < poll.value.questions[i].choicesOptions.length\n          );\n        }\n      } else {\n        return true;\n      }\n    });\n  });\n}\n\n// Getting valid answers\nconst answers = isTest\n  ? Social.index(\"poll_question\", `test-answer-v${indexVersion}`)\n  : Social.index(\"poll_question\", `answer-v${indexVersion}`);\n\nif (JSON.stringify(answers) != JSON.stringify(state.answers)) {\n  State.update({ answers: answers });\n}\n\nif (!state.answers) {\n  return \"Loading\";\n}\n\nconst isUserAllowedToVote = (accountId) => {\n  const view = Near.view(\"registry.i-am-human.near\", \"sbt_tokens_by_owner\", {\n    account: accountId,\n    issuer: \"fractal.i-am-human.near\",\n  });\n  const hasSBTToken = view?.[0]?.[1]?.[0];\n  return hasSBTToken || whitelist.includes(accountId);\n};\n\nconst answersToThisPoll = state.answers.filter(\n  (a) => a.value.questionBlockHeight == props.poll.blockHeight\n);\nfunction getValidAnswers() {\n  let validTimeAnswers = getTimeRelatedValidAnswers(answersToThisPoll);\n  let validOptionAndTimeAnswers =\n    getOptionRelatedValidAnswers(validTimeAnswers);\n  const validateAddresses = validOptionAndTimeAnswers.filter((item) => {\n    return isUserAllowedToVote(item.accountId);\n    // const view = Near.view(\"registry.i-am-human.near\", \"sbt_tokens_by_owner\", {\n    //   account: item.accountId,\n    //   issuer: \"fractal.i-am-human.near\",\n    // });\n    // return view?.[0]?.[1]?.[0] /*|| whitelist.includes(item.accountId)*/;\n  });\n  return validateAddresses;\n}\nconst validAnswersToThisPoll = getValidAnswers(answersToThisPoll);\n// Getting if user has already voted\nconst currAccountId = context.accountId ?? \"\";\nfunction userHasVoted() {\n  return (\n    validAnswersToThisPoll.find((a) => a.accountId == currAccountId) !=\n    undefined\n  );\n}\nlet hasVoted = userHasVoted();\nconst isQuestionOpen =\n  poll.value.startTimestamp < Date.now() &&\n  Date.now() < poll.value.endTimestamp;\nconst canVote = !hasVoted && isQuestionOpen;\n\n// Counting votes to display\nfunction countVotes(questionNumber, questionType) {\n  if (questionType == \"3\") return;\n  return validAnswersToThisPoll.reduce((acc, curr) => {\n    let ans = curr.value.answer[questionNumber];\n    if (Array.isArray(ans)) {\n      ans.forEach((a) => {\n        acc[Number(a)] += 1;\n      });\n    } else {\n      acc[Number(ans)] += 1;\n    }\n\n    return acc;\n  }, new Array(poll.value.questions[questionNumber].choicesOptions.length).fill(0));\n}\n\nfunction calculatePercentage(votesToThisOption) {\n  if (validAnswersToThisPoll.length == 0) return 0;\n  return ((votesToThisOption / validAnswersToThisPoll.length) * 100).toFixed(2);\n}\n\nreturn (\n  <Widget\n    src={`${widgetOwner}/widget/EasyPoll.DisplayVote2`}\n    props={{\n      isTest,\n      poll,\n      canVote,\n      countVotes,\n      hasVoted,\n      indexVersion,\n      isQuestionOpen,\n      validAnswersToThisPoll,\n      whitelist,\n    }}\n  />\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/neardigitalcollective.near/widget/EasyPoll.DisplayVote", "__row_index": 0}