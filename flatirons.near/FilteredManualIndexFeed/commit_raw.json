{"tx_hash": "BTHsZPrqtWUeAx6LWpYPXxomVz99xo5tdRZrgDcDgEoX", "action_id_social": "3XqrpRnEAVRC9B2xTYtae1RkQdr8fm2PzsfgP1C9xzsf-0-widget", "block_id": 85963237, "block_timestamp": "2023-02-24 20:25:07.027", "signer_id": "flatirons.near", "widget_name": "FilteredManualIndexFeed", "source_code": "const index = props.index;\nif (!index) {\n  return \"props.index is not defined\";\n}\n\nconst renderItem =\n  props.renderItem ??\n  ((item, i) => (\n    <div key={i}>\n      #{item.blockHeight}: {JSON.stringify(item)}\n    </div>\n  ));\nconst cachedRenderItem = (item, i) => {\n  const key = JSON.stringify(item);\n\n  if (!(key in state.cachedItems)) {\n    state.cachedItems[key] = renderItem(item, i);\n    State.update();\n  }\n  return state.cachedItems[key];\n};\n\nindex.options = index.options || {};\nconst initialRenderLimit =\n  props.initialRenderLimit ?? index.options.limit ?? 10;\nconst addDisplayCount =\n  props.nextLimit ?? initialRenderLimit ?? index.options.limit;\n\nindex.options.limit = Math.min(\n  Math.max(initialRenderLimit + addDisplayCount, index.options.limit),\n  100\n);\nconst reverse = !!props.reverse;\n\nconst initialItems = Social.index(index.action, index.key, index.options);\nif (initialItems === null) {\n  return \"\";\n}\n\nconst computeFetchFrom = (items, limit) => {\n  if (!items || items.length < limit) {\n    return false;\n  }\n  const blockHeight = items[items.length - 1].blockHeight;\n  return index.options.order === \"desc\" ? blockHeight - 1 : blockHeight + 1;\n};\n\nconst mergeItems = (newItems) => {\n  const items = [\n    ...new Set([...newItems, ...state.items].map((i) => JSON.stringify(i))),\n  ].map((i) => JSON.parse(i));\n  items.sort((a, b) => a.blockHeight - b.blockHeight);\n  if (index.options.order === \"desc\") {\n    items.reverse();\n  }\n  return items;\n};\n\nconst jInitialItems = JSON.stringify(initialItems);\nif (state.jInitialItems !== jInitialItems) {\n  const jIndex = JSON.stringify(index);\n  if (jIndex !== state.jIndex) {\n    State.update({\n      jIndex,\n      jInitialItems,\n      items: initialItems,\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(initialItems, index.options.limit),\n      displayCount: initialRenderLimit,\n      cachedItems: {},\n    });\n  } else {\n    State.update({\n      jInitialItems,\n      items: mergeItems(initialItems),\n    });\n  }\n}\n\nif (state.fetchFrom) {\n  const limit = addDisplayCount;\n  const newItems = Social.index(\n    index.action,\n    index.key,\n    Object.assign({}, index.options, {\n      from: state.fetchFrom,\n      subscribe: undefined,\n      limit,\n    })\n  );\n  if (newItems !== null) {\n    State.update({\n      items: mergeItems(newItems),\n      fetchFrom: false,\n      nextFetchFrom: computeFetchFrom(newItems, limit),\n    });\n  }\n}\n\nconst makeMoreItems = () => {\n  State.update({\n    displayCount: state.displayCount + addDisplayCount,\n  });\n  if (\n    state.items.length - state.displayCount < addDisplayCount &&\n    !state.fetchFrom &&\n    state.nextFetchFrom &&\n    state.nextFetchFrom !== state.fetchFrom\n  ) {\n    State.update({\n      fetchFrom: state.nextFetchFrom,\n    });\n  }\n};\n\nconst fetchMore =\n  state.fetchFrom && state.items.length < state.displayCount ? (\n    <div className=\"loader\" key={\"loader\"}>\n      <span\n        className=\"spinner-grow spinner-grow-sm me-1\"\n        role=\"status\"\n        aria-hidden=\"true\"\n      />\n      Loading ...\n    </div>\n  ) : (\n    state.displayCount < state.items.length && (\n      <div key={\"loader more\"}>\n        <a href=\"javascript:void\" onClick={(e) => makeMoreItems()}>\n          {props.loadMoreText ?? \"Load more...\"}\n        </a>\n      </div>\n    )\n  );\n\nlet userReputationHides = [];\nconst query =\n  'query MyQuery { user_centric_user_reputation(where: {base_account_id: {_eq: \"' +\n  context.accountId +\n  '\"}}) { target_account_id } }';\nlet graphqlError = null;\nconst userReputationResponse = fetch(\n  \"https://query-api-hasura-vcqilefdcq-uc.a.run.app/v1/graphql\",\n  {\n    method: \"POST\",\n    headers: {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({ query: query }),\n  }\n);\n\nif (\n  userReputationResponse.status == 200 &&\n  !userReputationResponse.body.errors\n) {\n  userReputationHides =\n    userReputationResponse.body.data.user_centric_user_reputation.map(\n      (a) => a.target_account_id\n    );\n} else {\n  graphqlError = userReputationResponse.body.errors;\n}\n\nconst filteredItems = state.items\n  ? state.items.filter((item) => !userReputationHides.includes(item.accountId))\n  : [];\n\nconst items = filteredItems.slice(0, state.displayCount);\nif (reverse) {\n  items.reverse();\n}\n\nreturn (\n  <>\n    {reverse && fetchMore}\n    {items.map(cachedRenderItem)}\n    {!reverse && fetchMore}\n  </>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/flatirons.near/widget/FilteredManualIndexFeed"}