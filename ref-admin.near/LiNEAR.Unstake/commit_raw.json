{"tx_hash": "ocejM1ZdaaYrgNQxZDLQEkyDGEiXW7vR3E5g5z47ZDv", "action_id_social": "2iLkN1UWSgftzSQ4xygsn2HBU6yFgaQ1ZAPiSNTqFyS4-0-widget", "block_id": 90821656, "block_timestamp": "2023-05-01 02:32:27.807", "signer_id": "ref-admin.near", "widget_name": "LiNEAR.Unstake", "source_code": "/** state init start */\nState.init({\n  unstakeMax: false,\n  inputValue: \"\",\n  inputError: \"\",\n  unstakeType: \"instant\", // instant | delayed\n  showConfirmInstantUnstake: false,\n  showConfirmDelayedUnstake: false,\n  swapEstimate: {},\n  swapAmountIn: \"\",\n  swapAmountOut: \"\",\n});\n/** state init end */\n\n// load config\nconst config = props.config;\nif (!config) {\n  return \"Component not be loaded. Missing `config` props\";\n}\n\n/** common lib start */\nconst accountId = props.accountId || context.accountId;\nconst isSignedIn = !!accountId;\nconst NEAR_DECIMALS = 24;\nconst LiNEAR_DECIMALS = 24;\nconst BIG_ROUND_DOWN = 0;\n\nfunction isValid(a) {\n  if (!a) return false;\n  if (isNaN(Number(a))) return false;\n  if (a === \"\") return false;\n  return true;\n}\n\n/** common lib end */\nfunction getLinearBalance(accountId) {\n  const linearBalanceRaw = Near.view(config.contractId, \"ft_balance_of\", {\n    account_id: accountId,\n  });\n  if (!linearBalanceRaw) return \"-\";\n  const balance = Big(linearBalanceRaw).div(Big(10).pow(LiNEAR_DECIMALS));\n  return balance.lt(0) ? \"0\" : balance.toFixed(5, BIG_ROUND_DOWN);\n}\n\nconst linearBalance = getLinearBalance(accountId);\n\nconst linearPrice = Big(\n  Near.view(config.contractId, \"ft_price\", `{}`) ?? \"0\"\n).div(Big(10).pow(24));\nconst nearPriceInLiNEAR = linearPrice.eq(0)\n  ? \"1\"\n  : Big(1).div(linearPrice).toFixed(5);\n\nfunction getReceivedDelayedUnstakeNear() {\n  const { unstakeMax, inputValue } = state;\n  if (!isValid(linearBalance) || !isValid(inputValue)) {\n    return \"-\";\n  }\n  const delayedUnstakeLiNear = unstakeMax ? linearBalance : inputValue;\n  const _delayedUnstakeNear = Big(delayedUnstakeLiNear)\n    .times(linearPrice)\n    .toFixed(5);\n  return _delayedUnstakeNear;\n}\n\nfunction getReceivedInstantUnstakeNear() {\n  const { inputValue, swapAmountOut } = state;\n  if (\n    !isValid(linearBalance) ||\n    !isValid(inputValue) ||\n    !isValid(swapAmountOut)\n  ) {\n    return Big(0).toFixed(5);\n  }\n  return Big(swapAmountOut).toFixed(5);\n}\n\nconst receivedDelayedUnstakeNear = getReceivedDelayedUnstakeNear();\nconst receivedInstantUnstakeNear = getReceivedInstantUnstakeNear();\nconst UNSTAKE_DIFF_ERROR_RATIO = 0.05;\nconst IMPACT_TOO_HIGH_ERROR = \"Price impact high. Unstake less or try later\";\nif (\n  !state.inputError &&\n  isValid(receivedDelayedUnstakeNear) &&\n  isValid(receivedInstantUnstakeNear) &&\n  state.inputValue === state.swapAmountIn && // compare received NEAR only if the input amounts matches\n  Big(receivedDelayedUnstakeNear)\n    .minus(receivedInstantUnstakeNear)\n    .div(receivedDelayedUnstakeNear)\n    .gt(UNSTAKE_DIFF_ERROR_RATIO)\n) {\n  State.update({\n    inputError: IMPACT_TOO_HIGH_ERROR,\n  });\n} else if (\n  state.inputError === IMPACT_TOO_HIGH_ERROR &&\n  isValid(receivedDelayedUnstakeNear) &&\n  isValid(receivedInstantUnstakeNear) &&\n  state.inputValue === state.swapAmountIn &&\n  Big(receivedDelayedUnstakeNear)\n    .minus(receivedInstantUnstakeNear)\n    .div(receivedDelayedUnstakeNear)\n    .lte(UNSTAKE_DIFF_ERROR_RATIO)\n) {\n  State.update({\n    inputError: \"\",\n  });\n}\n/** events start */\nconst onChange = (e) => {\n  // Has user signed in?\n  if (!isSignedIn) {\n    State.update({\n      unstakeMax: false,\n      inputError: \"Sign in please\",\n    });\n    return;\n  }\n  const targetValue = e.target.value;\n  if (targetValue !== \"\" && !targetValue.match(/^\\d*(\\.\\d*)?$/)) {\n    return;\n  }\n  let unstakeAmount = targetValue.replace(/^0+/, \"0\"); // remove prefix 0\n  // limit 24 decimals\n  const most24DecimalsPattern = /^-?\\d+(\\.\\d{0,24})?/;\n  let values = unstakeAmount.match(most24DecimalsPattern);\n  if (values) {\n    unstakeAmount = values[0];\n  }\n  if (\n    linearBalance &&\n    (isNaN(Number(unstakeAmount)) ||\n      unstakeAmount === \"\" ||\n      Big(unstakeAmount).lt(nearPriceInLiNEAR) ||\n      Big(unstakeAmount).gt(Big(linearBalance)))\n  ) {\n    if (\n      isNaN(Number(unstakeAmount)) ||\n      unstakeAmount === \"\" ||\n      Big(unstakeAmount).lt(nearPriceInLiNEAR)\n    ) {\n      State.update({\n        unstakeMax: false,\n        onClickMax: false,\n        inputValue: unstakeAmount,\n        inputError: `Stake at least ${nearPriceInLiNEAR} LiNEAR`,\n      });\n    } else {\n      State.update({\n        unstakeMax: false,\n        onClickMax: false,\n        inputValue: unstakeAmount,\n        inputError: `Max is ${linearBalance} LiNEAR`,\n      });\n    }\n    return;\n  }\n  State.update({\n    unstakeMax: false,\n    inputValue: unstakeAmount,\n    inputError: \"\",\n  });\n};\n\nconst onClickMax = () => {\n  if (\n    isNaN(Number(linearBalance)) ||\n    linearBalance === \"\" ||\n    Big(linearBalance).lt(nearPriceInLiNEAR)\n  ) {\n    State.update({\n      unstakeMax: true,\n      inputValue: linearBalance,\n      inputError: `Stake at least ${nearPriceInLiNEAR} NEAR`,\n    });\n    return;\n  } else {\n    State.update({\n      unstakeMax: true,\n      inputValue: linearBalance,\n      inputError: \"\",\n    });\n  }\n};\n\nconst onClickUnstake = async () => {\n  const { inputValue, unstakeMax, unstakeType, swapAmountOut } = state;\n  const amount = Big(inputValue)\n    .times(linearPrice)\n    .times(Big(10).pow(LiNEAR_DECIMALS))\n    .toFixed(0);\n\n  if (unstakeType === \"instant\") {\n    callRefSwapTx(\n      TOKEN_LINEAR,\n      TOKEN_NEAR,\n      inputValue,\n      swapAmountOut,\n      SLIPPAGE_TOLERANCE\n    );\n  } else {\n    if (unstakeMax) {\n      Near.call(config.contractId, \"unstake_all\", {});\n    } else {\n      Near.call(config.contractId, \"unstake\", {\n        amount,\n      });\n    }\n  }\n};\n\n// Ref swap constants and functions\n\n// token in and token out of swap\nconst TOKEN_LINEAR = { id: config.contractId, decimals: LiNEAR_DECIMALS };\nconst TOKEN_NEAR = { id: \"NEAR\", decimals: NEAR_DECIMALS };\nconst SLIPPAGE_TOLERANCE = 0.05;\n\nconst REF_EXCHANGE_CONTRACT_ID = \"v2.ref-finance.near\";\nconst WNEAR_CONTRACT_ID = \"wrap.near\";\n\n// Forked from weige.near/widget/ref-swap\nconst registered = Near.view(WNEAR_CONTRACT_ID, \"storage_balance_of\", {\n  account_id: accountId,\n});\n\nconst expandToken = (value, decimals) => {\n  return new Big(value).mul(new Big(10).pow(decimals));\n};\n\nconst callRefSwapTx = (\n  tokenIn,\n  tokenOut,\n  amountIn,\n  amountOut,\n  slippageTolerance\n) => {\n  const tx = [];\n\n  const nearDeposit = {\n    contractName: WNEAR_CONTRACT_ID,\n    methodName: \"near_deposit\",\n    deposit: expandToken(amountIn, 24).toFixed(),\n    gas: expandToken(50, 12),\n  };\n  const nearWithdraw = {\n    contractName: WNEAR_CONTRACT_ID,\n    methodName: \"near_withdraw\",\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      amount: expandToken(amountIn, 24).toFixed(),\n    },\n  };\n\n  if (state.swapEstimate.pool === \"wrap\") {\n    if (tokenIn.id === \"NEAR\") {\n      tx.push(nearDeposit);\n    } else {\n      tx.push(nearWithdraw);\n    }\n\n    return Near.call(tx);\n  }\n\n  if (registered === null) {\n    tx.push({\n      contractName: tokenOut.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenOut.id,\n      methodName: \"storage_deposit\",\n      deposit: expandToken(0.1, 24).toFixed(),\n      gas: expandToken(50, 12),\n      args: {\n        registration_only: true,\n        account_id: accountId,\n      },\n    });\n  }\n\n  if (tokenIn.id === \"NEAR\") {\n    tx.push(nearDeposit);\n  }\n\n  const minAmountOut = expandToken(\n    new Big(amountOut)\n      .mul(1 - Number(slippageTolerance) / 100)\n      .toFixed(tokenOut.decimals, 0),\n    tokenOut.decimals\n  ).toFixed();\n\n  tx.push({\n    methodName: \"ft_transfer_call\",\n    contractName: tokenIn.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenIn.id,\n    gas: expandToken(180, 12),\n    deposit: new Big(\"1\").toFixed(),\n    args: {\n      receiver_id: REF_EXCHANGE_CONTRACT_ID,\n      amount: expandToken(amountIn, tokenIn.decimals).toFixed(0, 0),\n      msg: JSON.stringify({\n        actions: [\n          {\n            pool_id: Number(state.swapEstimate.pool.id),\n            token_in: tokenIn.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenIn.id,\n            token_out: tokenOut.id === \"NEAR\" ? WNEAR_CONTRACT_ID : tokenOut.id,\n            amount_in: expandToken(amountIn, tokenIn.decimals).toFixed(0, 0),\n            min_amount_out: minAmountOut,\n          },\n        ],\n      }),\n    },\n  });\n\n  if (tokenOut.id === \"NEAR\") {\n    tx.push({\n      contractName: WNEAR_CONTRACT_ID,\n      methodName: \"near_withdraw\",\n      deposit: new Big(\"1\").toFixed(),\n      args: {\n        amount: minAmountOut,\n      },\n    });\n  }\n\n  Near.call(tx);\n};\n\n/** events end */\n\nconst disabledStakeButton =\n  !isValid(state.inputValue) || Big(state.inputValue).eq(0) || state.inputError;\n\nconst StakeFormWrapper = styled.div`\n  width: 100%;\n  max-width: 500px;\n  padding-top: 10px;\n  background: #1A2E33;\n  border-radius: 16px;\n  margin-top:20px;\n  padding-bottom:20px;\n  .contentArea{\n    background: #142427;\n    border-radius: 16px;\n    padding:20px 30px;\n  }\n`;\n\nreturn (\n  <StakeFormWrapper>\n    <Widget\n      src={`${config.ownerId}/widget/stake-bannerIcon`}\n      props={{\n        firstIconName: \"LiNEAR\",\n        firstIconUrl:\n          \"https://ipfs.near.social/ipfs/bafkreie2nqrjdjka3ckf4doocsrip5hwqrxh37jzwul2nyzeg3badfl2pm\",\n        secondIconName: \"NEAR\",\n        secondIconUrl:\n          \"https://ipfs.near.social/ipfs/bafkreid5xjykpqdvinmj432ldrkbjisrp3m4n25n4xefd32eml674ypqly\",\n        componentType: \"liNEAR\",\n      }}\n    ></Widget>\n    <div style={{ display: \"none\" }}>\n      <Widget\n        src={`${config.ownerId}/widget/Ref.ref-swap-getEstimate`}\n        props={{\n          config,\n          tokenIn: TOKEN_LINEAR,\n          tokenOut: TOKEN_NEAR,\n          amountIn: state.inputValue || 0,\n          loadRes: (value) => {\n            State.update({\n              swapEstimate: value,\n              swapAmountIn: value === null ? \"\" : value.amountIn,\n              swapAmountOut: value === null ? \"\" : value.estimate,\n            });\n          },\n        }}\n      />\n    </div>\n    <div class=\"contentArea\">\n      <Widget\n        src={`${config.ownerId}/widget/LiNEAR.Input`}\n        props={{\n          placeholder: \"0\",\n          value: state.inputValue,\n          onChange,\n          onClickMax,\n          inputError: state.inputError,\n          balance: `${linearBalance}`,\n        }}\n      />\n      <Widget\n        src={`${config.ownerId}/widget/LiNEAR.Button`}\n        props={{\n          onClick: onClickUnstake,\n          disabled: disabledStakeButton,\n          text: \"Unstake\",\n          type: \"outline\",\n        }}\n      />\n      <Widget\n        src={`${config.ownerId}/widget/LiNEAR.Message.YouWillReceive`}\n        props={{ text: `${receivedInstantUnstakeNear} NEAR` }}\n      />\n    </div>\n    <Widget\n      src={`${config.ownerId}/widget/LiNEAR.Tab`}\n      props={{\n        updateTabName: props.updateTabName,\n        tabName: \"unstake\",\n      }}\n    ></Widget>\n  </StakeFormWrapper>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/ref-admin.near/widget/LiNEAR.Unstake"}