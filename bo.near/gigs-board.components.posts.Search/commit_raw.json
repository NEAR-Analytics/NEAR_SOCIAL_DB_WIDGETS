{"tx_hash": "J6xLuQZDnqctD4wfXa6FerHQvTnnqZvQ7FNVsumvM9at", "action_id_social": "2YAL9hTvYPDVewD6zcikMTiVVMHKznhZGLE1KQMXATof-0-widget", "block_id": 89227245, "block_timestamp": "2023-04-10 02:31:05.583", "signer_id": "bo.near", "widget_name": "gigs-board.components.posts.Search", "source_code": "/* INCLUDE: \"common.jsx\" */\nconst nearDevGovGigsContractAccountId =\n  props.nearDevGovGigsContractAccountId ||\n  (context.widgetSrc ?? \"devgovgigs.near\").split(\"/\", 1)[0];\nconst nearDevGovGigsWidgetsAccountId =\n  props.nearDevGovGigsWidgetsAccountId ||\n  (context.widgetSrc ?? \"devgovgigs.near\").split(\"/\", 1)[0];\n\nfunction widget(widgetName, widgetProps, key) {\n  widgetProps = {\n    ...widgetProps,\n    nearDevGovGigsContractAccountId: props.nearDevGovGigsContractAccountId,\n    nearDevGovGigsWidgetsAccountId: props.nearDevGovGigsWidgetsAccountId,\n    referral: props.referral,\n  };\n  return (\n    <Widget\n      src={`${nearDevGovGigsWidgetsAccountId}/widget/gigs-board.${widgetName}`}\n      props={widgetProps}\n      key={key}\n    />\n  );\n}\n\nfunction href(widgetName, linkProps) {\n  linkProps = { ...linkProps };\n  if (props.nearDevGovGigsContractAccountId) {\n    linkProps.nearDevGovGigsContractAccountId =\n      props.nearDevGovGigsContractAccountId;\n  }\n  if (props.nearDevGovGigsWidgetsAccountId) {\n    linkProps.nearDevGovGigsWidgetsAccountId =\n      props.nearDevGovGigsWidgetsAccountId;\n  }\n  if (props.referral) {\n    linkProps.referral = props.referral;\n  }\n  const linkPropsQuery = Object.entries(linkProps)\n    .map(([key, value]) => `${key}=${value}`)\n    .join(\"&\");\n  return `#/${nearDevGovGigsWidgetsAccountId}/widget/gigs-board.pages.${widgetName}${\n    linkPropsQuery ? \"?\" : \"\"\n  }${linkPropsQuery}`;\n}\n/* END_INCLUDE: \"common.jsx\" */\n\n//////////////////////////////////////////////////////////////////////\n///STOPWORDS//////////////////////////////////////////////////////////\nconst stopWords = [\n  \"about\",\n  \"above\",\n  \"after\",\n  \"again\",\n  \"against\",\n  \"all\",\n  \"and\",\n  \"any\",\n  \"are\",\n  \"because\",\n  \"been\",\n  \"before\",\n  \"being\",\n  \"below\",\n  \"between\",\n  \"both\",\n  \"but\",\n  \"can\",\n  \"cannot\",\n  \"could\",\n  \"did\",\n  \"does\",\n  \"doing\",\n  \"down\",\n  \"during\",\n  \"each\",\n  \"etc\",\n  \"few\",\n  \"for\",\n  \"from\",\n  \"further\",\n  \"had\",\n  \"has\",\n  \"have\",\n  \"having\",\n  \"her\",\n  \"hers\",\n  \"herself\",\n  \"him\",\n  \"himself\",\n  \"his\",\n  \"how\",\n  \"into\",\n  \"its\",\n  \"itself\",\n  \"just\",\n  \"more\",\n  \"most\",\n  \"myself\",\n  \"nor\",\n  \"not\",\n  \"now\",\n  \"off\",\n  \"once\",\n  \"only\",\n  \"other\",\n  \"our\",\n  \"ours\",\n  \"ourselves\",\n  \"out\",\n  \"over\",\n  \"own\",\n  \"same\",\n  \"she\",\n  \"should\",\n  \"some\",\n  \"still\",\n  \"such\",\n  \"than\",\n  \"that\",\n  \"the\",\n  \"their\",\n  \"theirs\",\n  \"them\",\n  \"themselves\",\n  \"then\",\n  \"there\",\n  \"these\",\n  \"they\",\n  \"this\",\n  \"those\",\n  \"through\",\n  \"too\",\n  \"under\",\n  \"until\",\n  \"very\",\n  \"was\",\n  \"were\",\n  \"what\",\n  \"when\",\n  \"where\",\n  \"which\",\n  \"while\",\n  \"who\",\n  \"whom\",\n  \"why\",\n  \"will\",\n  \"with\",\n  \"you\",\n  \"your\",\n  \"yours\",\n  \"yourself\",\n  \"yourselves\",\n  \"www\",\n  \"http\",\n  \"com\",\n];\n\nconst stopWordsDictionary = {};\nfor (let i = 0; i < stopWords.length; i++) {\n  stopWordsDictionary[stopWords[i]] = true;\n}\n\nfunction isStopWord(word) {\n  return stopWordsDictionary.hasOwnProperty(word.toLowerCase());\n}\n//////////////////////////////////////////////////////////////////////\n///SYNONYMS///////////////////////////////////////////////////////////\nconst synonyms = {\n  ether: \"ethereum\",\n  eth: \"ethereum\",\n  either: \"ethereum\",\n  app: \"application\",\n  cryptocyrrency: \"crypto\",\n  developerdao: \"devdao\",\n  dev: \"develop\",\n  doc: \"document\",\n  lib: \"librari\",\n  saw: \"see\",\n  seen: \"see\",\n  tweet: \"twitter\",\n  paid: \"pai\",\n  src: \"sourc\",\n  zk: \"zkp\",\n};\n\nconst applySynonym = (word) => {\n  if (synonyms.hasOwnProperty(word.toLowerCase())) {\n    return synonyms[word];\n  }\n  return word;\n};\n//////////////////////////////////////////////////////////////////////\n///STEMMING///////////////////////////////////////////////////////////\nconst step2list = {\n  ational: \"ate\",\n  tional: \"tion\",\n  enci: \"ence\",\n  anci: \"ance\",\n  izer: \"ize\",\n  bli: \"ble\",\n  alli: \"al\",\n  entli: \"ent\",\n  eli: \"e\",\n  ousli: \"ous\",\n  ization: \"ize\",\n  ation: \"ate\",\n  ator: \"ate\",\n  alism: \"al\",\n  iveness: \"ive\",\n  fulness: \"ful\",\n  ousness: \"ous\",\n  aliti: \"al\",\n  iviti: \"ive\",\n  biliti: \"ble\",\n  logi: \"log\",\n};\n\n/** @type {Record<string, string>} */\nconst step3list = {\n  icate: \"ic\",\n  ative: \"\",\n  alize: \"al\",\n  iciti: \"ic\",\n  ical: \"ic\",\n  ful: \"\",\n  ness: \"\",\n};\n\nconst gt0 = /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)/;\nconst eq1 =\n  /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)([aeiouy][aeiou]*)?$/;\nconst gt1 =\n  /^([^aeiou][^aeiouy]*)?(([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)){2,}/;\nconst vowelInStem = /^([^aeiou][^aeiouy]*)?[aeiouy]/;\nconst consonantLike = /^([^aeiou][^aeiouy]*)[aeiouy][^aeiouwxy]$/;\n\n// Exception expressions.\nconst sfxLl = /ll$/;\nconst sfxE = /^(.+?)e$/;\nconst sfxY = /^(.+?)y$/;\nconst sfxIon = /^(.+?(s|t))(ion)$/;\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/;\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/;\nconst sfxEED = /^(.+?)eed$/;\nconst sfxS = /^.+?[^s]s$/;\nconst sfxSsesOrIes = /^.+?(ss|i)es$/;\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/;\nconst step2 =\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\nconst step4 =\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n\n/**\n * Get the stem from a given value.\n *\n * @param {string} value\n *   Value to stem.\n * @returns {string}\n *   Stem for `value`\n */\n// eslint-disable-next-line complexity\nfunction stemmer(value) {\n  let result = value.toLowerCase();\n\n  // Exit early.\n  if (result.length < 3) {\n    return result;\n  }\n\n  /** @type {boolean} */\n  let firstCharacterWasLowerCaseY = false;\n\n  // Detect initial `y`, make sure it never matches.\n  if (\n    result.codePointAt(0) === 121 // Lowercase Y\n  ) {\n    firstCharacterWasLowerCaseY = true;\n    result = \"Y\" + result.slice(1);\n  }\n\n  // Step 1a.\n  if (sfxSsesOrIes.test(result)) {\n    // Remove last two characters.\n    result = result.slice(0, -2);\n  } else if (sfxS.test(result)) {\n    // Remove last character.\n    result = result.slice(0, -1);\n  }\n\n  /** @type {RegExpMatchArray|null} */\n  let match;\n\n  // Step 1b.\n  if ((match = sfxEED.exec(result))) {\n    if (gt0.test(match[1])) {\n      // Remove last character.\n      result = result.slice(0, -1);\n    }\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\n    result = match[1];\n\n    if (sfxAtOrBlOrIz.test(result)) {\n      // Append `e`.\n      result += \"e\";\n    } else if (sfxMultiConsonantLike.test(result)) {\n      // Remove last character.\n      result = result.slice(0, -1);\n    } else if (consonantLike.test(result)) {\n      // Append `e`.\n      result += \"e\";\n    }\n  }\n\n  // Step 1c.\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\n    // Remove suffixing `y` and append `i`.\n    result = match[1] + \"i\";\n  }\n\n  // Step 2.\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step2list[match[2]];\n  }\n\n  // Step 3.\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\n    result = match[1] + step3list[match[2]];\n  }\n\n  // Step 4.\n  if ((match = step4.exec(result))) {\n    if (gt1.test(match[1])) {\n      result = match[1];\n    }\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\n    result = match[1];\n  }\n\n  // Step 5.\n  if (\n    (match = sfxE.exec(result)) &&\n    (gt1.test(match[1]) ||\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\n  ) {\n    result = match[1];\n  }\n\n  if (sfxLl.test(result) && gt1.test(result)) {\n    result = result.slice(0, -1);\n  }\n\n  // Turn initial `Y` back to `y`.\n  if (firstCharacterWasLowerCaseY) {\n    result = \"y\" + result.slice(1);\n  }\n\n  return result;\n}\n\n//////////////////////////////////////////////////////////////////////\n///SPELLCHECK/////////////////////////////////////////////////////////\nfunction levenshteinDistance(s, t, threshold) {\n  const BIG_NUMBER = 10000;\n  if (s == null || t == null) {\n    return BIG_NUMBER;\n  }\n  if (threshold < 0) {\n    return BIG_NUMBER;\n  }\n  let n = s.length;\n  let m = t.length;\n  if (Math.abs(n - m) >= threshold) {\n    return BIG_NUMBER;\n  }\n\n  // if one string is empty, the edit distance is necessarily the length of the other\n  if (n == 0) {\n    return m <= threshold ? m : BIG_NUMBER;\n  } else if (m == 0) {\n    return n <= threshold ? n : BIG_NUMBER;\n  }\n\n  if (n > m) {\n    // swap the two strings to consume less memory\n    let temp = s;\n    s = t;\n    t = temp;\n    let tempSize = n;\n    n = m;\n    m = tempSize;\n  }\n\n  let p = Array.from({ length: n + 1 }, () => 0); // 'previous' cost array, horizontally\n  let d = Array.from({ length: n + 1 }, () => 0); // cost array, horizontally\n  let _d; // placeholder to assist in swapping p and d\n\n  // fill in starting table values\n  const boundary = Math.min(n, threshold) + 1;\n  for (let i = 0; i < boundary; i++) {\n    p[i] = i;\n  }\n  // these fills ensure that the value above the rightmost entry of our\n  // stripe will be ignored in following loop iterations\n  for (let i = boundary; i < p.length; i++) {\n    p[i] = BIG_NUMBER;\n  }\n  for (let i = 0; i < d.length; i++) {\n    d[i] = BIG_NUMBER;\n  }\n\n  // iterates through t\n  for (let j = 1; j <= m; j++) {\n    const t_j = t.charAt(j - 1); // jth character of t\n    d[0] = j;\n\n    // compute stripe indices, constrain to array size\n    const min = Math.max(1, j - threshold);\n    const max = j > BIG_NUMBER - threshold ? n : Math.min(n, j + threshold);\n\n    // the stripe may lead off of the table if s and t are of different sizes\n    if (min > max) {\n      return BIG_NUMBER;\n    }\n\n    // ignore entry left of leftmost\n    if (min > 1) {\n      d[min - 1] = BIG_NUMBER;\n    }\n\n    // iterates through [min, max] in s\n    for (let i = min; i <= max; i++) {\n      if (s.charAt(i - 1) == t_j) {\n        // diagonally left and up\n        d[i] = p[i - 1];\n      } else {\n        // 1 + minimum of cell to the left, to the top, diagonally left and up\n        d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\n      }\n    }\n\n    // copy current distance counts to 'previous row' distance counts\n    _d = p;\n    p = d;\n    d = _d;\n  }\n  // we don't need to check for threshold here because we did it inside the loop\n  return p[n] <= threshold ? p[n] : BIG_NUMBER;\n}\n\nconst spellcheckQueryProcessing = (query, dictionary) => {\n  // Split text document into words\n  const words = stemAndFilterQuery(query);\n  const dictionaryArray = Object.keys(dictionary);\n  // Iterate over each word in the text\n  for (let i = 0; i < words.length; i++) {\n    let word = words[i].toLowerCase().replace(/[^a-z0-9]/g, \"\");\n\n    // If the word is not in the dictionary, find the closest match\n    if (!dictionary.hasOwnProperty(word)) {\n      let closestMatch = undefined;\n      let closestDistance = word.length;\n      let allowedDistance = Math.min(word.length - 1, 2);\n      // Iterate over each word in the dictionary\n      if (word.length > 1) {\n        for (let j = 0; j < dictionaryArray.length; j++) {\n          let dictWord = dictionaryArray[j];\n          let distance = levenshteinDistance(word, dictWord, allowedDistance);\n\n          // If the distance is less than the closest distance, update the closest match\n          if (distance <= allowedDistance && distance < closestDistance) {\n            closestMatch = dictWord;\n            closestDistance = distance;\n          }\n        }\n      }\n      // Replace the misspelled word with the closest match\n      words[i] = closestMatch;\n    }\n  }\n  return words.filter((word) => !!word);\n};\n\n//////////////////////////////////////////////////////////////////////\n///INDEXER&SEARCH/////////////////////////////////////////////////////\nconst fillDictionaryWith = (dict, text, id) => {\n  let word = \"\";\n  for (let i = 0; i < text.length; i++) {\n    const char = text.charAt(i);\n    const nextChar = text.charAt(i + 1);\n    if (/\\w/.test(char) || (char === \".\" && /\\w/.test(nextChar))) {\n      word += char.toLowerCase();\n    } else if (word.length > 0) {\n      const processedWord = applySynonym(stemmer(word));\n      if (processedWord.length > 1 && !isStopWord(processedWord)) {\n        const oldValue = dict[processedWord] || [];\n        dict[processedWord] = [...oldValue, id];\n      }\n      word = \"\";\n    }\n  }\n  const processedWord = applySynonym(stemmer(word));\n  if (processedWord.length > 1 && !isStopWord(processedWord)) {\n    const oldValue = dict[stemmer(processedWord)] || [];\n    dict[stemmer(processedWord)] = [...oldValue, id];\n  }\n  return dict;\n};\n\nconst buildIndex = (posts) => {\n  let index = {};\n\n  posts.forEach((post) => {\n    const title = post.snapshot.name;\n    const labels = post.snapshot.labels.join(\" \");\n    const text = post.snapshot.description;\n    const postType = post.snapshot.post_type;\n    const authorId = post.author_id;\n    const postText = `${authorId} ${postType} ${title} ${labels} ${text}`;\n    index = fillDictionaryWith(index, postText, post.id);\n  });\n  return index;\n};\n\nconst stemAndFilterQuery = (query) => {\n  return Object.keys(fillDictionaryWith({}, query));\n};\n\nconst sortSearchResult = (searchResult) => {\n  // create a map to count the frequency of each element\n  const freq = new Map();\n  for (const num of searchResult) {\n    freq.set(num, (freq.get(num) || 0) + 1);\n  }\n\n  // define a custom comparison function to sort the array\n  function compare(a, b) {\n    // compare the frequency of the two elements\n    const freqDiff = freq.get(b) - freq.get(a);\n    if (freqDiff !== 0) {\n      return freqDiff; // if they have different frequency, sort by frequency\n    } else {\n      return 0; // if they have the same frequency, leave as it is. Will be sorted by search term, by date\n    }\n  }\n\n  // sort the array using the custom comparison function\n  searchResult.sort(compare);\n  return searchResult.filter(\n    (elem, index) => searchResult.indexOf(elem) === index\n  );\n};\n\nconst search = (processedQueryArray, index) => {\n  return sortSearchResult(\n    processedQueryArray.flatMap((queryWord) => {\n      const termSearchRes = index[queryWord].reverse();\n      const termSortedSearchRes = sortSearchResult(termSearchRes);\n      return termSortedSearchRes;\n    })\n  );\n};\n\n//////////////////////////////////////////////////////////////////////\n///UI&UX//////////////////////////////////////////////////////////////\n//Run search and spelling computation every time the search bar modified\n//but no more frequent than 1 time per 1.5 seconds\nconst amountOfResultsToShowFirst = 5;\n\nconst buildPostsIndex = () => {\n  return Near.asyncView(\"devgovgigs.near\", \"get_posts\").then((posts) => {\n    const index = buildIndex(posts);\n    const data = posts.reduce((acc, post) => {\n      acc[post.id] = post;\n      return acc;\n    }, {});\n    return { index, data };\n  });\n};\n\nconst getProcessedPostsCached = () => {\n  return useCache(() => buildPostsIndex(), \"processedPostsCached\");\n};\n\nif (!state.interval) {\n  let termStorage = \"\";\n  Storage.privateSet(\"term\", \"\");\n  setInterval(() => {\n    const currentInput = Storage.privateGet(\"term\");\n    if (currentInput !== termStorage) {\n      termStorage = currentInput;\n      computeResults(termStorage);\n    }\n  }, 1500);\n  State.update({\n    interval: true,\n  });\n}\n\nconst computeResults = (term) => {\n  const start = new Date().getTime();\n  const processedPostsCached = useCache(\n    () =>\n      buildPostsIndex().then((processedPosts) => {\n        // Run query first time posts retrieved\n        const query = term;\n        const processedQuery = spellcheckQueryProcessing(\n          query,\n          processedPosts.index\n        );\n        const searchResult = search(processedQuery, processedPosts.index);\n        console.log(processedQuery);\n        console.log(searchResult);\n        State.update({\n          searchResult,\n          shownSearchResults: searchResult.slice(0, amountOfResultsToShowFirst),\n          processedQuery,\n          loading: false,\n        });\n        return processedPosts;\n      }),\n    \"processedPostsCached\"\n  );\n  if (processedPostsCached) {\n    // Run query every other time after data retrieved and cached\n    const query = term;\n    const processedQuery = spellcheckQueryProcessing(\n      query,\n      processedPostsCached.index\n    );\n    const searchResult = search(processedQuery, processedPostsCached.index);\n    console.log(processedQuery);\n    console.log(searchResult);\n    State.update({\n      searchResult,\n      shownSearchResults: searchResult.slice(0, 10),\n      processedQuery,\n      loading: false,\n    });\n  }\n  const end = new Date().getTime();\n  console.log(\"search time: \", end - start);\n};\n\nconst updateInput = (term) => {\n  Storage.privateSet(\"term\", term);\n  State.update({\n    term,\n    loading: true,\n  });\n};\n\nconst getSearchResultsKeywordsFor = (postId) => {\n  const index = getProcessedPostsCached().index;\n  return state.processedQuery.filter((queryWord) => {\n    return index[queryWord].includes(postId);\n  });\n};\n\nconst showMoreSearchResults = () => {\n  const shownSearchResults = state.shownSearchResults || [];\n  const newShownSearchResults = state.searchResult.slice(\n    0,\n    shownSearchResults.length + amountOfResultsToShowFirst\n  );\n  State.update({ shownSearchResults: newShownSearchResults });\n};\n\nreturn (\n  <div class=\"pb-2\">\n    <div\n      className=\"d-flex\"\n      style={{\n        height: \"38px\",\n      }}\n    >\n      <div\n        style={{\n          position: \"absolute\",\n          left: \"30px\",\n          display: \"flex\",\n          height: \"38px\",\n          \"align-items\": \"center\",\n        }}\n      >\n        {state.loading ? (\n          <div>\n            <span\n              className=\"spinner-grow spinner-grow-sm me-1\"\n              role=\"status\"\n              aria-hidden=\"true\"\n            />\n          </div>\n        ) : (\n          <div>\ud83d\udd0d</div>\n        )}\n      </div>\n      <input\n        type=\"search\"\n        style={{\n          \"padding-left\": \"40px\",\n        }}\n        className=\"form-control\"\n        value={state.term ?? \"\"}\n        onChange={(e) => updateInput(e.target.value)}\n        placeholder={props.placeholder ?? `Search Posts`}\n      />\n    </div>\n    {state.processedQuery &&\n      state.processedQuery.length > 0 &&\n      state.term.toLowerCase().trim() !== state.processedQuery.join(\" \") && (\n        <div class=\"mb-2\" style={{ \"font-family\": \"monospace\" }}>\n          No results for {state.term}. Looking for\n          <strong>{state.processedQuery.join(\" \")}</strong>:\n        </div>\n      )}\n    {state.term && state.term.length > 1 && state.searchResult\n      ? widget(\"components.posts.List\", {\n          searchResult: {\n            postIds: state.searchResult,\n            keywords: Object.fromEntries(\n              state.searchResult.map((postId) => {\n                return [postId, getSearchResultsKeywordsFor(postId)];\n              })\n            ),\n          },\n          recency: props.recency,\n          label: props.label,\n        })\n      : widget(\"components.posts.List\", {\n          recency: props.recency,\n          label: props.label,\n        })}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/bo.near/widget/gigs-board.components.posts.Search"}