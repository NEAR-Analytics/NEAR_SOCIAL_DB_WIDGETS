{"tx_hash": "2wEkX6g4j8Xa9cxd8vQ2kSxJE5hESMGqJkS72irQ3zLh", "action_id_social": "4bd2hfqzkKsCzKC1BskVWGKfZbTfGskANN1pUGDxezMs-0-widget", "block_id": 89579508, "block_timestamp": "2023-04-14 17:37:18.893", "signer_id": "dorgon108.near", "widget_name": "SearchPopupFunctions", "source_code": "const SEARCH_API_KEY = props.searchApiKey ?? \"0e42c01107b8f555a41bcc0fa7f2a4df\";\nconst APPLICATION_ID = props.appId ?? \"B6PI9UKKJT\";\nconst INDEX = props.index ?? \"prod_near-social-feed\";\nconst API_URL =\n  props.apiUrl ??\n  `https://${APPLICATION_ID}-dsn.algolia.net/1/indexes/${INDEX}/query?`;\nconst INITIAL_PAGE = props.initialPage ?? 0;\nconst facets = props.facets ?? [\"All\", \"Users\", \"Apps\", \"Components\", \"Posts\"];\n\nconst showHeader = props.showHeader ?? true;\nconst showSearchBar = props.showSearchBar ?? true;\nconst showPagination = props.showPagination ?? true;\nconst userId = props.accountId ?? context.accountId;\n\nconst componentsUrl = `/#/calebjacob.near/widget/ComponentsPage`;\nconst peopleUrl = `/#/calebjacob.near/widget/PeoplePage`;\n\n// Styling Specifications\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 48px;\n  padding-bottom: 48px;\n  max-width: 600px;\n  margin: 0 auto;\n`;\n\nconst Header = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n`;\n\nconst Search = styled.div``;\n\nconst Facets = styled.div`\n  overflow: auto;\n  background-color:'red'\n`;\n\nconst H1 = styled.h1`\n  font-weight: 600;\n  font-size: 32px;\n  line-height: 39px;\n  color: #11181c;\n  margin: 0;\n`;\n\nconst H2 = styled.h2`\n  font-weight: 400;\n  font-size: 20px;\n  line-height: 24px;\n  color: #687076;\n  margin: 0;\n`;\n\nconst H3 = styled.h3`\n  color: #687076;\n  font-weight: 600;\n  font-size: 12px;\n  line-height: 15px;\n  text-transform: uppercase;\n  margin: 0;\n`;\n\nconst Group = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 12px;\n`;\n\nconst GroupHeader = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 12px;\n`;\n\nconst Text = styled.p`\n  margin: 0;\n  line-height: 1.5rem;\n  color: ${(p) => (p.bold ? \"#11181C\" : \"#687076\")};\n  font-weight: ${(p) => (p.bold ? \"600\" : \"400\")};\n  font-size: ${(p) => (p.small ? \"12px\" : \"14px\")};\n  overflow: ${(p) => (p.ellipsis ? \"hidden\" : \"\")};\n  text-overflow: ${(p) => (p.ellipsis ? \"ellipsis\" : \"\")};\n  white-space: ${(p) => (p.ellipsis ? \"nowrap\" : \"\")};\n  overflow-wrap: anywhere;\n\n  b {\n    font-weight: 600;\n    color: #11181c;\n  }\n\n  &[href] {\n    color: #006adc;\n    outline: none;\n    font-weight: 600;\n\n    &:hover,\n    &:focus {\n      color: #006adc;\n      text-decoration: underline;\n    }\n  }\n`;\n\n// Update the Footer styling\nconst Footer = styled.div`\n  display: flex;\n  justify-content: right;\n  padding: 24px 0;\nborder-top: 1px solid rgba(96, 109, 122, 0.4);\n`;\n\nconst Button = styled.button`\n  background-color: transparent;\n  border: none;\n  font-size: 14px;\n  font-weight: 600;\n  color: #9799F8;\n  cursor: pointer;\n  padding: 0;\n  text-decoration: underline;\n\n  &:hover {\n    color: #9799F8;\n  }\n`;\n\nconst Items = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  gap: 12px;\n`;\n\nconst Item = styled.div``;\n\n//*********SEARCH FUNCTIONS ******** */\n\n// Reset Search Results\nconst resetSearcheHits = () => {\n  State.update({\n    currentPage: 0,\n    search: undefined,\n    paginate: undefined,\n    facet: undefined,\n  });\n};\n\n// updates search params as the user enters in a search value\nconst writeStateTerm = (term) => {\n  State.update({\n    term,\n  });\n\n  if (term === \"\") {\n    resetSearcheHits();\n  }\n};\n\n// creates an array of profiles\nconst profiles = (records) => {\n  const profiles = [];\n  for (const [i, record] of records ?? []) {\n    profiles.push({\n      accountId: record.author,\n      searchPosition: i,\n    });\n  }\n  return profiles;\n};\n\n// creates an array of objects that provide the details of the loaded posts\nconst posts = (content, postType) => {\n  const posts = [];\n  for (const [i, post] of content || []) {\n    const accountId = post.author;\n    const blockHeight = post.objectID.split(\"/\").slice(-1)[0];\n    const postContent = {\n      type: \"md\",\n      text: post.content,\n    };\n    const headerStyling =\n      postType === \"post\"\n        ? \"border rounded-4 p-3 pb-1\"\n        : \"pt-3 border-top pb-2\";\n\n    posts.push({\n      accountId,\n      blockHeight,\n      postContent,\n      postType,\n      headerStyling,\n      searchPosition: i,\n    });\n  }\n  return posts;\n};\n\n// creates an array of components\nconst components = (records) => {\n  const components = [];\n  for (const [i, component] of records || []) {\n    const idParts = component.objectID.split(\"/\");\n    const widgetName = idParts[idParts.length - 1];\n    const accountId = component.author;\n    components.push({\n      accountId,\n      widgetName,\n      searchPosition: i,\n    });\n  }\n  return components;\n};\n\nconst categorizeSearchHits = (rawResp) => {\n  const results = {};\n  for (const [i, result] of rawResp.hits?.entries()) {\n    const { categories: categories_raw } = result;\n    if (categories_raw.length > 1) {\n      categories_raw.sort();\n    }\n\n    const categories = categories_raw.join(\", \");\n    results[categories] = results[categories] || [];\n    results[categories].push([i + 1, result]);\n  }\n  return {\n    results,\n    hitsTotal: rawResp.nbHits,\n    hitsPerPage: rawResp.hitsPerPage,\n  };\n};\n\nconst debounce = (callable, timeout) => {\n  return (args) => {\n    clearTimeout(state.timer);\n    State.update({\n      timer: setTimeout(() => callable(args), timeout ?? 50),\n    });\n  };\n};\n\nconst fetchSearchHits = (query, { pageNumber, configs, optionalFilters }) => {\n  configs = configs ?? configsPerFacet(state.facet);\n  let body = {\n    query,\n    page: pageNumber ?? 0,\n    hitsPerPage: rawResp.hitsPerPage,\n    optionalFilters: optionalFilters ?? [\n      \"categories:profile<score=3>\",\n      \"categories:widget<score=2>\",\n      \"categories:post<score=1>\",\n      \"categories:comment<score=0>\",\n    ],\n    clickAnalytics: true,\n    ...configs,\n  };\n  return asyncFetch(API_URL, {\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json; charset=UTF-8\",\n      \"X-Algolia-Api-Key\": SEARCH_API_KEY,\n      \"X-Algolia-Application-Id\": APPLICATION_ID,\n    },\n    method: \"POST\",\n  });\n};\n\nconst updateSearchHits = debounce(({ term, pageNumber, configs }) => {\n  fetchSearchHits(term, { pageNumber, configs }).then((resp) => {\n    const { results, hitsTotal, hitsPerPage } = categorizeSearchHits(resp.body);\n    State.update({\n      search: {\n        profiles: profiles(results[\"profile\"]),\n        components: components(results[\"widget\"]),\n        postsAndComments: posts(results[\"post\"], \"post\").concat(\n          posts(results[\"comment, post\"], \"comment\")\n        ),\n      },\n      currentPage: 0,\n      paginate: {\n        hitsTotal,\n        hitsPerPage,\n      },\n      queryID: resp.body.queryID,\n    });\n  });\n}, 300);\n\nconst onSearchChange = ({ term }) => {\n  writeStateTerm(term);\n  updateSearchHits({ term, pageNumber: INITIAL_PAGE });\n};\n\nconst onPageChange = (pageNumber) => {\n  const algoliaPageNumber = pageNumber - 1;\n  if (algoliaPageNumber === state.currentPage) {\n    console.log(`Selected the same page number as before: ${pageNumber}`);\n    return;\n  }\n  // Need to clear out old search data otherwise we'll get multiple entries\n  // from the previous pages as well. Seems to be cache issue on near.social.\n  State.update({\n    search: undefined,\n    currentPage: algoliaPageNumber,\n  });\n  updateSearchHits({ term: state.term, pageNumber: algoliaPageNumber });\n};\n\nconst FACET_TO_CATEGORY = {\n  Users: \"profile\",\n  Apps: \"app\",\n  Components: \"widget\",\n  Posts: \"post\",\n};\n\nconst searchFilters = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let filters = category ? `categories:${category}` : undefined;\n  if (category === \"post\") {\n    filters = `(${filters} OR categories:comment)`;\n  }\n  if (category === \"app\") {\n    filters = `(${filters} OR tags:app)`;\n  }\n  if (filters) {\n    filters = `${filters} AND `;\n  }\n  filters = `${filters}NOT author:hypefairy.near AND NOT _tags:hidden`;\n\n  return filters;\n};\n\nconst restrictSearchable = (facet) => {\n  const category = FACET_TO_CATEGORY[facet];\n  let restrictSearchableAttrs = undefined;\n  if (category === \"post\") {\n    // Only the content should be searchable when the posts facet is selected.\n    restrictSearchableAttrs = [\"content\"];\n  }\n  return restrictSearchableAttrs;\n};\n\nconst configsPerFacet = (facet) => {\n  return {\n    filters: searchFilters(facet),\n    restrictSearchableAttributes: restrictSearchable(facet),\n  };\n};\n\nconst onFacetClick = (facet) => {\n  if (facet === state.facet) {\n    console.log(\"Clicked the same facet\");\n    return;\n  }\n\n  State.update({\n    facet,\n  });\n\n  updateSearchHits({\n    term: state.term,\n    configs: configsPerFacet(facet),\n  });\n};\n\nconst onSearchResultClick = ({ searchPosition, objectID, eventName }) => {\n  const position =\n    searchPosition + state.currentPage * state.paginate.hitsPerPage;\n  const event = {\n    type: \"clickedObjectIDsAfterSearch\",\n    data: {\n      eventName,\n      userToken: userId.replace(\".\", \"+\"),\n      queryID: state.queryID,\n      objectIDs: [objectID],\n      positions: [position],\n      timestamp: Date.now(),\n    },\n  };\n\n  // Deferred due to State.update causing multiple clicks to be needed\n  // before the browser redirect to the page the user clicks on.\n  setTimeout(() => {\n    // This will trigger the Insights widget:\n    State.update({ event });\n  }, 50);\n};\n\nconst topTwoHits = () => {\n  const twoEl = state.search.profiles.slice(0, 2) ?? [];\n\n  return twoEl.map((profile, i) => (\n    <Item key={profile.accountId}>\n      <Widget\n        src=\"dorgon108.near/widget/AccountProfileCard\"\n        props={{\n          accountId: profile.accountId,\n          onClick: () =>\n            onSearchResultClick({\n              searchPosition: profile.searchPosition,\n              objectID: `${profile.accountId}/profile`,\n              eventName: \"Clicked Profile After Search\",\n            }),\n        }}\n      />\n    </Item>\n  ));\n};\n\nconst topTwoComponents = () => {\n  const topTwoComponentsArray = [\n    state.search.components[0],\n    state.search.components[1],\n  ];\n\n  return topTwoComponentsArray.map((component, i) => (\n    <Item key={component.accountId + component.widgetName}>\n      <Widget\n        src=\"dorgon108.near/widget/ComponentCard\"\n        props={{\n          src: `${component.accountId}/widget/${component.widgetName}`,\n          onClick: () =>\n            onSearchResultClick({\n              searchPosition: component.searchPosition,\n              objectID: `${component.accountId}/widget/${component.widgetName}`,\n              eventName: \"Clicked Component After Search\",\n            }),\n        }}\n      />\n    </Item>\n  ));\n};\n\nconst topTwoComments = () => {\n  const twoCommentsArray = [\n    state.search.postsAndComments[0],\n    state.search.postsAndComments[1],\n  ];\n  return twoCommentsArray.map((post, i) => (\n    <Item key={`${post.accountId}/${post.postType}/${post.blockHeight}`}>\n      <Widget\n        src=\"chaotictempest.near/widget/SearchPost\"\n        props={{\n          accountId: post.accountId,\n          blockHeight: post.blockHeight,\n          content: post.postContent,\n        }}\n      />\n    </Item>\n  ));\n};\n\nif (props.term !== state.lastSyncedTerm) {\n  console.log(props.term);\n  State.update({\n    lastSyncedTerm: props.term,\n  });\n  onSearchChange({ term: props.term });\n}\n\nreturn (\n  <Wrapper>\n    {state.search && (\n      <Facets>\n        <Widget\n          src=\"dorgon108.near/widget/Facets\"\n          props={{\n            facets,\n            onFacetClick,\n            defaultFacet: facets[0],\n          }}\n        />\n      </Facets>\n    )}\n\n    {state.paginate?.hitsTotal == 0 && (\n      <H2>No matches were found for \"{state.term}\".</H2>\n    )}\n\n    {state.search?.profiles.length > 0 && (\n      <Group>\n        <GroupHeader>\n          <H3>\n            Users\n            <span\n              style={{\n                marginLeft: \"10px\",\n              }}\n            >\n              {` ${state.search?.profiles.length ?? 0}`}\n            </span>{\" \"}\n          </H3>\n        </GroupHeader>\n\n        <Items>{topTwoHits()}</Items>\n      </Group>\n    )}\n\n    {state.search?.components.length > 0 && (\n      <Group>\n        <GroupHeader>\n          <H3>\n            Components{\" \"}\n            <span\n              style={{\n                marginLeft: \"10px\",\n              }}\n            >\n              {` ${state.search?.components.length ?? 0}`}\n            </span>{\" \"}\n          </H3>\n        </GroupHeader>\n\n        <Items>{topTwoComponents()}</Items>\n      </Group>\n    )}\n\n    <Footer>\n      <a\n        href={`https://alpha.near.org/chaotictempest.near/widget/Search?term=${props.term}`}\n      >\n        <Button\n          onClick={() => {\n            console.log(\"redirect you sir/miss)\");\n          }}\n        >\n          See All\n        </Button>\n      </a>\n    </Footer>\n\n    {!props.disableInsights && (\n      <Widget\n        src=\"chaotictempest.near/widget/Insights\"\n        props={{\n          event: state.event,\n          searchApiKey: SEARCH_API_KEY,\n          appId: APPLICATION_ID,\n          index: INDEX,\n        }}\n      />\n    )}\n  </Wrapper>\n);\n", "metadata": null, "branch": NaN, "widget_modules_used": null, "widget_url": "https://near.social/#/dorgon108.near/widget/SearchPopupFunctions", "branch.draft.": NaN, "branch.draft.metadata": NaN}