{"tx_hash": "9G5491kEzhsuWodV7aRTeGKewGenU2tLzekHPwcvxhJy", "action_id_social": "BuG8VhxS4WySht4Q8hAaBE3veVkox9cyKWJEgNWrKk29-0-widget", "block_id": 83920591, "block_timestamp": "2023-01-27 15:22:10.523", "signer_id": "silkking.near", "widget_name": "voteWithText", "source_code": "State.init({ vote: \"\", showErrorsInForm: false, questions: {}, answers: {} });\r\n\r\nif (!props.isPreview && !props.blockHeight) {\r\n  return \"Property blockHeight not set\";\r\n}\r\n\r\n// Utility function\r\nfunction getBlockTimestamp(blockHeight) {\r\n  // It is stored in nanoseconds which is 1e-6 miliseconds\r\n  return Near.block(blockHeight).header.timestamp / 1e6;\r\n}\r\n\r\nfunction getQuestion(blockHeight) {\r\n  const questions = Social.index(\"poll_question\", \"question-v3.0.1\");\r\n\r\n  if (JSON.stringify(questions) != JSON.stringify(state.questions)) {\r\n    State.update({ questions: questions });\r\n  }\r\n  if (!questions) {\r\n    return \"Loading\";\r\n  }\r\n  return questions.find((q) => q.blockHeight == blockHeight);\r\n}\r\n\r\nlet widgetOwner =\r\n  \"f2bc8abdb8ba64fe5aac9689ded9491ff0e6fdcd7a5c680b7cf364142d1789fb\";\r\n\r\n// Discards answers that were posted after question's end date\r\nfunction getTimeRelatedValidAnswers(answers) {\r\n  const questionParams = getQuestion(props.blockHeight);\r\n  let low = 0;\r\n  let high = answers.length - 1;\r\n  const questionEndTimestamp = questionParams.value.endTimestamp;\r\n  let endBlockTimestamp = getBlockTimestamp(answers[high].blockHeight);\r\n  if (endBlockTimestamp < questionEndTimestamp) return answers;\r\n  // For tries to exceed 50 there should be more than 10e15 answers which will never happen. But if you mess up and make an infinite cycle it will crash. This way it will never be infinite\r\n  let tries = 50;\r\n  while (high - low > 1 && tries > 0) {\r\n    tries--;\r\n    let curr = Math.floor((high - low) / 2) + low;\r\n    let currBlockTimestamp = getBlockTimestamp(answers[curr].blockHeight);\r\n    if (currBlockTimestamp < questionEndTimestamp) {\r\n      low = curr;\r\n    } else {\r\n      high = curr;\r\n    }\r\n  }\r\n  // Slice ignores the index of the last one. Since high - low == 1, high = low + 1\r\n  return answers.slice(0, high);\r\n}\r\n\r\nlet isPreview = props.isPreview;\r\nconst questionBlockHeight = props.blockHeight;\r\n\r\nconst answers = Social.index(\"poll_question\", \"answer-v3.0.1\");\r\n\r\nif (JSON.stringify(answers) != JSON.stringify(state.answers)) {\r\n  State.update({ answers: answers });\r\n}\r\n\r\nif (!answers) {\r\n  return \"Loading\";\r\n}\r\nconst answersToThisQuestion = answers.filter(\r\n  (a) => a.value.questionBlockHeight == questionBlockHeight\r\n);\r\nconst onTimeAnswersToThisQuestion = getTimeRelatedValidAnswers(\r\n  answersToThisQuestion\r\n);\r\n\r\nlet usersThatAlreadyReplied = [];\r\nlet validAnswersToThisQuestion = onTimeAnswersToThisQuestion.filter((a) => {\r\n  const didUserAlreadyVoted = usersThatAlreadyReplied.includes(a.accountId);\r\n  if (!didUserAlreadyVoted) {\r\n    usersThatAlreadyReplied.push(a.accountId);\r\n  }\r\n  return !didUserAlreadyVoted;\r\n});\r\n\r\nlet userVote;\r\nconst loggedAccountId = context.accountId ?? \"\";\r\nfunction userHasVoted() {\r\n  return (\r\n    answersToThisQuestion.find((a) => a.accountId == loggedAccountId) !=\r\n    undefined\r\n  );\r\n}\r\nlet hasVoted = userHasVoted();\r\n\r\nconst getPublicationParams = () => {\r\n  return {\r\n    index: {\r\n      poll_question: JSON.stringify(\r\n        {\r\n          key: \"answer-v3.0.1\",\r\n          value: {\r\n            answer: state.vote,\r\n            questionBlockHeight: props.blockHeight,\r\n          },\r\n        },\r\n        undefined,\r\n        0\r\n      ),\r\n    },\r\n  };\r\n};\r\n\r\nconst isValidInput = () => {\r\n  let result = state.vote != \"\";\r\n  return result && !isPreview;\r\n};\r\n\r\nconst renderAnswers = () => {\r\n  return validAnswersToThisQuestion.map((answer) => {\r\n    return (\r\n      <div style={{ maxWidth: \"45%\" }}>\r\n        <Widget\r\n          src={`${widgetOwner}.near/widget/answer_poll-comment-container`}\r\n          props={{ blockHeight: answer.blockHeight }}\r\n        />\r\n      </div>\r\n    );\r\n  });\r\n};\r\n\r\nreturn (\r\n  <div>\r\n    {hasVoted ? (\r\n      <div className=\"d-flex justify-content-between flex-wrap\">\r\n        {renderAnswers()}\r\n      </div>\r\n    ) : (\r\n      <div>\r\n        <textarea\r\n          value={state.vote}\r\n          onChange={(e) => State.update({ vote: e.target.value })}\r\n          style={{ width: \"100%\" }}\r\n        />\r\n\r\n        {isValidInput() ? (\r\n          <CommitButton\r\n            className=\"my-2 btn btn-primary\"\r\n            data={getPublicationParams()}\r\n          >\r\n            Done\r\n          </CommitButton>\r\n        ) : (\r\n          <button\r\n            className=\"my-2 btn btn-primary\"\r\n            onClick={() => State.update({ showErrorsInForm: true })}\r\n          >\r\n            Done\r\n          </button>\r\n        )}\r\n      </div>\r\n    )}\r\n    <p\r\n      style={{\r\n        fontWeight: \"500\",\r\n        fontSize: \"1.1rem\",\r\n        color: \"#767B8E\",\r\n        letterSpacing: \"-0.02em\",\r\n        marginTop: \"0.8rem\",\r\n      }}\r\n    >\r\n      {validAnswersToThisQuestion.length} votes\r\n    </p>\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/voteWithText"}