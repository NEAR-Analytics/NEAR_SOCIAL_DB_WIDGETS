{"tx_hash": "4uoKWR9KUrfXAP7aNHqmp7grYGS1b1uomKcXwgR6aBEA", "action_id_social": "ACgZ62yGZz6TGWsxqLqyUKSNFypy29iW9FJANsmBbi8z-0-widget", "block_id": 80657500, "block_timestamp": "2022-12-14 21:14:17.775", "signer_id": "silkking.near", "widget_name": "newMiniMultipleChoiceInterface", "source_code": "if (!props.blockHeight) {\n  return \"Property blockHeight not set\";\n}\n\n// Utility function. Consider moving it to an utility widget\nfunction getBlockTimestamp(blockHeight) {\n  // It is stored in nanoseconds which is 1e-6 miliseconds\n  return Near.block(blockHeight).header.timestamp / 1e6;\n}\n\n// Discards answers that were posted after question's end date. Consider moving to utility widget\nfunction getTimeRelatedValidAnswers(answers) {\n  let low = 0;\n  let high = answers.length - 1;\n  const questionEndTimestamp = questionParams.value.endTimestamp;\n  let endBlockTimestamp = getBlockTimestamp(answers[high].blockHeight);\n  if (endBlockTimestamp < questionEndTimestamp) return answers;\n  // For tries to exceed 50 there should be more than 10e15 answers which will never happen. But if you mess up and make an infinite cycle it will crash. This way it will never be infinite\n  let tries = 50;\n  while (high - low > 1 && tries > 0) {\n    tries--;\n    let curr = Math.floor((high - low) / 2) + low;\n    let currBlockTimestamp = getBlockTimestamp(answers[curr].blockHeight);\n    if (currBlockTimestamp < questionEndTimestamp) {\n      low = curr;\n    } else {\n      high = curr;\n    }\n  }\n  // Slice ignores the index of the last one. Since high - low == 1, high = low + 1\n  return answers.slice(0, high);\n}\n\nconst questionBlockHeight = Number(props.blockHeight);\nconst questions = Social.index(\"poll_question\", \"question-v3.0.1\");\nconst questionParams = questions.find(\n  (q) => q.blockHeight == questionBlockHeight\n);\nState.init({ vote: \"\", showErrorsInForm: false });\n\nconst answers = Social.index(\"poll_question\", \"answer-v3.0.1\");\nconst answersToThisQuestion = answers.filter(\n  (a) => a.value.questionBlockHeight == questionBlockHeight\n);\nlet usersWithAnswersToThisQuestion = [];\nlet validAnswersToThisQuestion = answersToThisQuestion.filter((a) => {\n  const didUserAlreadyAnswered = usersWithAnswersToThisQuestion.includes(\n    a.accountId\n  );\n  if (!didUserAlreadyAnswered) {\n    usersWithAnswersToThisQuestion.push(a.accountId);\n  }\n  return !didUserAlreadyAnswered;\n});\nvalidAnswersToThisQuestion = getTimeRelatedValidAnswers(\n  validAnswersToThisQuestion\n);\n\nfunction calculatePercentage(votesToThisOption) {\n  if (validAnswersToThisQuestion.length == 0) return 100;\n  return (votesToThisOption / validAnswersToThisQuestion.length) * 100;\n}\n\nconst currAccId = context.accountId ?? \"\";\nconst userHasVoted = validAnswersToThisQuestion.find(\n  (a) => a.accountId == currAccId\n);\nconst isQuestionOpen =\n  questionParams.value.startTimestamp < Date.now() &&\n  Date.now() < questionParams.value.endTimestamp;\nconst displayAnswers = userHasVoted || !isQuestionOpen;\n\nlet countVotes = new Array(questionParams.value.choicesOptions.length).fill(0);\ncountVotes = !userHasVoted\n  ? countVotes\n  : validAnswersToThisQuestion.reduce((acc, curr) => {\n      const ans = curr.value.answer;\n      const isValidAnswer =\n        !isNaN(ans) &&\n        Number(ans) >= 0 &&\n        Number(ans) < questionParams.value.choicesOptions.length;\n      if (isValidAnswer) {\n        acc[Number(ans)] += 1;\n        return acc;\n      } else {\n        return acc;\n      }\n    }, countVotes);\n\nfunction displayableOptionName(option) {\n  if (option.length > 20) {\n    return option.slice(0, 20) + \"...\";\n  }\n  return option;\n}\n\nconst renderOption = (option, index) => {\n  return (\n    <div className=\"d-flex\">\n      <div style={{ color: \"#000\", width: \"90%\" }}>\n        {/* Set the width of the next div to make the bar grow. At the same, use the same value to fill the span tag */}\n        <div\n          style={{\n            margin: \"0.3rem 0px\",\n            content: \"\",\n            display: \"table\",\n            clear: \"both\",\n            padding: \"0.01em 16px\",\n            display: \"inline-block\",\n            width: `${calculatePercentage(countVotes[index])}%`,\n            textAlign: \"center\",\n            overflow: \"visible\",\n            whiteSpace: \"nowrap\",\n            textAlign: \"left\",\n            backgroundColor: \"lightgray\",\n          }}\n        >\n          <span style={{ overflow: \"visible\", fontWeight: \"500\" }}>\n            {displayableOptionName(option)}\n            <span\n              className=\"text-secondary\"\n              style={{ marginLeft: \"1rem\", fontWeight: \"400\" }}\n            >\n              {displayAnswers && `(${countVotes[index]} votes)`}\n            </span>\n          </span>\n        </div>\n      </div>\n      <span\n        style={{\n          minWidth: \"max-content\",\n          marginLeft: \"0.3rem\",\n          fontWeight: \"500\",\n        }}\n      >\n        {displayAnswers && `${calculatePercentage(countVotes[index])}%`}\n      </span>\n    </div>\n  );\n};\n\nreturn (\n  <div className=\"m-2\">\n    {questionParams.value.choicesOptions.map((option, index) => {\n      return renderOption(option, index);\n    })}\n  </div>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/silkking.near/widget/newMiniMultipleChoiceInterface"}