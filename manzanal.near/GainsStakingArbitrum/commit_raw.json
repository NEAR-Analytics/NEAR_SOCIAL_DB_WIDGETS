{"tx_hash": "7mh94Z8AjttUXPkgxA57VzQAstsKK97uQPCb9Y1cdstr", "action_id_social": "5mXPfnc5csZZNP33zmaz9NxaanFwwnoWE3FeJ8qfZQp6-0-widget", "block_id": 88315479, "block_timestamp": "2023-03-28 19:02:54.323", "signer_id": "manzanal.near", "widget_name": "GainsStakingArbitrum", "source_code": "const gainsStakingContract = \"0x6B8D3C08072a020aC065c467ce922e3A36D3F9d6\";\nconst gainsTokenContract = \"0x18c11FD286C5EC11c3b683Caa813B77f5163A122\";\nconst tokenDecimals = 18;\nconst fetchAbiRaw = (contract) => {\n  return fetch(\n    `https://raw.githubusercontent.com/leomanza/ETHDubaiHackathon/main/abis/gains/${contract}`\n  );\n};\nlet stakingAbi = fetchAbiRaw(gainsStakingContract);\nlet tokenAbi = fetchAbiRaw(gainsTokenContract);\nconst arbitrumApr = fetch(\"https://backend-arbitrum.gains.trade/apr\", {\n  subscribe: true,\n});\n\nif (!stakingAbi.ok && !tokenAbi.ok && !arbitrumApr) {\n  return \"Loading\";\n}\nstakingAbi = JSON.parse(stakingAbi.body);\ntokenAbi = JSON.parse(tokenAbi.body);\nconst iface = new ethers.utils.Interface(stakingAbi);\nconst tokenIFace = new ethers.utils.Interface(tokenAbi);\n\nState.init({\n  apr: arbitrumApr.body.sssBaseApr.toFixed(2),\n});\nconst formatBigNumber = (big) => {\n  return Big(big)\n    .div(Big(10).pow(tokenDecimals))\n    .toFixed(4)\n    .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n};\nconst getStakedBalance = (receiver) => {\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: iface.encodeFunctionData(\"users\", [receiver]),\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"users\",\n        rawBalance\n      );\n      State.update({ rawStaked: receiverBalanceHex.stakedTokens.toString() });\n      State.update({\n        rawBoost: receiverBalanceHex.totalBoostTokens.toString(),\n      });\n      State.update({ rawDebtDai: receiverBalanceHex.debtDai.toString() });\n      return formatBigNumber(receiverBalanceHex.stakedTokens.toString());\n    });\n};\nconst getRewardBalance = () => {\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: iface.encodeFunctionData(\"accDaiPerToken\"),\n    })\n    .then((accDaiPerToken) => {\n      const DaiPerToken = iface.decodeFunctionResult(\n        \"accDaiPerToken\",\n        accDaiPerToken\n      );\n      const daiReward =\n        ((parseFloat(state.rawStaked) + parseFloat(state.rawBoost)) *\n          parseFloat(DaiPerToken.toString())) /\n          1e18 -\n        state.rawDebtDai;\n\n      return formatBigNumber(daiReward.toString());\n    });\n};\nconst getTokenBalance = (receiver) => {\n  return Ethers.provider()\n    .call({\n      to: gainsTokenContract,\n      data: tokenIFace.encodeFunctionData(\"balanceOf\", [receiver]),\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\n        \"balanceOf\",\n        rawBalance\n      );\n      return formatBigNumber(receiverBalanceHex.toString());\n    });\n};\nconst getTokenAllowance = (receiver) => {\n  return Ethers.provider()\n    .call({\n      to: gainsTokenContract,\n      data: tokenIFace.encodeFunctionData(\"allowance\", [\n        receiver,\n        gainsStakingContract,\n      ]),\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = tokenIFace.decodeFunctionResult(\n        \"allowance\",\n        rawBalance\n      )[0];\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(2);\n    });\n};\nconst stakeTokens = (tokenAmount) => {\n  if (!tokenAmount || tokenAmount > state.balance) {\n    return;\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi,\n    Ethers.provider().getSigner()\n  );\n  erc20\n    .stakeTokens(ethers.utils.parseEther(state.tokenAmount))\n    .then((transactionHash) => transactionHash.wait())\n    .then((receipt) => {\n      getTokenBalance(state.sender).then((balance) => {\n        State.update({ balance });\n      });\n      getStakedBalance(state.sender).then((stakedBalance) => {\n        State.update({ stakedBalance });\n      });\n      getRewardBalance().then((rewards) => {\n        State.update({ rewards });\n      });\n      State.update({ tokenAmount: 0 });\n    });\n};\nconst unStakeTokens = () => {\n  if (parseFloat(state.stakedBalance) == 0) {\n    return;\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi,\n    Ethers.provider().getSigner()\n  );\n  erc20\n    .unstakeTokens(ethers.utils.parseEther(state.stakedBalance))\n    .then((transactionHash) => transactionHash.wait())\n    .then((receipt) => {\n      getTokenBalance(state.sender).then((balance) => {\n        State.update({ balance });\n      });\n      getStakedBalance(state.sender).then((stakedBalance) => {\n        State.update({ stakedBalance });\n      });\n      getRewardBalance().then((rewards) => {\n        State.update({ rewards });\n      });\n    });\n};\nconst harverstRewards = () => {\n  if (!(state.rewards > 0) && state.sender) {\n    return;\n  }\n  const erc20 = new ethers.Contract(\n    gainsStakingContract,\n    stakingAbi,\n    Ethers.provider().getSigner()\n  );\n  erc20\n    .harvest()\n    .then((transactionHash) => transactionHash.wait())\n    .then((response) => {\n      State.update({ rewards: 0 });\n    });\n};\nconst updateTokenAmount = (tokenAmount) => {\n  State.update({ tokenAmount: tokenAmount });\n};\nconst approveToken = () => {\n  const erc20 = new ethers.Contract(\n    gainsTokenContract,\n    tokenAbi,\n    Ethers.provider().getSigner()\n  );\n  const maxAllowance =\n    \"115792089237316195423570985008687907853269984665640564039457584007913129639935\";\n  erc20\n    .approve(gainsStakingContract, maxAllowance)\n    .then((transactionHash) => transactionHash.wait())\n    .then((receipt) => {\n      State.update({\n        allowance: Big(maxAllowance).div(Big(10).pow(tokenDecimals)).toFixed(2),\n      });\n    });\n};\nconst getTotalRewardDistributed = () => {\n  const encodedData = iface.encodeFunctionData(\"totalRewardsDistributedDai\");\n  return Ethers.provider()\n    .call({\n      to: gainsStakingContract,\n      data: encodedData,\n    })\n    .then((rawBalance) => {\n      const receiverBalanceHex = iface.decodeFunctionResult(\n        \"totalRewardsDistributedDai\",\n        rawBalance\n      );\n      return Big(receiverBalanceHex.toString())\n        .div(Big(10).pow(tokenDecimals))\n        .toFixed(4)\n        .replace(/\\d(?=(\\d{3})+\\.)/g, \"$&,\");\n    });\n};\nif (state.sender === undefined) {\n  const accounts = Ethers.send(\"eth_requestAccounts\", []);\n  if (accounts.length) {\n    State.update({ sender: accounts[0] });\n  }\n}\nif (state.sender && !state.totalRewards) {\n  getTotalRewardDistributed().then((totalRewards) => {\n    State.update({ totalRewards });\n  });\n}\nif (state.sender && state.balance === undefined) {\n  getTokenBalance(state.sender).then((balance) => {\n    State.update({ balance });\n  });\n}\nif (state.sender && state.stakedBalance === undefined) {\n  getStakedBalance(state.sender).then((stakedBalance) => {\n    State.update({ stakedBalance });\n  });\n}\nif (state.sender && state.allowance == undefined) {\n  getTokenAllowance(state.sender).then((allowance) => {\n    State.update({ allowance });\n  });\n}\nif (state.sender && state.rewards == undefined) {\n  getRewardBalance().then((rewards) => {\n    State.update({ rewards });\n  });\n}\nconst renderContent = () => {\n  return (\n    <>\n      <Widget\n        src=\"manzanal.near/widget/GainStakingArbitrum.Info\"\n        props={{ state, unStakeTokens, harverstRewards }}\n      />\n      <Widget\n        src=\"manzanal.near/widget/GainStakingArbitrum.StakeForm\"\n        props={{ state, updateTokenAmount, approveToken, stakeTokens }}\n      />\n    </>\n  );\n};\nreturn (\n  <Widget\n    src=\"manzanal.near/widget/StakingTheme\"\n    props={{ children: renderContent() }}\n  />\n);\n", "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/manzanal.near/widget/GainsStakingArbitrum", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.name": NaN, "metadata.tags.app": NaN, "metadata.tags.arbitrum": NaN, "metadata.tags.ethdubai2023": NaN, "metadata": NaN}