{"tx_hash": "3GkBcmPHjyBJDo8Uw37Cb7CXJhMGk9wUtmoxzZKQxKug", "action_id_social": "7knAyJCzgqnDuSYcksLEHAaYNbwQKU6qDfp8WAp124jd-0-widget", "block_id": 86374022, "block_timestamp": "2023-03-02 07:54:24.112", "signer_id": "p516entropy.near", "widget_name": "test_p516", "source_code": "//////////////////////////////////////////////////////////////////////\r\n///STOPWORDS//////////////////////////////////////////////////////////\r\nconst stopWords = [\r\n  \"about\",\r\n  \"above\",\r\n  \"after\",\r\n  \"again\",\r\n  \"against\",\r\n  \"all\",\r\n  \"and\",\r\n  \"any\",\r\n  \"are\",\r\n  \"because\",\r\n  \"been\",\r\n  \"before\",\r\n  \"being\",\r\n  \"below\",\r\n  \"between\",\r\n  \"both\",\r\n  \"but\",\r\n  \"can\",\r\n  \"cannot\",\r\n  \"could\",\r\n  \"did\",\r\n  \"does\",\r\n  \"doing\",\r\n  \"down\",\r\n  \"during\",\r\n  \"each\",\r\n  \"etc\",\r\n  \"few\",\r\n  \"for\",\r\n  \"from\",\r\n  \"further\",\r\n  \"had\",\r\n  \"has\",\r\n  \"have\",\r\n  \"having\",\r\n  \"her\",\r\n  \"here\",\r\n  \"hers\",\r\n  \"herself\",\r\n  \"him\",\r\n  \"himself\",\r\n  \"his\",\r\n  \"how\",\r\n  \"into\",\r\n  \"its\",\r\n  \"itself\",\r\n  \"just\",\r\n  \"more\",\r\n  \"most\",\r\n  \"myself\",\r\n  \"nor\",\r\n  \"not\",\r\n  \"now\",\r\n  \"off\",\r\n  \"once\",\r\n  \"only\",\r\n  \"other\",\r\n  \"our\",\r\n  \"ours\",\r\n  \"ourselves\",\r\n  \"out\",\r\n  \"over\",\r\n  \"own\",\r\n  \"same\",\r\n  \"she\",\r\n  \"should\",\r\n  \"some\",\r\n  \"still\",\r\n  \"such\",\r\n  \"than\",\r\n  \"that\",\r\n  \"the\",\r\n  \"their\",\r\n  \"theirs\",\r\n  \"them\",\r\n  \"themselves\",\r\n  \"then\",\r\n  \"there\",\r\n  \"these\",\r\n  \"they\",\r\n  \"this\",\r\n  \"those\",\r\n  \"through\",\r\n  \"too\",\r\n  \"under\",\r\n  \"until\",\r\n  \"very\",\r\n  \"was\",\r\n  \"were\",\r\n  \"what\",\r\n  \"when\",\r\n  \"where\",\r\n  \"which\",\r\n  \"while\",\r\n  \"who\",\r\n  \"whom\",\r\n  \"why\",\r\n  \"will\",\r\n  \"with\",\r\n  \"you\",\r\n  \"your\",\r\n  \"yours\",\r\n  \"yourself\",\r\n  \"yourselves\",\r\n  \"www\",\r\n  \"http\",\r\n  \"com\",\r\n];\r\n\r\nconst stopWordsDictionary = {};\r\nfor (let i = 0; i < stopWords.length; i++) {\r\n  stopWordsDictionary[stopWords[i]] = true;\r\n}\r\n\r\nfunction isStopWord(word) {\r\n  return stopWordsDictionary.hasOwnProperty(word.toLowerCase());\r\n}\r\n//////////////////////////////////////////////////////////////////////\r\n///SYNONYMS///////////////////////////////////////////////////////////\r\nconst synonyms = {\r\n  ether: \"ethereum\",\r\n  eth: \"ethereum\",\r\n  either: \"ethereum\",\r\n  app: \"application\",\r\n  cryptocyrrency: \"crypto\",\r\n  developerdao: \"devdao\",\r\n  dev: \"develop\",\r\n  doc: \"document\",\r\n  lib: \"librari\",\r\n  saw: \"see\",\r\n  seen: \"see\",\r\n  tweet: \"twitter\",\r\n  paid: \"pai\",\r\n  src: \"sourc\",\r\n};\r\n\r\nconst applySynonym = (word) => {\r\n  if (synonyms.hasOwnProperty(word.toLowerCase())) {\r\n    return synonyms[word];\r\n  }\r\n  return word;\r\n};\r\n//////////////////////////////////////////////////////////////////////\r\n///STEMMING///////////////////////////////////////////////////////////\r\nconst step2list = {\r\n  ational: \"ate\",\r\n  tional: \"tion\",\r\n  enci: \"ence\",\r\n  anci: \"ance\",\r\n  izer: \"ize\",\r\n  bli: \"ble\",\r\n  alli: \"al\",\r\n  entli: \"ent\",\r\n  eli: \"e\",\r\n  ousli: \"ous\",\r\n  ization: \"ize\",\r\n  ation: \"ate\",\r\n  ator: \"ate\",\r\n  alism: \"al\",\r\n  iveness: \"ive\",\r\n  fulness: \"ful\",\r\n  ousness: \"ous\",\r\n  aliti: \"al\",\r\n  iviti: \"ive\",\r\n  biliti: \"ble\",\r\n  logi: \"log\",\r\n};\r\n\r\n/** @type {Record<string, string>} */\r\nconst step3list = {\r\n  icate: \"ic\",\r\n  ative: \"\",\r\n  alize: \"al\",\r\n  iciti: \"ic\",\r\n  ical: \"ic\",\r\n  ful: \"\",\r\n  ness: \"\",\r\n};\r\n\r\nconst gt0 = /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)/;\r\nconst eq1 =\r\n  /^([^aeiou][^aeiouy]*)?([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)([aeiouy][aeiou]*)?$/;\r\nconst gt1 =\r\n  /^([^aeiou][^aeiouy]*)?(([aeiouy][aeiou]*)([^aeiou][^aeiouy]*)){2,}/;\r\nconst vowelInStem = /^([^aeiou][^aeiouy]*)?[aeiouy]/;\r\nconst consonantLike = /^([^aeiou][^aeiouy]*)[aeiouy][^aeiouwxy]$/;\r\n\r\n// Exception expressions.\r\nconst sfxLl = /ll$/;\r\nconst sfxE = /^(.+?)e$/;\r\nconst sfxY = /^(.+?)y$/;\r\nconst sfxIon = /^(.+?(s|t))(ion)$/;\r\nconst sfxEdOrIng = /^(.+?)(ed|ing)$/;\r\nconst sfxAtOrBlOrIz = /(at|bl|iz)$/;\r\nconst sfxEED = /^(.+?)eed$/;\r\nconst sfxS = /^.+?[^s]s$/;\r\nconst sfxSsesOrIes = /^.+?(ss|i)es$/;\r\nconst sfxMultiConsonantLike = /([^aeiouylsz])\\1$/;\r\nconst step2 =\r\n  /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\r\nconst step3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\r\nconst step4 =\r\n  /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\r\n\r\n/**\r\n * Get the stem from a given value.\r\n *\r\n * @param {string} value\r\n *   Value to stem.\r\n * @returns {string}\r\n *   Stem for `value`\r\n */\r\n// eslint-disable-next-line complexity\r\nfunction stemmer(value) {\r\n  let result = value.toLowerCase();\r\n\r\n  // Exit early.\r\n  if (result.length < 3) {\r\n    return result;\r\n  }\r\n\r\n  /** @type {boolean} */\r\n  let firstCharacterWasLowerCaseY = false;\r\n\r\n  // Detect initial `y`, make sure it never matches.\r\n  if (\r\n    result.codePointAt(0) === 121 // Lowercase Y\r\n  ) {\r\n    firstCharacterWasLowerCaseY = true;\r\n    result = \"Y\" + result.slice(1);\r\n  }\r\n\r\n  // Step 1a.\r\n  if (sfxSsesOrIes.test(result)) {\r\n    // Remove last two characters.\r\n    result = result.slice(0, -2);\r\n  } else if (sfxS.test(result)) {\r\n    // Remove last character.\r\n    result = result.slice(0, -1);\r\n  }\r\n\r\n  /** @type {RegExpMatchArray|null} */\r\n  let match;\r\n\r\n  // Step 1b.\r\n  if ((match = sfxEED.exec(result))) {\r\n    if (gt0.test(match[1])) {\r\n      // Remove last character.\r\n      result = result.slice(0, -1);\r\n    }\r\n  } else if ((match = sfxEdOrIng.exec(result)) && vowelInStem.test(match[1])) {\r\n    result = match[1];\r\n\r\n    if (sfxAtOrBlOrIz.test(result)) {\r\n      // Append `e`.\r\n      result += \"e\";\r\n    } else if (sfxMultiConsonantLike.test(result)) {\r\n      // Remove last character.\r\n      result = result.slice(0, -1);\r\n    } else if (consonantLike.test(result)) {\r\n      // Append `e`.\r\n      result += \"e\";\r\n    }\r\n  }\r\n\r\n  // Step 1c.\r\n  if ((match = sfxY.exec(result)) && vowelInStem.test(match[1])) {\r\n    // Remove suffixing `y` and append `i`.\r\n    result = match[1] + \"i\";\r\n  }\r\n\r\n  // Step 2.\r\n  if ((match = step2.exec(result)) && gt0.test(match[1])) {\r\n    result = match[1] + step2list[match[2]];\r\n  }\r\n\r\n  // Step 3.\r\n  if ((match = step3.exec(result)) && gt0.test(match[1])) {\r\n    result = match[1] + step3list[match[2]];\r\n  }\r\n\r\n  // Step 4.\r\n  if ((match = step4.exec(result))) {\r\n    if (gt1.test(match[1])) {\r\n      result = match[1];\r\n    }\r\n  } else if ((match = sfxIon.exec(result)) && gt1.test(match[1])) {\r\n    result = match[1];\r\n  }\r\n\r\n  // Step 5.\r\n  if (\r\n    (match = sfxE.exec(result)) &&\r\n    (gt1.test(match[1]) ||\r\n      (eq1.test(match[1]) && !consonantLike.test(match[1])))\r\n  ) {\r\n    result = match[1];\r\n  }\r\n\r\n  if (sfxLl.test(result) && gt1.test(result)) {\r\n    result = result.slice(0, -1);\r\n  }\r\n\r\n  // Turn initial `Y` back to `y`.\r\n  if (firstCharacterWasLowerCaseY) {\r\n    result = \"y\" + result.slice(1);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n///SPELLCHECK/////////////////////////////////////////////////////////\r\nfunction levenshteinDistance(s, t, threshold) {\r\n  const BIG_NUMBER = 10000;\r\n  if (s == null || t == null) {\r\n    return BIG_NUMBER;\r\n  }\r\n  if (threshold < 0) {\r\n    return BIG_NUMBER;\r\n  }\r\n  let n = s.length;\r\n  let m = t.length;\r\n  if (Math.abs(n - m) >= threshold) {\r\n    return BIG_NUMBER;\r\n  }\r\n\r\n  // if one string is empty, the edit distance is necessarily the length of the other\r\n  if (n == 0) {\r\n    return m <= threshold ? m : BIG_NUMBER;\r\n  } else if (m == 0) {\r\n    return n <= threshold ? n : BIG_NUMBER;\r\n  }\r\n\r\n  if (n > m) {\r\n    // swap the two strings to consume less memory\r\n    let temp = s;\r\n    s = t;\r\n    t = temp;\r\n    let tempSize = n;\r\n    n = m;\r\n    m = tempSize;\r\n  }\r\n\r\n  let p = Array.from({ length: n + 1 }, () => 0); // 'previous' cost array, horizontally\r\n  let d = Array.from({ length: n + 1 }, () => 0); // cost array, horizontally\r\n  let _d; // placeholder to assist in swapping p and d\r\n\r\n  // fill in starting table values\r\n  const boundary = Math.min(n, threshold) + 1;\r\n  for (let i = 0; i < boundary; i++) {\r\n    p[i] = i;\r\n  }\r\n  // these fills ensure that the value above the rightmost entry of our\r\n  // stripe will be ignored in following loop iterations\r\n  for (let i = boundary; i < p.length; i++) {\r\n    p[i] = BIG_NUMBER;\r\n  }\r\n  for (let i = 0; i < d.length; i++) {\r\n    d[i] = BIG_NUMBER;\r\n  }\r\n\r\n  // iterates through t\r\n  for (let j = 1; j <= m; j++) {\r\n    const t_j = t.charAt(j - 1); // jth character of t\r\n    d[0] = j;\r\n\r\n    // compute stripe indices, constrain to array size\r\n    const min = Math.max(1, j - threshold);\r\n    const max = j > BIG_NUMBER - threshold ? n : Math.min(n, j + threshold);\r\n\r\n    // the stripe may lead off of the table if s and t are of different sizes\r\n    if (min > max) {\r\n      return BIG_NUMBER;\r\n    }\r\n\r\n    // ignore entry left of leftmost\r\n    if (min > 1) {\r\n      d[min - 1] = BIG_NUMBER;\r\n    }\r\n\r\n    // iterates through [min, max] in s\r\n    for (let i = min; i <= max; i++) {\r\n      if (s.charAt(i - 1) == t_j) {\r\n        // diagonally left and up\r\n        d[i] = p[i - 1];\r\n      } else {\r\n        // 1 + minimum of cell to the left, to the top, diagonally left and up\r\n        d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);\r\n      }\r\n    }\r\n\r\n    // copy current distance counts to 'previous row' distance counts\r\n    _d = p;\r\n    p = d;\r\n    d = _d;\r\n  }\r\n  // we don't need to check for threshold here because we did it inside the loop\r\n  return p[n] <= threshold ? p[n] : BIG_NUMBER;\r\n}\r\n\r\nconst spellcheckQueryProcessing = (query, dictionary) => {\r\n  // Split text document into words\r\n  const words = stemAndFilterQuery(query);\r\n  const dictionaryArray = Object.keys(dictionary);\r\n  // Iterate over each word in the text\r\n  for (let i = 0; i < words.length; i++) {\r\n    let word = words[i].toLowerCase().replace(/[^a-z0-9]/g, \"\");\r\n\r\n    // If the word is not in the dictionary, find the closest match\r\n    if (!dictionary.hasOwnProperty(word)) {\r\n      let closestMatch = undefined;\r\n      let closestDistance = word.length;\r\n      let allowedDistance = Math.min(word.length - 1, 3);\r\n      // Iterate over each word in the dictionary\r\n      if (word.length > 2) {\r\n        for (let j = 0; j < dictionaryArray.length; j++) {\r\n          let dictWord = dictionaryArray[j];\r\n          let distance = levenshteinDistance(word, dictWord, allowedDistance);\r\n\r\n          // If the distance is less than the closest distance, update the closest match\r\n          if (distance <= allowedDistance && distance < closestDistance) {\r\n            closestMatch = dictWord;\r\n            closestDistance = distance;\r\n          }\r\n        }\r\n      }\r\n      // Replace the misspelled word with the closest match\r\n      words[i] = closestMatch;\r\n    }\r\n  }\r\n  return words.filter((word) => !!word);\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n///INDEXER&SEARCH/////////////////////////////////////////////////////\r\nconst fillDictionaryWith = (dict, text, id) => {\r\n  let word = \"\";\r\n  for (let i = 0; i < text.length; i++) {\r\n    const char = text.charAt(i);\r\n    if (/\\w/.test(char)) {\r\n      word += char.toLowerCase();\r\n    } else if (word.length > 0) {\r\n      const processedWord = applySynonym(stemmer(word));\r\n      if (processedWord.length > 2 && !isStopWord(processedWord)) {\r\n        const oldValue = dict[processedWord] || [];\r\n        dict[processedWord] = [...oldValue, id];\r\n      }\r\n      word = \"\";\r\n    }\r\n  }\r\n  const processedWord = applySynonym(stemmer(word));\r\n  if (processedWord.length > 2 && !isStopWord(processedWord)) {\r\n    const oldValue = dict[stemmer(processedWord)] || [];\r\n    dict[stemmer(processedWord)] = [...oldValue, id];\r\n  }\r\n  return dict;\r\n};\r\n\r\nconst buildIndex = (posts) => {\r\n  let index = {};\r\n\r\n  posts.forEach((post) => {\r\n    const title = post.snapshot.name;\r\n    const labels = post.snapshot.labels.join(\" \");\r\n    const text = post.snapshot.description;\r\n    const postText = `${title} ${labels} ${text}`;\r\n    index = fillDictionaryWith(index, postText, post.id);\r\n  });\r\n\r\n  return index;\r\n};\r\n\r\nconst stemAndFilterQuery = (query) => {\r\n  return Object.keys(fillDictionaryWith({}, query));\r\n};\r\n\r\nconst sortSearchResult = (searchResult) => {\r\n  // create a map to count the frequency of each element\r\n  const freq = new Map();\r\n  for (const num of searchResult) {\r\n    freq.set(num, (freq.get(num) || 0) + 1);\r\n  }\r\n\r\n  // define a custom comparison function to sort the array\r\n  function compare(a, b) {\r\n    // compare the frequency of the two elements\r\n    const freqDiff = freq.get(b) - freq.get(a);\r\n    if (freqDiff !== 0) {\r\n      return freqDiff; // if they have different frequency, sort by frequency\r\n    } else {\r\n      return b - a; // if they have the same frequency, sort by value\r\n    }\r\n  }\r\n\r\n  // sort the array using the custom comparison function\r\n  searchResult.sort(compare);\r\n  return searchResult.filter(\r\n    (elem, index) => searchResult.indexOf(elem) === index\r\n  );\r\n};\r\n\r\nconst search = (processedQueryArray, index) => {\r\n  return sortSearchResult(\r\n    processedQueryArray.flatMap((queryWord) => index[queryWord])\r\n  );\r\n};\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n///UI&UX//////////////////////////////////////////////////////////////\r\n//Run search and spelling computation every time the search bar modified\r\n//but no more frequent than 1 time per 1.5 seconds\r\nif (!state.interval) {\r\n  let termStorage = \"\";\r\n  Storage.privateSet(\"term\", \"\");\r\n  setInterval(() => {\r\n    const currentInput = Storage.privateGet(\"term\");\r\n    if (currentInput !== termStorage) {\r\n      console.log(\"run computation\");\r\n      termStorage = currentInput;\r\n      computeResults(termStorage);\r\n    }\r\n  }, 1500);\r\n  State.update({\r\n    interval: true,\r\n  });\r\n}\r\n\r\nconst buildPostsIndex = () => {\r\n  return Near.asyncView(\"devgovgigs.near\", \"get_posts\").then((posts) => {\r\n    const index = buildIndex(posts);\r\n    const data = posts.reduce((acc, post) => {\r\n      acc[post.id] = post;\r\n      return acc;\r\n    }, {});\r\n    return { index, data };\r\n  });\r\n};\r\n\r\nconst getProcessedPostsCached = () => {\r\n  return useCache(() => buildPostsIndex(), \"processedPostsCached\");\r\n};\r\n\r\nconst computeResults = (term) => {\r\n  const start = new Date().getTime();\r\n  const processedPostsCached = useCache(\r\n    () =>\r\n      buildPostsIndex().then((processedPosts) => {\r\n        // Run query first time posts retrieved\r\n        const query = term;\r\n        const processedQuery = spellcheckQueryProcessing(\r\n          query,\r\n          processedPosts.index\r\n        );\r\n        const searchResult = search(processedQuery, processedPosts.index);\r\n        console.log(processedQuery);\r\n        console.log(searchResult);\r\n        State.update({ searchResult, processedQuery, loading: false });\r\n        return processedPosts;\r\n      }),\r\n    \"processedPostsCached\"\r\n  );\r\n  if (processedPostsCached) {\r\n    // Run query every other time after data retrieved and cached\r\n    const query = term;\r\n    const processedQuery = spellcheckQueryProcessing(\r\n      query,\r\n      processedPostsCached.index\r\n    );\r\n    const searchResult = search(processedQuery, processedPostsCached.index);\r\n    console.log(processedQuery);\r\n    console.log(searchResult);\r\n    State.update({ searchResult, processedQuery, loading: false });\r\n  }\r\n  const end = new Date().getTime();\r\n\r\n  console.log(end - start);\r\n};\r\n\r\nconst updateInput = (term) => {\r\n  Storage.privateSet(\"term\", term);\r\n  State.update({\r\n    term,\r\n    loading: true,\r\n  });\r\n};\r\n\r\nreturn (\r\n  <div class=\"p-2\">\r\n    <div\r\n      className=\"d-flex\"\r\n      style={{\r\n        height: \"38px\",\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          position: \"absolute\",\r\n          left: \"30px\",\r\n          display: \"flex\",\r\n          height: \"38px\",\r\n          \"align-items\": \"center\",\r\n        }}\r\n      >\r\n        {state.loading ? (\r\n          <div>\r\n            <span\r\n              className=\"spinner-grow spinner-grow-sm me-1\"\r\n              role=\"status\"\r\n              aria-hidden=\"true\"\r\n            />\r\n          </div>\r\n        ) : (\r\n          <div>\ud83d\udd0d</div>\r\n        )}\r\n      </div>\r\n      <input\r\n        type=\"search\"\r\n        style={{\r\n          \"padding-left\": \"40px\",\r\n        }}\r\n        className=\"form-control\"\r\n        value={state.term ?? \"\"}\r\n        onChange={(e) => updateInput(e.target.value)}\r\n        placeholder={props.placeholder ?? `Search Posts`}\r\n      />\r\n    </div>\r\n    {state.processedQuery &&\r\n      state.processedQuery.length > 0 &&\r\n      state.term.toLowerCase().trim() !== state.processedQuery.join(\" \") && (\r\n        <div class=\"mb-2\" style={{ \"font-family\": \"cursive\" }}>\r\n          Technical stuff: Looking for\r\n          <strong>{state.processedQuery.join(\" \")}</strong>\r\n        </div>\r\n      )}\r\n\r\n    {state.searchResult &&\r\n      state.searchResult.slice(0, 10).map((postId) => {\r\n        return (\r\n          <div key={postId}>\r\n            <Widget\r\n              src={`devgovgigs.near/widget/gigs-board.components.posts.Post`}\r\n              props={{ post: getProcessedPostsCached().data[postId] }}\r\n              key={key}\r\n            />\r\n          </div>\r\n        );\r\n      })}\r\n  </div>\r\n);\r\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/p516entropy.near/widget/test_p516"}