{"tx_hash": "3gAbBRKG2KKGD92zwFZ7rk9cBspcPTqdytzopByoNKEi", "action_id_social": "6M8v1Ki8qptPfeZQmNUstY18iZBBEDp8Dg8dNwqkvgQb-0-widget", "block_id": 86491342, "block_timestamp": "2023-03-03 21:42:25.673", "signer_id": "markeljan.near", "widget_name": "MarkdownDiff", "source_code": "/*\nCredit goes to bozon.near/widget/CodeDiff\nChanges made to styles and to support markdown.\n---props---\ncurrentCode: string,\nprevCode?: string,\n\nfindUniqueResult(\n  lineCountDeleted: number, \n  lineCountInserted: inserted,\n  lineCountCurrentCode: number,\n  lineCountPrevCode: number,\n  allLineCount: number\n)?: function\n\naddStyle?: Object,\ndeleteStyle?: Object\n\nshowLineNumber?: bool\n\n*/\n\nif (typeof props?.currentCode !== \"string\")\n  return \"send {currentCode: string} in props\";\n\n//code from this - https://github.com/jonTrent/PatienceDiff\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\n  //\n  // findUnique finds all unique values in arr[lo..hi], inclusive.  This\n  // function is used in preparation for determining the longest common\n  // subsequence.  Specifically, it first reduces the array range in question\n  // to unique values.\n  //\n  // Returns an ordered Map, with the arr[i] value as the Map key and the\n  // array index i as the Map value.\n  //\n\n  function findUnique(arr, lo, hi) {\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n      let line = arr[i];\n\n      if (lineMap.has(line)) {\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n      } else {\n        lineMap.set(line, {\n          count: 1,\n          index: i,\n        });\n      }\n    }\n\n    lineMap.forEach((val, key) => {\n      if (val.count !== 1) {\n        lineMap.delete(key);\n      } else {\n        lineMap.set(key, val.index);\n      }\n    });\n\n    return lineMap;\n  }\n\n  //\n  // uniqueCommon finds all the unique common entries between aArray[aLo..aHi]\n  // and bArray[bLo..bHi], inclusive.  This function uses findUnique to pare\n  // down the aArray and bArray ranges first, before then walking the comparison\n  // between the two arrays.\n  //\n  // Returns an ordered Map, with the Map key as the common line between aArray\n  // and bArray, with the Map value as an object containing the array indexes of\n  // the matching unique lines.\n  //\n\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key) => {\n      if (mb.has(key)) {\n        ma.set(key, {\n          indexA: val,\n          indexB: mb.get(key),\n        });\n      } else {\n        ma.delete(key);\n      }\n    });\n\n    return ma;\n  }\n\n  //\n  // longestCommonSubsequence takes an ordered Map from the function uniqueCommon\n  // and determines the Longest Common Subsequence (LCS).\n  //\n  // Returns an ordered array of objects containing the array indexes of the\n  // matching lines for a LCS.\n  //\n\n  function longestCommonSubsequence(abMap) {\n    const ja = [];\n\n    // First, walk the list creating the jagged array.\n\n    abMap.forEach((val, key, map) => {\n      let i = 0;\n\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n        i++;\n      }\n\n      if (!ja[i]) {\n        ja[i] = [];\n      }\n\n      if (0 < i) {\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\n      }\n\n      ja[i].push(val);\n    });\n\n    // Now, pull out the longest common subsequence.\n\n    let lcs = [];\n\n    if (0 < ja.length) {\n      let n = ja.length - 1;\n      lcs = [ja[n][ja[n].length - 1]];\n\n      while (lcs[lcs.length - 1].prev) {\n        lcs.push(lcs[lcs.length - 1].prev);\n      }\n    }\n\n    return lcs.reverse();\n  }\n\n  // \"result\" is the array used to accumulate the aLines that are deleted, the\n  // lines that are shared between aLines and bLines, and the bLines that were\n  // inserted.\n\n  const result = [];\n  let deleted = 0;\n  let inserted = 0;\n\n  // aMove and bMove will contain the lines that don't match, and will be returned\n  // for possible searching of lines that moved.\n\n  const aMove = [];\n  const aMoveIndex = [];\n  const bMove = [];\n  const bMoveIndex = [];\n\n  //\n  // addToResult simply pushes the latest value onto the \"result\" array.  This\n  // array captures the diff of the line, aIndex, and bIndex from the aLines\n  // and bLines array.\n  //\n\n  function addToResult(aIndex, bIndex) {\n    if (bIndex < 0) {\n      aMove.push(aLines[aIndex]);\n      aMoveIndex.push(result.length);\n      deleted++;\n    } else if (aIndex < 0) {\n      bMove.push(bLines[bIndex]);\n      bMoveIndex.push(result.length);\n      inserted++;\n    }\n\n    result.push({\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n      aIndex: aIndex,\n      bIndex: bIndex,\n    });\n  }\n\n  //\n  // addSubMatch handles the lines between a pair of entries in the LCS.  Thus,\n  // this function might recursively call recurseLCS to further match the lines\n  // between aLines and bLines.\n  //\n\n  function addSubMatch(aLo, aHi, bLo, bHi) {\n    // Match any lines at the beginning of aLines and bLines.\n\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n      addToResult(aLo++, bLo++);\n    }\n\n    // Match any lines at the end of aLines and bLines, but don't place them\n    // in the \"result\" array just yet, as the lines between these matches at\n    // the beginning and the end need to be analyzed first.\n\n    let aHiTemp = aHi;\n\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n      aHi--;\n      bHi--;\n    }\n\n    // Now, check to determine with the remaining lines in the subsequence\n    // whether there are any unique common lines between aLines and bLines.\n    //\n    // If not, add the subsequence to the result (all aLines having been\n    // deleted, and all bLines having been inserted).\n    //\n    // If there are unique common lines between aLines and bLines, then let's\n    // recursively perform the patience diff on the subsequence.\n\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n    if (uniqueCommonMap.size === 0) {\n      while (aLo <= aHi) {\n        addToResult(aLo++, -1);\n      }\n\n      while (bLo <= bHi) {\n        addToResult(-1, bLo++);\n      }\n    } else {\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n    }\n\n    // Finally, let's add the matches at the end to the result.\n\n    while (aHi < aHiTemp) {\n      addToResult(++aHi, ++bHi);\n    }\n  }\n\n  //\n  // recurseLCS finds the longest common subsequence (LCS) between the arrays\n  // aLines[aLo..aHi] and bLines[bLo..bHi] inclusive.  Then for each subsequence\n  // recursively performs another LCS search (via addSubMatch), until there are\n  // none found, at which point the subsequence is dumped to the result.\n  //\n\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\n    const x = longestCommonSubsequence(\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\n    );\n\n    if (x.length === 0) {\n      addSubMatch(aLo, aHi, bLo, bHi);\n    } else {\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n      }\n\n      let i = 0;\n      for (; i < x.length - 1; i++) {\n        addSubMatch(\n          x[i].indexA,\n          x[i + 1].indexA - 1,\n          x[i].indexB,\n          x[i + 1].indexB - 1\n        );\n      }\n\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n      }\n    }\n  }\n\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n  if (diffPlusFlag) {\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n      aMove: aMove,\n      aMoveIndex: aMoveIndex,\n      bMove: bMove,\n      bMoveIndex: bMoveIndex,\n    };\n  }\n\n  return {\n    lines: result,\n    lineCountDeleted: deleted,\n    lineCountInserted: inserted,\n    lineCountMoved: 0,\n  };\n}\n\nconst diffResult = patienceDiff(\n  props.prevCode ? props.prevCode.split(/\\r\\n|\\n/) : [],\n  props.currentCode.split(/\\r\\n|\\n/)\n);\n\nif (props.findUniqueResult)\n  props.findUniqueResult(\n    diffResult.lineCountDeleted,\n    diffResult.lineCountInserted,\n    props.currentCode.split(/\\r\\n|\\n/).length,\n    props.prevCode ? props.prevCode.split(/\\r\\n|\\n/).length : 0,\n    diffResult.lines.length\n  );\n\nlet longestLineLength = 0;\ndiffResult.lines.forEach((line) => {\n  if (line.line.length > longestLineLength)\n    longestLineLength = line.line.length;\n});\n\nconst forMobile = false;\n\nconst lineProps = (lineNumber) => {\n  const line = diffResult.lines[lineNumber - 1];\n  let conditionalTopMargin = \"0\";\n  let conditionalBottomMargin = \"0\";\n  if (lineNumber === 1) {\n    conditionalTopMargin = \"-1em\";\n  } else if (lineNumber === diffResult.lines.length)\n    conditionalBottomMargin = \"-1em\";\n\n  let style = {\n    display: \"block\",\n    width: \"auto\",\n    background: \"#fff\",\n    marginRight: forMobile\n      ? `-${parseInt(longestLineLength * 0.36)}em`\n      : `-1em`,\n    marginLeft: \"-1em\",\n    marginTop: conditionalTopMargin,\n    marginBottom: conditionalBottomMargin,\n    paddingLeft: \"1em\",\n    color: \"black\",\n  };\n\n  if (line.aIndex === -1 || line.bIndex === -1) {\n    style = {\n      ...style,\n    };\n  }\n\n  if (line.aIndex === -1) {\n    style = {\n      ...style,\n      background: \"#E0FFEC\",\n      ...props.addStyle,\n    };\n  }\n  if (line.bIndex === -1) {\n    style = {\n      ...style,\n      background: \"#FFEDF0\",\n      ...props.deleteStyle,\n    };\n  }\n  //set for mobile true so next run does mobile styling.\n  forMobile = true;\n  return { style };\n};\n\nconst codeText = diffResult.lines.map((el) => el.line).join(\"\\n\");\n\nconst ShowOnDesktop = styled.div`\n  display: block;\n\n  @media (min-width: 1200px) {\n    display: block;\n\n  }\n`;\n\nconst ShowOnMobile = styled.div`\n  display: none;\n\n  @media (max-width: 1200px) {\n    display: none;\n\n  }\n`;\n\nreturn (\n  <>\n    <ShowOnDesktop>\n      <Markdown\n        text={`\n\\`\\`\\`\\text\n${codeText}\n`}\n        syntaxHighlighterProps={{\n          wrapLines: true,\n          lineProps,\n          showLineNumbers: true,\n          lineNumberStyle: { display: !props.showLineNumber && \"none\" },\n        }}\n      />\n    </ShowOnDesktop>\n    <ShowOnMobile>\n      <Markdown\n        text={`\n\\`\\`\\`\\text\n${codeText}\n`}\n        syntaxHighlighterProps={{\n          wrapLines: true,\n          lineProps,\n          showLineNumbers: true,\n          lineNumberStyle: { display: !props.showLineNumber && \"none\" },\n        }}\n      />\n    </ShowOnMobile>\n  </>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/markeljan.near/widget/MarkdownDiff", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.name": NaN, "metadata.tags.codediff": NaN, "metadata.tags.devgovgigs": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.tags.markdown": NaN}