{"tx_hash": "DZRcg3vzSpyFhEjS3gbexUwu22cf4Wc6ioGyQU6iau8H", "action_id_social": "DArkrkdC9yvrE4VWWsJteMKov9GQ9xpmBuMV7snTJ5sk-0-widget", "block_id": 86513475, "block_timestamp": "2023-03-04 04:45:37.270", "signer_id": "markeljan.near", "widget_name": "MarkdownDiff", "source_code": "/*\n//fork from bozon.near/widget/CodeDiff\nChanges made to styles and to support markdown.\n---props---\ncurrentCode: string,\nprevCode?: string,\n\nfindUniqueResult(\n  lineCountDeleted: number, \n  lineCountInserted: inserted,\n  lineCountCurrentCode: number,\n  lineCountPrevCode: number,\n  allLineCount: number\n)?: function\n\naddStyle?: Object,\ndeleteStyle?: Object\n\nshowLineNumber?: bool\n\n*/\n\nif (typeof props?.currentCode !== \"string\")\n  return \"send {currentCode: string} in props\";\n\nconst MAX_CHARS_PER_LINE = 120;\n\nfunction formatText(markdownString) {\n  const lines = markdownString.split(\"\\n\");\n  const formattedLines = [];\n  for (let line of lines) {\n    if (line.length <= MAX_CHARS_PER_LINE) {\n      formattedLines.push(line);\n      continue;\n    }\n    let splitIndex = MAX_CHARS_PER_LINE;\n    while (splitIndex > 0 && line.charAt(splitIndex) !== \" \") {\n      splitIndex--;\n    }\n    if (splitIndex === 0) {\n      formattedLines.push(line.substring(0, MAX_CHARS_PER_LINE));\n      line = line.substring(MAX_CHARS_PER_LINE);\n    } else {\n      formattedLines.push(line.substring(0, splitIndex));\n      line = line.substring(splitIndex + 1);\n    }\n    while (line.length > MAX_CHARS_PER_LINE) {\n      splitIndex = MAX_CHARS_PER_LINE;\n      while (splitIndex > 0 && line.charAt(splitIndex) !== \" \") {\n        splitIndex--;\n      }\n      if (splitIndex === 0) {\n        formattedLines.push(line.substring(0, MAX_CHARS_PER_LINE));\n        line = line.substring(MAX_CHARS_PER_LINE);\n      } else {\n        formattedLines.push(line.substring(0, splitIndex));\n        line = line.substring(splitIndex + 1);\n      }\n    }\n    formattedLines.push(line);\n  }\n  return formattedLines.join(\"\\n\");\n}\n\nconst modifiedCurrentCode = formatText(props.currentCode);\nconst modifiedPrevCode = formatText(props.prevCode);\n//code from this - https://github.com/jonTrent/PatienceDiff\nfunction patienceDiff(aLines, bLines, diffPlusFlag) {\n  function findUnique(arr, lo, hi) {\n    const lineMap = new Map();\n\n    for (let i = lo; i <= hi; i++) {\n      let line = arr[i];\n\n      if (lineMap.has(line)) {\n        lineMap.get(line).count++;\n        lineMap.get(line).index = i;\n      } else {\n        lineMap.set(line, {\n          count: 1,\n          index: i,\n        });\n      }\n    }\n\n    lineMap.forEach((val, key) => {\n      if (val.count !== 1) {\n        lineMap.delete(key);\n      } else {\n        lineMap.set(key, val.index);\n      }\n    });\n\n    return lineMap;\n  }\n\n  function uniqueCommon(aArray, aLo, aHi, bArray, bLo, bHi) {\n    const ma = findUnique(aArray, aLo, aHi);\n    const mb = findUnique(bArray, bLo, bHi);\n\n    ma.forEach((val, key) => {\n      if (mb.has(key)) {\n        ma.set(key, {\n          indexA: val,\n          indexB: mb.get(key),\n        });\n      } else {\n        ma.delete(key);\n      }\n    });\n\n    return ma;\n  }\n\n  function longestCommonSubsequence(abMap) {\n    const ja = [];\n\n    abMap.forEach((val, key, map) => {\n      let i = 0;\n\n      while (ja[i] && ja[i][ja[i].length - 1].indexB < val.indexB) {\n        i++;\n      }\n\n      if (!ja[i]) {\n        ja[i] = [];\n      }\n\n      if (0 < i) {\n        val.prev = ja[i - 1][ja[i - 1].length - 1];\n      }\n\n      ja[i].push(val);\n    });\n\n    let lcs = [];\n\n    if (0 < ja.length) {\n      let n = ja.length - 1;\n      lcs = [ja[n][ja[n].length - 1]];\n\n      while (lcs[lcs.length - 1].prev) {\n        lcs.push(lcs[lcs.length - 1].prev);\n      }\n    }\n\n    return lcs.reverse();\n  }\n\n  const result = [];\n  let deleted = 0;\n  let inserted = 0;\n\n  const aMove = [];\n  const aMoveIndex = [];\n  const bMove = [];\n  const bMoveIndex = [];\n\n  function addToResult(aIndex, bIndex) {\n    if (bIndex < 0) {\n      aMove.push(aLines[aIndex]);\n      aMoveIndex.push(result.length);\n      deleted++;\n    } else if (aIndex < 0) {\n      bMove.push(bLines[bIndex]);\n      bMoveIndex.push(result.length);\n      inserted++;\n    }\n\n    result.push({\n      line: 0 <= aIndex ? aLines[aIndex] : bLines[bIndex],\n      aIndex: aIndex,\n      bIndex: bIndex,\n    });\n  }\n\n  function addSubMatch(aLo, aHi, bLo, bHi) {\n    while (aLo <= aHi && bLo <= bHi && aLines[aLo] === bLines[bLo]) {\n      addToResult(aLo++, bLo++);\n    }\n\n    let aHiTemp = aHi;\n\n    while (aLo <= aHi && bLo <= bHi && aLines[aHi] === bLines[bHi]) {\n      aHi--;\n      bHi--;\n    }\n\n    const uniqueCommonMap = uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi);\n\n    if (uniqueCommonMap.size === 0) {\n      while (aLo <= aHi) {\n        addToResult(aLo++, -1);\n      }\n\n      while (bLo <= bHi) {\n        addToResult(-1, bLo++);\n      }\n    } else {\n      recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap);\n    }\n\n    while (aHi < aHiTemp) {\n      addToResult(++aHi, ++bHi);\n    }\n  }\n\n  function recurseLCS(aLo, aHi, bLo, bHi, uniqueCommonMap) {\n    const x = longestCommonSubsequence(\n      uniqueCommonMap || uniqueCommon(aLines, aLo, aHi, bLines, bLo, bHi)\n    );\n\n    if (x.length === 0) {\n      addSubMatch(aLo, aHi, bLo, bHi);\n    } else {\n      if (aLo < x[0].indexA || bLo < x[0].indexB) {\n        addSubMatch(aLo, x[0].indexA - 1, bLo, x[0].indexB - 1);\n      }\n\n      let i = 0;\n      for (; i < x.length - 1; i++) {\n        addSubMatch(\n          x[i].indexA,\n          x[i + 1].indexA - 1,\n          x[i].indexB,\n          x[i + 1].indexB - 1\n        );\n      }\n\n      if (x[i].indexA <= aHi || x[i].indexB <= bHi) {\n        addSubMatch(x[i].indexA, aHi, x[i].indexB, bHi);\n      }\n    }\n  }\n\n  recurseLCS(0, aLines.length - 1, 0, bLines.length - 1);\n\n  if (diffPlusFlag) {\n    return {\n      lines: result,\n      lineCountDeleted: deleted,\n      lineCountInserted: inserted,\n      lineCountMoved: 0,\n      aMove: aMove,\n      aMoveIndex: aMoveIndex,\n      bMove: bMove,\n      bMoveIndex: bMoveIndex,\n    };\n  }\n\n  return {\n    lines: result,\n    lineCountDeleted: deleted,\n    lineCountInserted: inserted,\n    lineCountMoved: 0,\n  };\n}\n\nconst diffResult = patienceDiff(\n  modifiedPrevCode ? modifiedPrevCode.split(/\\r\\n|\\n/) : [],\n  modifiedCurrentCode.split(/\\r\\n|\\n/)\n);\n\nif (props.findUniqueResult)\n  props.findUniqueResult(\n    diffResult.lineCountDeleted,\n    diffResult.lineCountInserted,\n    modifiedCurrentCode.split(/\\r\\n|\\n/).length,\n    modifiedPrevCode ? modifiedPrevCode.split(/\\r\\n|\\n/).length : 0,\n    diffResult.lines.length\n  );\n\nlet longestLineLength = 0;\ndiffResult.lines.forEach((line) => {\n  if (line.line.length > longestLineLength)\n    longestLineLength = line.line.length;\n});\n\nconst linePropsDesktop = (lineNumber) => {\n  const line = diffResult.lines[lineNumber - 1];\n  let conditionalTopMargin = \"0\";\n  let conditionalBottomMargin = \"0\";\n  if (lineNumber === 1) {\n    conditionalTopMargin = \"-1em\";\n  } else if (lineNumber === diffResult.lines.length)\n    conditionalBottomMargin = \"-1em\";\n\n  let style = {\n    display: \"block\",\n    width: \"auto\",\n    background: \"#fff\",\n    marginRight: `-1em`,\n    marginLeft: \"-1em\",\n    marginTop: conditionalTopMargin,\n    marginBottom: conditionalBottomMargin,\n    paddingLeft: \"1em\",\n    color: \"black\",\n  };\n\n  if (line.aIndex === -1 || line.bIndex === -1) {\n    style = {\n      ...style,\n    };\n  }\n\n  if (line.aIndex === -1) {\n    style = {\n      ...style,\n      background: \"#E0FFEC\",\n      ...props.addStyle,\n    };\n  }\n  if (line.bIndex === -1) {\n    style = {\n      ...style,\n      background: \"#FFEDF0\",\n      ...props.deleteStyle,\n    };\n  }\n  return { style };\n};\n\nconst linePropsMobile = (lineNumber) => {\n  const line = diffResult.lines[lineNumber - 1];\n  let conditionalTopMargin = \"0\";\n  let conditionalBottomMargin = \"0\";\n  if (lineNumber === 1) {\n    conditionalTopMargin = \"-1em\";\n  } else if (lineNumber === diffResult.lines.length)\n    conditionalBottomMargin = \"-1em\";\n\n  let style = {\n    display: \"block\",\n    width: \"auto\",\n    background: \"#fff\",\n    marginRight: `-${parseInt(longestLineLength * 0.6)}em`,\n    marginLeft: \"-1em\",\n    marginTop: conditionalTopMargin,\n    marginBottom: conditionalBottomMargin,\n    paddingLeft: \"1em\",\n    color: \"black\",\n  };\n\n  if (line.aIndex === -1 || line.bIndex === -1) {\n    style = {\n      ...style,\n    };\n  }\n\n  if (line.aIndex === -1) {\n    style = {\n      ...style,\n      background: \"#E0FFEC\",\n      ...props.addStyle,\n    };\n  }\n  if (line.bIndex === -1) {\n    style = {\n      ...style,\n      background: \"#FFEDF0\",\n      ...props.deleteStyle,\n    };\n  }\n  return { style };\n};\n\nconst codeText = diffResult.lines.map((el) => el.line).join(\"\\n\");\n\nconst ShowOnDesktop = styled.div`\n  display: none;\n\n  @media (min-width: 1200px) {\n    display: block;\n\n  }\n`;\n\nconst ShowOnMobile = styled.div`\n  display: none;\n\n  @media (max-width: 1200px) {\n    display: block;\n\n  }\n`;\n\nreturn (\n  <>\n    <ShowOnDesktop>\n      <Markdown\n        text={`\n\\`\\`\\`\\text\n${codeText}\n`}\n        syntaxHighlighterProps={{\n          wrapLines: true,\n          lineProps: linePropsDesktop,\n          showLineNumbers: true,\n          lineNumberStyle: { display: !props.showLineNumber && \"none\" },\n        }}\n      />\n    </ShowOnDesktop>\n    <ShowOnMobile>\n      <Markdown\n        text={`\n\\`\\`\\`\\text\n${codeText}\n`}\n        syntaxHighlighterProps={{\n          wrapLines: true,\n          lineProps: linePropsMobile,\n          showLineNumbers: true,\n          lineNumberStyle: { display: !props.showLineNumber && \"none\" },\n        }}\n      />\n    </ShowOnMobile>\n  </>\n);\n", "metadata": NaN, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/markeljan.near/widget/MarkdownDiff", "metadata.description": NaN, "metadata.image.ipfs_cid": NaN, "metadata.name": NaN, "metadata.tags.codediff": NaN, "metadata.tags.devgovgigs": NaN, "metadata.tags.ethdenver2023": NaN, "metadata.tags.markdown": NaN}