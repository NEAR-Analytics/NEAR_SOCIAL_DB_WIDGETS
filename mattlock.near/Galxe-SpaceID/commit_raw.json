{"tx_hash": null, "action_id_social": "AR9nmkNVXGyp85qoApnK9NUoD2GYhZJRmLwPomkuNCJr-0-widget", "block_id": 93707012, "block_timestamp": "2023-06-08T03:05:26.329Z", "signer_id": "mattlock.near", "widget_name": "Galxe-SpaceID", "source_code": "if (\n  state.chainId === undefined &&\n  ethers !== undefined &&\n  Ethers.send(\"eth_requestAccounts\", [])[0]\n) {\n  Ethers.provider()\n    .getNetwork()\n    .then((chainIdData) => {\n      if (chainIdData?.chainId) {\n        State.update({ chainId: chainIdData.chainId });\n      }\n    });\n}\nif (state.chainId !== undefined && state.chainId !== 56) {\n  return (\n    <div>\n      {\" \"}\n      <p>Please switch to BNB Chain</p>{\" \"}\n      <a\n        href={`https://academy.binance.com/en/articles/connecting-metamask-to-binance-smart-chain`}\n      >\n        {\" \"}\n        Guide{\" \"}\n      </a>{\" \"}\n    </div>\n  );\n}\n//Campaigns\nconst dataMap = {\n  GCr4FUxghP: {\n    src: `https://cdn.galxe.com/galaxy/spaceid/1d471e0c-2783-4b52-90eb-3db0b2403198.png?optimizer=image&width=800&quality=100`,\n  },\n  GCi5FUxkZz: {\n    src: `https://cdn.galxe.com/galaxy/spaceid/aa8dcc5b-fc27-47d8-bd1b-09b32440d5ac.png?optimizer=image&width=800&quality=100`,\n  },\n  GCiFFUxgPJ: {\n    src: `https://cdn.galxe.com/galaxy/spaceid/3c115abf-2888-46c7-a83a-76d25de88989.png?optimizer=image&width=800&quality=100`,\n  },\n};\nconst toast = (toast) => {\n  State.update({ toast });\n};\nconst css = `  button,  button:disabled,  button[disabled] {    background: rgb(30, 239, 164);    color: black;    border: none;    font-weight: bold;    &:hover {      border: rgb(30, 239, 164);      background: rgb(16, 204, 137);      color: black;    }  }  button:disabled,  button[disabled]{    background: rgb(16, 204, 137, 0.5);  }  .main {    padding: 16px;    margin: auto;    margin-top: -16px;    width: 100%;    max-width: 1000px;    text-align: left;    position: relative;    background: black;    border-radius: 0 0 16px 16px;    color: rgb(199, 210, 215);  }  .boxes {    margin: auto;    max-width: 864px;    display: flex;    flex-flow: row wrap;    > div {      border: 1px solid #222;      margin: 16px;      padding: 8px;      text-align: center;      width: 256px;      > img {        width: 256px;      }      .break {        margin: 16px 0 16px 0;        height: 1px;        background-size: 100%;        background-image: url(https://galxe.com/_nuxt/img/bar.57178f2.png);      }      > button {        margin-bottom: 12px;      }      > h4 {        margin: 16px 0 16px 0;        font-size: 1.2rem;      }      > p.not {        color: rgb(168, 174, 186);      }    }      }`;\nif (!css) return \"\";\n\nif (!state.theme) {\n  State.update({\n    theme: styled.div`    box-sizing: border-box;    font-family: Sans-Serif;    ${css}`,\n  });\n}\nconst Theme = state.theme;\nconst init = () => {\n  console.log(\"init\");\n  const name = Storage.get(NAME);\n  let address;\n  if (state.address === undefined) {\n    const accounts = Ethers.send(\"eth_requestAccounts\", []);\n    if (accounts.length) {\n      address = accounts[0];\n      State.update({ address, name });\n    }\n  }\n  if (!address) {\n    address = state.address;\n  }\n  const queryRes = fetch(\n    `https://galxe-proxy.near.workers.dev?url=https://graphigo.prd.galaxy.eco/query`,\n    {\n      subscribe: true,\n      method: \"POST\",\n      body: JSON.stringify({\n        operationName: \"CampaignInfoWidthAddress\",\n        variables: { address, id: \"GCUtLUxWjp\" },\n        query:\n          \"query CampaignInfoWidthAddress($id: ID!, $address: String!) {  campaign(id: $id) {    ...CampaignDetailFrag    userParticipants(address: $address, first: 1) {      list {        status        premintTo        __typename      }      __typename    }    space {      ...SpaceDetail      isAdmin(address: $address)      __typename    }    isBookmarked(address: $address)    claimedLoyaltyPoints(address: $address)    childrenCampaigns {      ...CampaignDetailFrag      userParticipants(address: $address, first: 1) {        list {          status          __typename        }        __typename      }      parentCampaign {        id        __typename      }      __typename    }    __typename  }}fragment CampaignDetailFrag on Campaign {  id  ...CampaignMedia  name  numberID  type  cap  info  useCred  formula  status  creator  thumbnail  gasType  isPrivate  createdAt  requirementInfo  description  enableWhitelist  chain  startTime  endTime  requireEmail  requireUsername  blacklistCountryCodes  whitelistRegions  rewardType  distributionType  rewardName  claimEndTime  loyaltyPoints  tokenRewardContract {    id    address    chain    __typename  }  tokenReward {    userTokenAmount    tokenAddress    depositedTokenAmount    tokenRewardId    __typename  }  nftHolderSnapshot {    holderSnapshotBlock    __typename  }  spaceStation {    id    address    chain    __typename  }  ...WhitelistInfoFrag  ...WhitelistSubgraphFrag  gamification {    ...GamificationDetailFrag    __typename  }  creds {    ...CredForAddress    __typename  }  credentialGroups(address: $address) {    ...CredentialGroupForAddress    __typename  }  dao {    ...DaoSnap    nftCores {      list {        capable        marketLink        contractAddress        __typename      }      __typename    }    __typename  }  rewardInfo {    discordRole {      guildId      guildName      roleId      roleName      inviteLink      __typename    }    premint {      startTime      endTime      chain      price      totalSupply      contractAddress      banner      __typename    }    loyaltyPoints {      points      __typename    }    loyaltyPointsMysteryBox {      points      __typename    }    __typename  }  participants {    participantsCount    bountyWinnersCount    __typename  }  __typename}fragment DaoSnap on DAO {  id  name  logo  alias  isVerified  __typename}fragment CampaignMedia on Campaign {  thumbnail  rewardName  type  gamification {    id    type    __typename  }  __typename}fragment CredForAddress on Cred {  id  name  type  credType  credSource  referenceLink  description  lastUpdate  credContractNFTHolder {    timestamp    __typename  }  chain  eligible(address: $address)  subgraph {    endpoint    query    expression    __typename  }  __typename}fragment CredentialGroupForAddress on CredentialGroup {  id  description  credentials {    ...CredForAddress    __typename  }  conditionRelation  conditions {    expression    eligible    __typename  }  rewards {    expression    eligible    rewardCount    rewardType    __typename  }  rewardAttrVals {    attrName    attrTitle    attrVal    __typename  }  claimedLoyaltyPoints  __typename}fragment WhitelistInfoFrag on Campaign {  id  whitelistInfo(address: $address) {    address    maxCount    usedCount    __typename  }  __typename}fragment WhitelistSubgraphFrag on Campaign {  id  whitelistSubgraph {    query    endpoint    expression    variable    __typename  }  __typename}fragment GamificationDetailFrag on Gamification {  id  type  nfts {    nft {      id      animationURL      category      powah      image      name      treasureBack      nftCore {        ...NftCoreInfoFrag        __typename      }      traits {        name        value        __typename      }      __typename    }    __typename  }  airdrop {    name    contractAddress    token {      address      icon      symbol      __typename    }    merkleTreeUrl    addressInfo(address: $address) {      index      amount {        amount        ether        __typename      }      proofs      __typename    }    __typename  }  forgeConfig {    minNFTCount    maxNFTCount    requiredNFTs {      nft {        category        powah        image        name        nftCore {          capable          contractAddress          __typename        }        __typename      }      count      __typename    }    __typename  }  __typename}fragment NftCoreInfoFrag on NFTCore {  id  capable  chain  contractAddress  name  symbol  dao {    id    name    logo    alias    __typename  }  __typename}fragment SpaceDetail on Space {  id  name  info  thumbnail  alias  links  isVerified  discordGuildID  __typename}\",\n      }),\n    }\n  );\n  State.update({ data: JSON.parse(queryRes.body).data });\n};\ninit();\nconsole.log(\"data\", state.data);\nif (!state.data)\n  return (\n    <Theme>\n      {\" \"}\n      <div class=\"main\">\n        {\" \"}\n        <h2>SPACE ID Voyage Season 2 - Calling</h2>{\" \"}\n        <p>Register a .bnb domain name and claim a Voyage Box</p>{\" \"}\n        <Web3Connect connectLabel=\"Connect with Web3\" />{\" \"}\n      </div>{\" \"}\n    </Theme>\n  );\n\nconst handleClaim = (id) => {\n  const queryRes1 = fetch(\n    `https://galxe-proxy.near.workers.dev?url=https://graphigo.prd.galaxy.eco/query`,\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        operationName: \"SufficientForGaslessChainQuery\",\n        variables: { id: \"344\", chains: [\"BSC\"] },\n        query:\n          \"query SufficientForGaslessChainQuery($id: Int, $chains: [Chain!]!) {  space(id: $id) {    spaceBalance {      sufficientForGaslessClaimOnChain(chains: $chains) {        sufficient        chain        __typename      }      __typename    }    __typename  }}\",\n      }),\n    }\n  );\n  const { sufficient } =\n    queryRes1.body.data.space.spaceBalance.sufficientForGaslessClaimOnChain;\n  if (!sufficient) {\n    return toast(\"Not enough sufficient balance for gasless claim on chain!\");\n  }\n  const queryRes2 = fetch(\n    `https://galxe-proxy.near.workers.dev?a=123&url=https://graphigo.prd.galaxy.eco/query`,\n    {\n      method: \"POST\",\n      body: JSON.stringify({\n        operationName: \"PrepareParticipate\",\n        variables: {\n          input: {\n            signature: \"\",\n            campaignID: id,\n            address: state.address,\n            mintCount: 1,\n            chain: \"BSC\",\n            captcha: {\n              lotNumber: \"0974770267a14e8f8a4802d4750b16b3\",\n              captchaOutput:\n                \"pJEPZ0JxeomN0EEvex0UjDCjy5hTOjN16CmGspGRsg6YHH7F2uO0on-XbISrHxUVmUxSW_3LqveBUYDyaqCTIEKcs--6SnjyBdzLuCR-pK4PfAckYPRnPOkqQnyLR-TkX-osO08iP3n_VbG9yM8CIJNkQZYWGeypyG_ulQT-x2QdwXAsABTPo0vBHw43GCnrkwdROv5npo3RNdOG7bMVW87fOFenVFa9Q4X7fdnK6MAAyKr1j5bfdipX_c59G4J1rLP04nvJYi3QnFg_eqmVmQ==\",\n              passToken:\n                \"dd275b5ec2272a31df8c7c6664146b8fb48b4ea78d3d7140cf2a46d1b51930e9\",\n              genTime: \"1682041909\",\n            },\n          },\n        },\n        query:\n          \"mutation PrepareParticipate($input: PrepareParticipateInput!) {  prepareParticipate(input: $input) {    allow    disallowReason    signature    nonce    mintFuncInfo {      funcName      nftCoreAddress      verifyIDs      powahs      cap      __typename    }    extLinkResp {      success      data      error      __typename    }    metaTxResp {      metaSig2      autoTaskUrl      metaSpaceAddr      forwarderAddr      metaTxHash      reqQueueing      __typename    }    solanaTxResp {      mint      updateAuthority      explorerUrl      signedTx      verifyID      __typename    }    aptosTxResp {      signatureExpiredAt      tokenName      __typename    }    tokenRewardCampaignTxResp {      signatureExpiredAt      verifyID      __typename    }    loyaltyPointsTxResp {      TotalClaimedPoints      __typename    }    __typename  }}\",\n      }),\n    }\n  );\n  try {\n    const { TotalClaimedPoints } = data.prepareParticipate.loyaltyPointsTxResp;\n    if (TotalClaimedPoints > 0) {\n      return toast(`You received: ${TotalClaimedPoints} points!`);\n    }\n    throw \"no points\";\n  } catch (e) {\n    return toast(`Error claiming!`);\n  }\n};\nreturn (\n  <Theme>\n    {\" \"}\n    <Widget src=\"mattlock.near/widget/SPACEID-BNB\" />{\" \"}\n    <div class=\"main\">\n      {\" \"}\n      <p>\n        {\" \"}\n        After registering a .bnb domain above, you will be eligible for the\n        SPACE ID campaign below!{\" \"}\n      </p>{\" \"}\n      <h2>SPACE ID Voyage Season 2 - Calling</h2>{\" \"}\n      <p>\n        {\" \"}\n        There are three types of Voyage Boxes of varying rarity, each containing\n        random points that can be claimed. The box with the higher rarity will\n        give you more points.{\" \"}\n      </p>{\" \"}\n      {state.toast && (\n        <div class=\"toasted-container\">\n          {\" \"}\n          <div class=\"toasted\">\n            {\" \"}\n            {state.toast}{\" \"}\n            <div class=\"close\" onClick={() => State.update({ toast: null })}>\n              {\" \"}\n              \u2a09{\" \"}\n            </div>{\" \"}\n          </div>{\" \"}\n        </div>\n      )}{\" \"}\n      <div class=\"boxes\">\n        {\" \"}\n        {state.data.campaign.childrenCampaigns.map(\n          ({ id, name, whitelistInfo: { maxCount, usedCount } }, i) => {\n            const eligible = maxCount - 1 === usedCount;\n            return (\n              <div key={id}>\n                {\" \"}\n                <h4>{name}</h4> <img src={dataMap[id].src} />{\" \"}\n                <div class=\"break\"></div>{\" \"}\n                {eligible ? (\n                  <p>You are eligible</p>\n                ) : (\n                  <p class=\"not\">You are not eligible</p>\n                )}{\" \"}\n                <button disabled={!eligible} onClick={() => handleClaim(id)}>\n                  {\" \"}\n                  Claim{\" \"}\n                </button>{\" \"}\n              </div>\n            );\n          }\n        )}{\" \"}\n      </div>{\" \"}\n    </div>{\" \"}\n  </Theme>\n);\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/mattlock.near/widget/Galxe-SpaceID", "__row_index": 1}