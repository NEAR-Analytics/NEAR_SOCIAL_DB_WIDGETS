{"tx_hash": "5XUHrCh3ttbC2S96Sx38k4tg2x9yMPw1NbZRNxd7EQkU", "action_id_social": "AZs4AiNWqu2YrFM6vSbZkcZkyZrAxSg2VMJohuUn2Pu6-0-widget", "block_id": 90870159, "block_timestamp": "2023-05-01 18:00:54.382", "signer_id": "juaner.near", "widget_name": "ref_burrow-data-test", "source_code": "const accountId = \"reffer.near\";\nconst BURROW_CONTRACT = \"contract.main.burrow.near\";\nconst netLiquidityFarm = Near.view(BURROW_CONTRACT, \"get_asset_farm\", {\n  farm_id: \"NetTvl\",\n});\nconst unique = (value, index, self) => {\n  return self.indexOf(value) === index;\n};\n\nconst sumReducer = (sum, a) => sum + a;\n\nfunction power(x, y) {\n  if (y === 0) {\n    return 1;\n  } else if (y % 2 === 0) {\n    return power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  } else {\n    return x * power(x, parseInt(y / 2)) * power(x, parseInt(y / 2));\n  }\n}\nfunction getGains(account, assets, source) {\n  return account[source]\n    .map((accountAsset) => {\n      const { token_id, balance, apr } = accountAsset;\n      const asset = assets.find((asset) => asset.token_id == token_id);\n      const netTvlMultiplier = asset.config.net_tvl_multiplier / 10000;\n      const balanceUSD = toUsd(balance, asset);\n      return [balanceUSD * (withNetTvlMultiplier ? netTvlMultiplier : 1), apr];\n    })\n    .reduce(\n      ([gain, sum], [balance, apr]) => [gain + balance * apr, sum + balance],\n      [0, 0]\n    );\n}\nfunction getNetTvlRewards(assets, account) {\n  const hasNetTvlFarm = !!Object.entries(netLiquidityFarm.rewards).length;\n  if (!hasNetTvlFarm) return [];\n  const netTvl = account.farms.find((farm) => farm.farm_id == \"NetTvl\");\n  if (!netTvl.rewards) return [];\n  return netTvl.rewards.map((reward) => {\n    const { asset_farm_reward, boosted_shares, reward_token_id } = reward;\n    const asset = assets.find((asset) => asset.token_id == reward_token_id);\n    const assetDecimals = asset.metadata.decimals + asset.config.extra_decimals;\n    const boostedShares = Number(shrinkToken(boosted_shares, assetDecimals));\n    const totalBoostedShares = Number(\n      shrinkToken(asset_farm_reward[\"boosted_shares\"], assetDecimals)\n    );\n    const totalRewardsPerDay = Number(\n      shrinkToken(asset_farm_reward[\"reward_per_day\"], assetDecimals)\n    );\n    const dailyAmount =\n      (boostedShares / totalBoostedShares) * totalRewardsPerDay;\n    return { dailyAmount, token_id: reward_token_id, price: asset.price.usd };\n  });\n}\nconst toUsd = (balance, asset) =>\n  asset?.price?.usd\n    ? Number(\n        shrinkToken(\n          balance,\n          asset.metadata.decimals + asset.config.extra_decimals\n        )\n      ) * asset.price.usd\n    : 0;\n\n// transform tolen balance from big number decimal to number\nconst shrinkToken = (value, decimals, fixed) => {\n  return new Big(value).div(new Big(10).pow(decimals || 0)).toFixed(fixed);\n};\n// get all assets, metadata and pricing from burrow contracts\nfunction getAssets() {\n  const assets = Near.view(BURROW_CONTRACT, \"get_assets_paged\");\n  if (!assets) return;\n  const tokenIds = assets?.map(([id]) => id);\n  const assetsDetailed = tokenIds.map((token_id) =>\n    Near.view(BURROW_CONTRACT, \"get_asset\", { token_id })\n  );\n  if (!assetsDetailed) return;\n  const metadata = tokenIds?.map((token_id) =>\n    Near.view(token_id, \"ft_metadata\")\n  );\n  if (!metadata) return;\n\n  const config = Near.view(BURROW_CONTRACT, \"get_config\");\n  if (!config) return;\n\n  const prices =\n    config && Near.view(config?.[\"oracle_account_id\"], \"get_price_data\");\n\n  const refPricesResponse = fetch(\n    \"https://raw.githubusercontent.com/NearDeFi/token-prices/main/ref-prices.json\"\n  );\n  const refPrices = JSON.parse(refPricesResponse.body);\n\n  if (!config || !prices || !refPricesResponse) return;\n\n  const balances = accountId\n    ? tokenIds.map((token_id) =>\n        Near.view(token_id, \"ft_balance_of\", { account_id: accountId })\n      )\n    : undefined;\n\n  return assetsDetailed?.map((asset, i) => {\n    const price = prices?.prices?.find((p) => p.asset_id === asset?.token_id);\n    const priceDecimals =\n      parseInt(price?.price?.decimals || 0) - parseInt(metadata?.[i].decimals);\n    const usd = price?.price?.multiplier / power(10, priceDecimals);\n\n    const temp = Big(asset.supplied.balance)\n      .plus(Big(asset.reserved))\n      .minus(Big(asset.borrowed.balance));\n\n    const decimals = metadata?.[i].decimals + asset.config.extra_decimals;\n    const availableLiquidity = Number(shrinkToken(temp.toFixed(), decimals));\n    const extraPrice = price.price || {\n      decimals: Number(refPrices?.[asset.token_id]?.decimal),\n      multiplier: \"1\",\n    };\n    return {\n      ...asset,\n      metadata: metadata?.[i],\n      accountBalance: accountId ? balances?.[i] : undefined,\n      price: {\n        ...extraPrice,\n        usd: usd ? usd : parseFloat(refPrices?.[asset.token_id]?.price),\n      },\n      availableLiquidity,\n    };\n  });\n}\n\n// get balance of every asset on account\nconst getBalances = (assets) => {\n  if (!assets) return;\n  const balances = accountId\n    ? assets.map(({ token_id }) =>\n        Near.view(token_id, \"ft_balance_of\", { account_id: accountId })\n      )\n    : undefined;\n\n  return balances;\n};\n\n// sum all balances for supplied or borrowed\n// it's used for computing the net liquidity apy\nconst getTotalBalance = (assets, source) =>\n  assets\n    .map((asset) => {\n      const netTvlMultiplier = asset.config.net_tvl_multiplier / 10000;\n      return (\n        toUsd(asset[source].balance, asset) * netTvlMultiplier +\n        (source === \"supplied\"\n          ? toUsd(asset.reserved, asset) * netTvlMultiplier\n          : 0)\n      );\n    })\n    .reduce(sumReducer, 0);\n\nconst getNetLiquidityAPY = (assets, netLiquidityFarm, account) => {\n  const totalDailyNetLiquidityRewards = Object.entries(netLiquidityFarm.rewards)\n    .map(([rewardTokenId, farm]) => {\n      const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n      const assetDecimals =\n        rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n      const dailyAmount = Number(\n        shrinkToken(farm.reward_per_day, assetDecimals)\n      );\n      return (\n        dailyAmount *\n        rewardAsset.price.usd *\n        (rewardAsset.config.net_tvl_multiplier / 10000)\n      );\n    })\n    .reduce(sumReducer, 0);\n\n  const supplied = getTotalBalance(assets, \"supplied\");\n  const borrowed = getTotalBalance(assets, \"borrowed\");\n\n  const totalProtocolLiquidity = supplied - borrowed;\n  const netLiquidtyAPY =\n    ((totalDailyNetLiquidityRewards * 365) / totalProtocolLiquidity) * 100;\n\n  const rewardTokens = Object.entries(netLiquidityFarm.rewards).map(\n    ([rewardTokenId]) => rewardTokenId\n  );\n  let accountNetLiquidtyAPY;\n  if (account) {\n    const [gainCollateral, totalCollateral] = getGains(\n      account,\n      assets,\n      \"collateral\"\n    );\n    const [gainSupplied, totalSupplied] = getGains(account, assets, \"supplied\");\n    const accountTvlRewards = getNetTvlRewards(assets, account);\n    const netTvlRewards = accountTvlRewards.reduce(\n      (acc, r) => acc + r.dailyAmount * r.price,\n      0\n    );\n    const netLiquidity = totalCollateral + totalSupplied;\n    accountNetLiquidtyAPY = ((netTvlRewards * 365) / netLiquidity) * 100;\n  }\n\n  return [accountNetLiquidtyAPY || netLiquidtyAPY, rewardTokens];\n};\n\n// get all farm rewards for each asset\nconst getRewards = (assets, account) => {\n  if (!netLiquidityFarm) return;\n\n  const [apyRewardTvl, rewardTokensTVL] = getNetLiquidityAPY(\n    assets,\n    netLiquidityFarm,\n    account\n  );\n\n  const rewards = assets.map((asset) => {\n    const apyBase = asset[\"supply_apr\"] * 100;\n    const apyBaseBorrow = asset[\"borrow_apr\"] * 100;\n    const tokenId = asset.token_id;\n    const totalSupplyUsd = toUsd(asset.supplied.balance, asset);\n    const totalBorrowUsd = toUsd(asset.borrowed.balance, asset);\n\n    const suppliedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Supplied === tokenId)?.rewards ||\n      {};\n\n    const rewardTokens = Object.entries(suppliedFarmRewards)\n      .map(([rewardTokenId]) => rewardTokenId)\n      .concat(rewardTokensTVL)\n      .filter(unique);\n\n    const apyRewards = Object.entries(suppliedFarmRewards).map(\n      ([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n        if (!totalSupplyUsd) return 0;\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals || 0))\n            .mul(365)\n            .mul(price)\n            .div(totalSupplyUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      }\n    );\n\n    const apyReward = apyRewards.reduce(sumReducer, 0);\n\n    const borrowedFarmRewards =\n      asset.farms.find((farm) => farm.farm_id.Borrowed === tokenId)?.rewards ||\n      {};\n\n    const rewardTokensBorrow = Object.entries(borrowedFarmRewards).map(\n      ([rewardTokenId]) => rewardTokenId\n    );\n\n    const apyRewardBorrow = Object.entries(borrowedFarmRewards)\n      .map(([rewardTokenId, reward]) => {\n        const rewardAsset = assets.find((a) => a.token_id === rewardTokenId);\n        const decimals =\n          rewardAsset.metadata.decimals + rewardAsset.config.extra_decimals;\n        const price = rewardAsset.price?.usd || 0;\n\n        if (!totalBorrowUsd) return 0;\n\n        return (\n          new Big(reward.reward_per_day)\n            .div(new Big(10).pow(decimals || 0))\n            .mul(365)\n            .mul(price)\n            .div(totalBorrowUsd)\n            .mul(100)\n            .toNumber() || 0\n        );\n      })\n      .reduce(sumReducer, 0);\n\n    return {\n      token_id: asset.token_id,\n      symbol: asset.metadata.symbol,\n      tvlUsd: totalSupplyUsd - totalBorrowUsd,\n      apyReward,\n      apyRewardTvl: apyRewardTvl || 0,\n      apyBase,\n      rewardTokens,\n      totalSupplyUsd,\n      totalBorrowUsd,\n      apyBaseBorrow,\n      apyRewardBorrow,\n      rewardTokensBorrow,\n      ltv: asset.config.volatility_ratio,\n    };\n  });\n\n  return rewards;\n};\n\n// get account portfolio\nconst getAccount = () => {\n  if (!accountId) return null;\n  const account = Near.view(BURROW_CONTRACT, \"get_account\", {\n    account_id: accountId,\n  });\n  return account;\n};\n\nconst assets = getAssets();\n\nif (!assets) return <div />;\n\nconst balances = getBalances(assets);\nconst account = getAccount();\nconst rewards = getRewards(assets, account);\nif (!rewards) return <div />;\nconst data = {\n  assets,\n  rewards,\n  balances,\n  account,\n};\n\nif (typeof props.onLoad === \"function\") {\n  props.onLoad(data);\n}\n\nreturn <div />;\n", "metadata": null, "branch": null, "widget_modules_used": null, "widget_url": "https://near.social/#/juaner.near/widget/ref_burrow-data-test"}